# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Taichi Developers
# This file is distributed under the same license as the taichi package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: taichi 0.6.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-13 16:43+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: \n"
"Language: zh_CN\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../snode.rst:4
msgid "Structural nodes (SNodes)"
msgstr "结构节点 (SNodes)"

#: ../../snode.rst:6
msgid ""
"After writing the computation code, the user needs to specify the "
"internal data structure hierarchy. Specifying a data structure includes "
"choices at both the macro level, dictating how the data structure "
"components nest with each other and the way they represent sparsity, and "
"the micro level, dictating how data are grouped together (e.g. structure "
"of arrays vs. array of structures). Taichi provides *Structural Nodes "
"(SNodes)* to compose the hierarchy and particular properties. These "
"constructs and their semantics are listed below:"
msgstr ""
"在编写计算部分的代码之后，用户需要设定内部层次数据结构。包括微观和宏观两部分，宏观上设定层级数据结构组件之间的嵌套关系以及表示稀疏性的方式；微观上，描述数据如何分组(例如，SOA"
" 或 AOS)。Taichi 提供了 *结构节点 (SNodes)* 以满足不同层级数据结构构建时的需求。其结构和语义具体如下所示："

#: ../../snode.rst:9
msgid "dense: A fixed-length contiguous array."
msgstr "稠密集合(dense)：固定长度的连续数组。"

#: ../../snode.rst:11
msgid ""
"bitmasked: This is similar to dense, but it also uses a mask to maintain "
"sparsity information, one bit per child."
msgstr "位掩码集合(bitmasked)：类似于稠密集合，但实现了通过掩码保持数据的稀疏信息。比如为稠密集合的元素分配掩码来记录稀疏信息。"

#: ../../snode.rst:13
msgid ""
"pointer: Store pointers instead of the whole structure to save memory and"
" maintain sparsity."
msgstr "指针集合(pointer)：存储指针而不是整个结构，以节省内存和保持稀疏性。"

#: ../../snode.rst:15
msgid ""
"dynamic: Variable-length array, with a predefined maximum length. It "
"serves the role of ``std::vector`` in C++ or ``list`` in Python, and can "
"be used to maintain objects (e.g. particles) contained in a block."
msgstr ""
"动态集合(dynamic)：可变长度数组，具有预定义的最大长度。它扮演着 C++ 中的 ``std::vector`` 或者是 Python 中的"
" ``list`` 这样的角色，可以用来维护包含在一个块(block)中的对象（例如粒子）。"

#: ../../snode.rst:18
msgid ""
"See :ref:`layout` for more details. ``ti.root`` is the root node of the "
"data structure."
msgstr "你可以在 :ref:`layout` 章节中了解更多详细信息。 ``ti.root`` 是层级数据结构的根结点."

#: ../../snode.rst
msgid "Parameters"
msgstr "参数"

#: ../../snode.rst:22
msgid "(SNode) where to place"
msgstr "(结构节点) 放置(place)操作的目标"

#: ../../snode.rst:23
#, fuzzy
msgid "(ti.field) field(s) to be placed"
msgstr "(张量) 要放置的张量对象"

#: ../../snode.rst
msgid "Returns"
msgstr "返回"

#: ../../snode.rst:24
msgid "(SNode) the ``snode`` itself"
msgstr "(结构节点) ``snode`` 对象"

#: ../../snode.rst:26
#, fuzzy
msgid "The following code places two 0-D fields named ``x`` and ``y``:"
msgstr "以下示例代码放置了 ``x`` 和 ``y`` 两个零维张量:"

#: ../../snode.rst:30
msgid ""
"x = ti.field(dtype=ti.i32)\n"
"y = ti.field(dtype=ti.f32)\n"
"ti.root.place(x, y)\n"
"assert x.snode == y.snode"
msgstr ""

#: ../../snode.rst:38 ../../snode.rst:53
msgid "(ti.field)"
msgstr ""

#: ../../snode.rst:39
#, fuzzy
msgid "(tuple of integers) the shape of field"
msgstr "(整数元组) 张量的形状"

#: ../../snode.rst:41
#, fuzzy
msgid "Equivalent to ``field.snode.shape``."
msgstr "相当于 ``tensor.shape()[i]`` 。"

#: ../../snode.rst:43
msgid "For example,"
msgstr "例如，"

#: ../../snode.rst:47
msgid ""
"ti.root.dense(ti.ijk, (3, 5, 4)).place(x)\n"
"x.shape  # returns (3, 5, 4)"
msgstr ""

#: ../../snode.rst:54
msgid "(SNode) the structual node where ``field`` is placed"
msgstr ""

#: ../../snode.rst:58
msgid ""
"x = ti.field(dtype=ti.i32)\n"
"y = ti.field(dtype=ti.f32)\n"
"blk1 = ti.root.dense(ti.i, 4)\n"
"blk1.place(x, y)\n"
"assert x.snode == blk1"
msgstr ""

#: ../../snode.rst:67 ../../snode.rst:84
msgid "(SNode)"
msgstr "（结构节点）"

#: ../../snode.rst:68
#, fuzzy
msgid "(tuple) the size of node along that axis"
msgstr "（标量）张量在指定轴上的尺寸"

#: ../../snode.rst:72
msgid ""
"blk1 = ti.root\n"
"blk2 = blk1.dense(ti.i,  3)\n"
"blk3 = blk2.dense(ti.jk, (5, 2))\n"
"blk4 = blk3.dense(ti.k,  2)\n"
"blk1.shape  # ()\n"
"blk2.shape  # (3, )\n"
"blk3.shape  # (3, 5, 2)\n"
"blk4.shape  # (3, 5, 4)"
msgstr ""

#: ../../snode.rst:85
msgid ""
"(optional, scalar) the number of steps, i.e. ``n=1`` for parent, ``n=2`` "
"grandparent, etc."
msgstr ""

#: ../../snode.rst:86
msgid "(SNode) the parent node of ``snode``"
msgstr "（结构节点） ``snode`` 的父节点"

#: ../../snode.rst:90
msgid ""
"blk1 = ti.root.dense(ti.i, 8)\n"
"blk2 = blk1.dense(ti.j, 4)\n"
"blk3 = blk2.bitmasked(ti.k, 6)\n"
"blk1.parent()  # ti.root\n"
"blk2.parent()  # blk1\n"
"blk3.parent()  # blk2\n"
"blk3.parent(1) # blk2\n"
"blk3.parent(2) # blk1\n"
"blk3.parent(3) # ti.root\n"
"blk3.parent(4) # None"
msgstr ""

#: ../../snode.rst:103
msgid "Node types"
msgstr "不同类型的节点"

#: ../../snode.rst:108 ../../snode.rst:145
msgid "(SNode) parent node where the child is derived from"
msgstr "（结构节点） 父节点，返回的子节点就是从该节点派生"

#: ../../snode.rst:109
msgid "(Index or Indices) indices used for this node"
msgstr "（索引）用于子节点上的索引"

#: ../../snode.rst:110
#, fuzzy
msgid "(scalar or tuple) shape of the field"
msgstr "（标量或元组）指定向量张量(tensor of vector)的形状"

#: ../../snode.rst:111 ../../snode.rst:149
msgid "(SNode) the derived child node"
msgstr "（结构节点）派生出来的子节点"

#: ../../snode.rst:113
#, fuzzy
msgid "The following code places a 1-D field of size ``3``:"
msgstr "以下示例代码放置了尺寸为 ``3`` 的一维张量："

#: ../../snode.rst:117
msgid ""
"x = ti.field(dtype=ti.i32)\n"
"ti.root.dense(ti.i, 3).place(x)"
msgstr ""

#: ../../snode.rst:120
#, fuzzy
msgid "The following code places a 2-D field of shape ``(3, 4)``:"
msgstr "以下示例代码放置了尺寸为 ``(3,4)`` 的二维张量："

#: ../../snode.rst:124
msgid ""
"x = ti.field(dtype=ti.i32)\n"
"ti.root.dense(ti.ij, (3, 4)).place(x)"
msgstr ""

#: ../../snode.rst:129
msgid ""
"If ``shape`` is a scalar and there are multiple indices, then ``shape`` "
"will be automatically expanded to fit the number of indices. For example,"
msgstr "如果给定的 ``shape`` 是一个标量，却又对应了多个索引，那么 ``shape`` 将自动扩充直至和索引数量相等。例如,"

#: ../../snode.rst:134
msgid "snode.dense(ti.ijk, 3)"
msgstr ""

#: ../../snode.rst:136
msgid "is equivalent to"
msgstr "相当于"

#: ../../snode.rst:140
msgid "snode.dense(ti.ijk, (3, 3, 3))"
msgstr ""

#: ../../snode.rst:146
msgid "(Index) the ``dynamic`` node indices"
msgstr "（索引） 动态集合节点(dynamic node)的索引"

#: ../../snode.rst:147
msgid "(scalar) the maximum size of the dynamic node"
msgstr "（标量）描述该动态集合节点的最大尺寸"

#: ../../snode.rst:148
msgid ""
"(optional, scalar) the number of elements in each dynamic memory "
"allocation chunk"
msgstr "（可选标量）描述动态内存分配时块(chunk)中存储的元素数目"

#: ../../snode.rst:151
msgid ""
"``dynamic`` nodes acts like ``std::vector`` in C++ or ``list`` in Python."
" Taichi's dynamic memory allocation system allocates its memory on the "
"fly."
msgstr ""
"``动态集合`` 节点就像 C++ 中的 ``std::vector`` 或者是 Python 中的 ``list`` 。Taichi "
"具有的动态内存分配系统可以实现自由的分配内存。"

#: ../../snode.rst:154
#, fuzzy
msgid "The following places a 1-D dynamic field of maximum size ``16``:"
msgstr "以下示例代码放置了最大尺寸为 ``16`` 的一维动态张量："

#: ../../snode.rst:158
msgid "ti.root.dynamic(ti.i, 16).place(x)"
msgstr ""

#: ../../snode.rst:166
msgid "TODO: add descriptions here"
msgstr ""

#: ../../snode.rst:171
msgid "Working with ``dynamic`` SNodes"
msgstr "动态集合节点的使用"

#: ../../snode.rst:175 ../../snode.rst:182
msgid "(SNode, dynamic)"
msgstr "（动态集合节点）"

#: ../../snode.rst:176 ../../snode.rst:183
msgid "(scalar or tuple of scalars) the ``dynamic`` node indices"
msgstr "(标量或元组中标量)  ``动态集合`` 节点的索引"

#: ../../snode.rst:177
#, fuzzy
msgid "(int32) the current size of the dynamic node"
msgstr "（标量）当前动态集合节点的尺寸"

#: ../../snode.rst:184
msgid "(depends on SNode data type) value to store"
msgstr "（取决于结构节点的数据类型）想要储存的值"

#: ../../snode.rst:185
#, fuzzy
msgid "(int32) the size of the dynamic node, before appending"
msgstr "(``int32``) 附加操作之前动态节点的尺寸"

#: ../../snode.rst:187
msgid "Inserts ``val`` into the ``dynamic`` node with indices ``indices``."
msgstr "使用上述函数，就能实现通过 ``索引(indices)`` 将 ``常量(val)`` 插入到 ``动态集合`` 节点中。"

#: ../../snode.rst:191
#, fuzzy
msgid "Taichi fields like powers of two"
msgstr "Taichi 的张量尺寸"

#: ../../snode.rst:193
#, fuzzy
msgid ""
"Non-power-of-two field dimensions are promoted into powers of two and "
"thus these fields will occupy more virtual address space. For example, a "
"(dense) field of size ``(18, 65)`` will be materialized as ``(32, 128)``."
msgstr ""
"对于张量，非整二次幂的那些维度会被扩充为整二次幂，因而会占据更多虚拟地址空间。例如，一个 ``(18, 65)`` "
"的稠密张量在实际存储时相当于一个 ``(32, 128)`` 大小的张量。"

#: ../../snode.rst:198
msgid "Indices"
msgstr "索引"

#: ../../snode.rst:213
msgid "(TODO)"
msgstr ""

#~ msgid ""
#~ "See :ref:`layout` for more details about"
#~ " data layout. ``ti.root`` is the root"
#~ " node of the data structure."
#~ msgstr ""

#~ msgid ""
#~ "After writing the computation code, the"
#~ " user needs to specify the internal"
#~ " data structure hierarchy. Specifying a "
#~ "data structure includes choices at both"
#~ " the macro level, dictating how the"
#~ " data structure components nest with "
#~ "each other and the way they "
#~ "represent sparsity, and the micro level,"
#~ " dictating how data are grouped "
#~ "together (e.g. structure of arrays vs."
#~ " array of structures). Our language "
#~ "provides *structural nodes (SNodes)* to "
#~ "compose the hierarchy and particular "
#~ "properties. These constructs and their "
#~ "semantics are listed below:"
#~ msgstr ""

#~ msgid "the tensor"
#~ msgstr ""

#~ msgid "TODO: add tensor.parent(), and add see also ref here"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(dt=ti.i32)\n"
#~ "y = ti.var(dt=ti.f32)\n"
#~ "ti.root.place(x, y)"
#~ msgstr ""

#~ msgid ""
#~ "ti.root.dense(ti.ijk, (3, 5, 4)).place(x)\n"
#~ "x.shape() # returns (3, 5, 4)"
#~ msgstr ""

#~ msgid "axis (0 for ``i`` and 1 for ``j``)"
#~ msgstr "指定轴（0 表示 ``i`` ，1 表示 ``j`` ）"

#~ msgid ""
#~ "ti.root.dense(ti.ijk, (3, 5, 4)).place(x)\n"
#~ "x.snode().get_shape(0)  # 3\n"
#~ "x.snode().get_shape(1)  # 5\n"
#~ "x.snode().get_shape(2)  # 4"
#~ msgstr ""

#~ msgid "(scalar) the dimensionality of the tensor"
#~ msgstr "（标量）张量的维度"

#~ msgid "Equivalent to ``len(tensor.shape())``."
#~ msgstr "相当于 ``len(tensor.shape())`` 。"

#~ msgid ""
#~ "ti.root.dense(ti.ijk, (8, 9, 10)).place(x)\n"
#~ "x.dim()  # 3"
#~ msgstr ""

#~ msgid ""
#~ "blk1 = ti.root.dense(ti.i, 8)\n"
#~ "blk2 = blk1.dense(ti.j, 4)\n"
#~ "blk3 = blk2.bitmasked(ti.k, 6)\n"
#~ "blk1.parent()  # ti.root\n"
#~ "blk2.parent()  # blk1\n"
#~ "blk3.parent()  # blk2"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(dt=ti.i32)\n"
#~ "y = ti.var(dt=ti.f32)\n"
#~ "ti.root.place(x, y)\n"
#~ "assert x.snode() == y.snode()"
#~ msgstr ""

#~ msgid "(Tensor)"
#~ msgstr "（张量）"

#~ msgid ""
#~ "ti.root.dense(ti.ijk, (3, 5, 4)).place(x)\n"
#~ "x.shape # returns (3, 5, 4)"
#~ msgstr ""

#~ msgid "(SNode) the structual node where ``tensor`` is placed"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(dt=ti.i32)\n"
#~ "y = ti.var(dt=ti.f32)\n"
#~ "ti.root.place(x, y)\n"
#~ "x.snode()"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(dt=ti.i32)\n"
#~ "ti.root.dense(ti.i, 3).place(x)"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(dt=ti.i32)\n"
#~ "ti.root.dense(ti.ij, (3, 4)).place(x)"
#~ msgstr ""

