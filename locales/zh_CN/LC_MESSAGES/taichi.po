# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Yuanming Hu
# This file is distributed under the same license as the taichi package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: taichi 0.5.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-13 16:43+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../taichi/docs/acknowledgments.rst:2
msgid "Acknowledgments"
msgstr ""

#: ../../taichi/docs/acknowledgments.rst:4
msgid ""
"`Taichi` depends on other open-source projects, which are shipped with "
"taichi and users do not have to install manually: `pybind11 "
"<https://github.com/pybind/pybind11>`_, `fmt "
"<https://github.com/fmtlib/fmt>`_, `Catch2 "
"<https://github.com/catchorg/Catch2>`_, `spdlog "
"<https://github.com/gabime/spdlog>`_, `stb_image, stb_image_write, "
"stb_truetype <https://github.com/nothings/stb>`_, `tinyobjloader "
"<https://github.com/syoyo/tinyobjloader>`_, `ffmpeg "
"<https://www.ffmpeg.org/>`_, `miniz "
"<https://github.com/richgel999/miniz>`_."
msgstr ""

#: ../../taichi/docs/acknowledgments.rst:15
msgid ""
"`Halide <https://halide-lang.org/>`_ has been a great reference for us to"
" learn about the Apple Metal API and the LLVM NVPTX backend API."
msgstr ""

#: ../../taichi/docs/atomic.rst:2
msgid "Atomic operations"
msgstr ""

#: ../../taichi/docs/atomic.rst:4
msgid ""
"In Taichi, augmented assignments (e.g., ``x[i] += 1``) are automatically "
"`atomic <https://en.wikipedia.org/wiki/Fetch-and-add>`_."
msgstr ""

#: ../../taichi/docs/atomic.rst:9
msgid ""
"When modifying global variables in parallel, make sure you use atomic "
"operations. For example, to sum up all the elements in ``x``, ::"
msgstr ""

#: ../../taichi/docs/atomic.rst:12
msgid ""
"@ti.kernel\n"
"def sum():\n"
"    for i in x:\n"
"        # Approach 1: OK\n"
"        total[None] += x[i]\n"
"\n"
"        # Approach 2: OK\n"
"        ti.atomic_add(total[None], x[i])\n"
"\n"
"        # Approach 3: Wrong result since the operation is not atomic.\n"
"        total[None] = total[None] + x[i]"
msgstr ""

#: ../../taichi/docs/atomic.rst:26
msgid ""
"When atomic operations are applied to local values, the Taichi compiler "
"will try to demote these operations into their non-atomic counterparts."
msgstr ""

#: ../../taichi/docs/atomic.rst:28
msgid ""
"Apart from the augmented assignments, explicit atomic operations, such as"
" ``ti.atomic_add``, also do read-modify-write atomically. These "
"operations additionally return the **old value** of the first argument."
msgstr ""

#: ../../taichi/docs/atomic.rst:31
msgid "Below is a list of all explicit atomic operations:"
msgstr ""

#: ../../taichi/docs/atomic.rst:36
msgid "Atomically compute ``x + y`` or ``x - y`` and store the result in ``x``."
msgstr ""

#: ../../taichi/docs/atomic.rst ../../taichi/docs/gui.rst
#: ../../taichi/docs/matrix.rst ../../taichi/docs/scalar_tensor.rst
#: ../../taichi/docs/snode.rst ../../taichi/docs/vector.rst
msgid "Returns"
msgstr ""

#: ../../taichi/docs/atomic.rst:38 ../../taichi/docs/atomic.rst:55
msgid "The old value of ``x``."
msgstr ""

#: ../../taichi/docs/atomic.rst:40 ../../taichi/docs/vector.rst:113
#: ../../taichi/docs/vector.rst:130 ../../taichi/docs/vector.rst:144
msgid "For example, ::"
msgstr ""

#: ../../taichi/docs/atomic.rst:43
msgid ""
"x[i] = 3\n"
"y[i] = 4\n"
"z[i] = ti.atomic_add(x[i], y[i])\n"
"# now x[i] = 7, y[i] = 4, z[i] = 3"
msgstr ""

#: ../../taichi/docs/atomic.rst:53
msgid ""
"Atomically compute ``x & y`` (bitwise and), ``x | y`` (bitwise or), or "
"``x ^ y`` (bitwise xor), and store the result in ``x``."
msgstr ""

#: ../../taichi/docs/atomic.rst:60
msgid "Supported atomic operations on each backend:"
msgstr ""

#: ../../taichi/docs/atomic.rst:63 ../../taichi/docs/type.rst:48
msgid "type"
msgstr ""

#: ../../taichi/docs/atomic.rst:63 ../../taichi/docs/type.rst:48
msgid "CPU/CUDA"
msgstr ""

#: ../../taichi/docs/atomic.rst:63 ../../taichi/docs/hello.rst:81
#: ../../taichi/docs/type.rst:48
msgid "OpenGL"
msgstr ""

#: ../../taichi/docs/atomic.rst:63 ../../taichi/docs/hello.rst:81
#: ../../taichi/docs/type.rst:48
msgid "Metal"
msgstr ""

#: ../../taichi/docs/atomic.rst:65
msgid "``i32``"
msgstr ""

#: ../../taichi/docs/atomic.rst:65 ../../taichi/docs/atomic.rst:67
#: ../../taichi/docs/atomic.rst:69 ../../taichi/docs/atomic.rst:71
#: ../../taichi/docs/hello.rst:83 ../../taichi/docs/hello.rst:85
#: ../../taichi/docs/hello.rst:87 ../../taichi/docs/type.rst:50
#: ../../taichi/docs/type.rst:52 ../../taichi/docs/type.rst:54
#: ../../taichi/docs/type.rst:56 ../../taichi/docs/type.rst:58
#: ../../taichi/docs/type.rst:60 ../../taichi/docs/type.rst:62
#: ../../taichi/docs/type.rst:64 ../../taichi/docs/type.rst:66
#: ../../taichi/docs/type.rst:68
msgid "OK"
msgstr ""

#: ../../taichi/docs/atomic.rst:67
msgid "``f32``"
msgstr ""

#: ../../taichi/docs/atomic.rst:69
msgid "``i64``"
msgstr ""

#: ../../taichi/docs/atomic.rst:69 ../../taichi/docs/atomic.rst:71
#: ../../taichi/docs/type.rst:56
msgid "EXT"
msgstr ""

#: ../../taichi/docs/atomic.rst:69 ../../taichi/docs/atomic.rst:71
#: ../../taichi/docs/hello.rst:83 ../../taichi/docs/hello.rst:85
#: ../../taichi/docs/hello.rst:87 ../../taichi/docs/type.rst:50
#: ../../taichi/docs/type.rst:52 ../../taichi/docs/type.rst:56
#: ../../taichi/docs/type.rst:58 ../../taichi/docs/type.rst:60
#: ../../taichi/docs/type.rst:62 ../../taichi/docs/type.rst:64
#: ../../taichi/docs/type.rst:68
msgid "N/A"
msgstr ""

#: ../../taichi/docs/atomic.rst:71
msgid "``f64``"
msgstr ""

#: ../../taichi/docs/atomic.rst:74
msgid "(OK: supported; EXT: require extension; N/A: not available)"
msgstr ""

#: ../../taichi/docs/cli_utilities.rst:2
msgid "Command line utilities"
msgstr ""

#: ../../taichi/docs/cli_utilities.rst:4
msgid ""
"A successful installation of Taichi should add a CLI (Command-Line "
"Interface) to your system, which is helpful to perform several rountine "
"tasks quickly. To invoke the CLI, please run ``ti`` or ``python3 -m "
"taichi``."
msgstr ""

#: ../../taichi/docs/cli_utilities.rst:9 ../../taichi/docs/layout.rst:201
msgid "Examples"
msgstr ""

#: ../../taichi/docs/cli_utilities.rst:10
msgid ""
"Taichi provides a set of bundled examples. You could run ``ti example "
"-h`` to print the help message and get a list of available example names."
" For instance, to run the basic `fractal` example, try: ``ti example "
"fractal`` from your shell. (``ti example fractal.py`` should also work)"
msgstr ""

#: ../../taichi/docs/cli_utilities.rst:17
msgid "Changelog"
msgstr ""

#: ../../taichi/docs/cli_utilities.rst:18
msgid ""
"Sometimes it's convenient to view the changelog of the current version of"
" Taichi, to do so from your shell, you could run ``ti changelog``."
msgstr ""

#: ../../taichi/docs/compilation.rst:4
msgid "Life of a Taichi kernel"
msgstr ""

#: ../../taichi/docs/compilation.rst:6
msgid ""
"Sometimes it is helpful to understand the life cycle of a Taichi kernel. "
"In short, compilation will only happen on the first invocation of an "
"instance of a kernel."
msgstr ""

#: ../../taichi/docs/compilation.rst:9
msgid "The life cycle of a Taichi kernel has the following stages:"
msgstr ""

#: ../../taichi/docs/compilation.rst:11 ../../taichi/docs/compilation.rst:38
msgid "Kernel registration"
msgstr ""

#: ../../taichi/docs/compilation.rst:12 ../../taichi/docs/compilation.rst:45
msgid "Template instantiation and caching"
msgstr ""

#: ../../taichi/docs/compilation.rst:13
msgid "Python AST transforms"
msgstr ""

#: ../../taichi/docs/compilation.rst:14
msgid "Taichi IR compilation, optimization, and executable generation"
msgstr ""

#: ../../taichi/docs/compilation.rst:15
msgid "Launching"
msgstr ""

#: ../../taichi/docs/compilation.rst:19
msgid "Let's consider the following simple kernel:"
msgstr ""

#: ../../taichi/docs/compilation.rst:21
msgid ""
"@ti.kernel\n"
"def add(field: ti.template(), delta: ti.i32):\n"
"  for i in field:\n"
"    field[i] += delta"
msgstr ""

#: ../../taichi/docs/compilation.rst:29
msgid "We allocate two 1D fields to simplify discussion:"
msgstr ""

#: ../../taichi/docs/compilation.rst:31
msgid ""
"x = ti.field(dtype=ti.f32, shape=128)\n"
"y = ti.field(dtype=ti.f32, shape=16)"
msgstr ""

#: ../../taichi/docs/compilation.rst:39
msgid ""
"When the ``ti.kernel`` decorator is executed, a kernel named ``add`` is "
"registered. Specifically, the Python Abstract Syntax Tree (AST) of the "
"``add`` function will be memorized. No compilation will happen until the "
"first invocation of ``add``."
msgstr ""

#: ../../taichi/docs/compilation.rst:47
msgid "add(x, 42)"
msgstr ""

#: ../../taichi/docs/compilation.rst:51
msgid ""
"When ``add`` is called for the first time, the Taichi frontend compiler "
"will instantiate the kernel."
msgstr ""

#: ../../taichi/docs/compilation.rst:53
msgid ""
"When you have a second call with the same **template signature** "
"(explained later), e.g.,"
msgstr ""

#: ../../taichi/docs/compilation.rst:55
msgid "add(x, 1)"
msgstr ""

#: ../../taichi/docs/compilation.rst:59
msgid "Taichi will directly reuse the previously compiled binary."
msgstr ""

#: ../../taichi/docs/compilation.rst:61
msgid ""
"Arguments hinted with ``ti.template()`` are template arguments, and will "
"incur template instantiation. For example,"
msgstr ""

#: ../../taichi/docs/compilation.rst:63
msgid "add(y, 42)"
msgstr ""

#: ../../taichi/docs/compilation.rst:67
msgid "will lead to a new instantiation of **add**."
msgstr ""

#: ../../taichi/docs/compilation.rst:70
msgid ""
"**Template signatures** are what distinguish different instantiations of "
"a kernel template. The signature of ``add(x, 42)`` is ``(x, ti.i32)``, "
"which is the same as that of ``add(x, 1)``. Therefore, the latter can "
"reuse the previously compiled binary. The signature of ``add(y, 42)`` is "
"``(y, ti.i32)``, a different value from the previous signature, hence a "
"new kernel will be instantiated and compiled."
msgstr ""

#: ../../taichi/docs/compilation.rst:76
msgid ""
"Many basic operations in the Taichi standard library are implemented "
"using Taichi kernels using metaprogramming tricks. Invoking them will "
"incur **implicit kernel instantiations**."
msgstr ""

#: ../../taichi/docs/compilation.rst:79
msgid ""
"Examples include ``x.to_numpy()`` and ``y.from_torch(torch_tensor)``. "
"When you invoke these functions, you will see kernel instantiations, as "
"Taichi kernels will be generated to offload the hard work to multiple CPU"
" cores/GPUs."
msgstr ""

#: ../../taichi/docs/compilation.rst:82
msgid ""
"As mentioned before, the second time you call the same operation, the "
"cached compiled kernel will be reused and no further compilation is "
"needed."
msgstr ""

#: ../../taichi/docs/compilation.rst:85
msgid "Code transformation and optimizations"
msgstr ""

#: ../../taichi/docs/compilation.rst:87
msgid ""
"When a new instantiation happens, the Taichi frontend compiler (i.e., the"
" ``ASTTransformer`` Python class) will transform the kernel body AST into"
" a Python script, which, when executed, emits a Taichi frontend AST. "
"Basically, some patches are applied to the Python AST so that the Taichi "
"frontend can recognize it."
msgstr ""

#: ../../taichi/docs/compilation.rst:91
msgid ""
"The Taichi AST lowering pass translates Taichi frontend IR into "
"hierarchical static single assignment (SSA) IR, which allows a series of "
"further IR passes to happen, such as"
msgstr ""

#: ../../taichi/docs/compilation.rst:94
msgid "Loop vectorization"
msgstr ""

#: ../../taichi/docs/compilation.rst:95
msgid "Type inference and checking"
msgstr ""

#: ../../taichi/docs/compilation.rst:96
msgid ""
"General simplifications such as common subexpression elimination (CSE), "
"dead instruction elimination (DIE), constant folding, and store "
"forwarding"
msgstr ""

#: ../../taichi/docs/compilation.rst:97
msgid "Access lowering"
msgstr ""

#: ../../taichi/docs/compilation.rst:98
msgid "Data access optimizations"
msgstr ""

#: ../../taichi/docs/compilation.rst:99
msgid ""
"Reverse-mode automatic differentiation (if using differentiable "
"programming)"
msgstr ""

#: ../../taichi/docs/compilation.rst:100
msgid "Parallelization and offloading"
msgstr ""

#: ../../taichi/docs/compilation.rst:101
msgid "Atomic operation demotion"
msgstr ""

#: ../../taichi/docs/compilation.rst:104
msgid "The just-in-time (JIT) compilation engine"
msgstr ""

#: ../../taichi/docs/compilation.rst:106
msgid ""
"Finally, the optimized SSA IR is fed into backend compilers such as LLVM "
"or Apple Metal/OpenGL shader compilers. The backend compilers then "
"generate high-performance executable CPU/GPU programs."
msgstr ""

#: ../../taichi/docs/compilation.rst:110
msgid "Kernel launching"
msgstr ""

#: ../../taichi/docs/compilation.rst:112
msgid ""
"Taichi kernels will be ultimately launched as multi-threaded CPU tasks or"
" GPU kernels."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:2
msgid "Contribution guidelines"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:4
msgid ""
"First of all, thank you for contributing! We welcome contributions of all"
" forms, including but not limited to"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:7
msgid "Bug fixes"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:8
msgid "Proposing and implementing new features"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:9
msgid ""
"Documentation improvement and translations (e.g. `Simplified Chinese "
"<https://github.com/taichi-dev/taichi-docs-zh-cn>`_)"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:10
msgid "Improved error messages that are more user-friendly"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:11
msgid "New test cases"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:12
msgid "New examples"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:13
msgid "Compiler performance patches"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:14
msgid "Blog posts and tutorials on Taichi"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:15
msgid "Participation in the `Taichi forum <https://forum.taichi.graphics/>`_"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:16
msgid ""
"Introduce Taichi to your friends or simply star `the project "
"<https://github.com/taichi-dev/taichi>`_."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:17
msgid ""
"Typo fixes in the documentation, code or comments (please directly make a"
" pull request for minor issues like these)"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:20
msgid "How to contribute bug fixes and new features"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:22
#, python-format
msgid ""
"Issues marked with `\"good first issue\" <https://github.com/taichi-"
"dev/taichi/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22>`_"
" are great chances for starters."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:24
msgid ""
"Please first leave a note (e.g. *I know how to fix this and would like to"
" help!*) on the issue, so that people know someone is already working on "
"it. This helps prevent redundant work;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:26
msgid ""
"If no core developer has commented and described a potential solution on "
"the issue, please briefly describe your plan, and wait for a core "
"developer to reply before you start. This helps keep implementations "
"simple and effective."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:29
msgid ""
"Issues marked with `\"welcome contribution\" <https://github.com/taichi-"
"dev/taichi/issues?q=is%3Aopen+is%3Aissue+label%3A%22welcome+contribution%22>`_"
" are slightly more challenging but still friendly to beginners."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:32
msgid "High-level guidelines"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:34
msgid "Be pragmatic: practically solving problems is our ultimate goal."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:35
msgid ""
"No overkills: always use *easy* solutions to solve easy problems, so that"
" you have time and energy for real hard ones."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:36
msgid ""
"Almost every design decision has pros and cons. A decision is `good` if "
"its pros outweigh its cons. Always think about both sides."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:37
msgid ""
"Debugging is hard. Changesets should be small so that sources of bugs can"
" be easily pinpointed."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:38
msgid "Unit/integration tests are our friends."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:41
msgid ""
"“There are two ways of constructing a software design: One way is to make"
" it so simple that there are obviously no deficiencies, and the other way"
" is to make it so complicated that there are no obvious deficiencies. "
"`The first method is far more difficult`.”     --- `C.A.R. Hoare "
"<https://en.wikipedia.org/wiki/Tony_Hoare>`_"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:43
msgid ""
"One thing to keep in mind is that, Taichi was originally born as an "
"academic research project. This usually means that some parts did not "
"have the luxury to go through a solid design. While we are always trying "
"to improve the code quality, it doesn't mean that the project is free "
"from technical debts. Some places may be confusing or overly complicated."
" Whenever you spot one, you are more than welcome to shoot us a PR! :-)"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:46
msgid "Effective communication"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:48
msgid ""
"How much information we effectively convey, is way more important than "
"how many words we typed."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:49
msgid "Be constructive. Be polite. Be organized. Be concise."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:50
msgid "Bulleted lists are our friends."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:51
msgid ""
"Proofread before you post: if you are the reader, can you understand what"
" you typed?"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:52
msgid ""
"If you are not a native speaker, consider using a spell checker such as "
"`Grammarly <https://app.grammarly.com/>`_."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:54
msgid ""
"Please base your discussion and feedback on facts, and not personal "
"feelings. It is very important for all of us to maintain a friendly and "
"blame-free community. Some examples:"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:57
msgid "(Acceptable) This design could be confusing to new Taichi users."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:60
msgid "(Not Acceptable) This design is terrible."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:64
msgid "Making good pull requests"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:66
msgid ""
"PRs with **small** changesets are preferred. A PR should ideally address "
"**only one issue**."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:68
msgid ""
"It is fine to include off-topic **trivial** refactoring such as typo "
"fixes;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:69
msgid ""
"The reviewers reserve the right to ask PR authors to remove off-topic "
"**non-trivial** changes."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:71
msgid ""
"All commits in a PR will always be **squashed and merged into master as a"
" single commit**."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:72
msgid "PR authors **should not squash commits on their own**;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:73
msgid ""
"When implementing a complex feature, consider breaking it down into small"
" PRs, to keep a more detailed development history and to interact with "
"core developers more frequently."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:74
msgid "If you want early feedback from core developers"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:76
msgid ""
"Open a PR in `Draft <https://github.blog/2019-02-14-introducing-draft-"
"pull-requests/>`_ state on GitHub so that you can share your progress;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:77
msgid ""
"Make sure you @ the corresponding developer in the comments or request "
"the review."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:79
msgid "If you are making multiple PRs"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:81
msgid ""
"Independent PRs should be based on **different** branches forking from "
"``master``;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:82
msgid ""
"PRs with dependencies should be raised only after all prerequisite PRs "
"are merged into ``master``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:84
msgid "All PRs should ideally come with corresponding **tests**;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:85
msgid ""
"All PRs should come with **documentation update**, except for internal "
"compiler implementations;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:86
msgid "All PRs must pass **continuous integration tests** before they get merged;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:87
msgid "PR titles should follow :ref:`prtag`;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:88
msgid ""
"A great article from Google on `how to have your PR merged quickly "
"<https://testing.googleblog.com/2017/06/code-health-too-many-comments-on-"
"your.html>`_. `[PDF] <https://github.com/yuanming-"
"hu/public_files/blob/master/graphics/taichi/google_review_comments.pdf>`_"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:92
msgid "Reviewing & PR merging"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:94
msgid "Please try to follow these tips from Google"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:96
msgid ""
"`Code Health: Understanding Code In Review "
"<https://testing.googleblog.com/2018/05/code-health-understanding-code-"
"in-review.html>`_; `[PDF] <https://github.com/yuanming-"
"hu/public_files/blob/master/graphics/taichi/google_understanding_code.pdf>`_"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:97
msgid ""
"`Code Health: Respectful Reviews == Useful Reviews "
"<https://testing.googleblog.com/2019/11/code-health-respectful-reviews-"
"useful.html>`_. `[PDF] <https://github.com/yuanming-"
"hu/public_files/blob/master/graphics/taichi/google_respectful_reviews.pdf>`_"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:99
msgid "The merger should always **squash and merge** PRs into the master branch;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:100
msgid "The master branch is required to have a **linear history**;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:101
msgid ""
"Make sure the PR passes **continuous integration tests**, except for "
"cases like documentation updates;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:102
msgid "Make sure the title follows :ref:`prtag`."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:106
msgid "Using continuous integration"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:108
msgid ""
"Continuous Integration (CI), will **build** and **test** your commits in "
"a PR against in environments."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:109
msgid ""
"Currently, Taichi uses `Travis CI <https://travis-ci.org>`_ (for OS X and"
" Linux) and `AppVeyor <https://www.appveyor.com>`_ (for Windows)."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:110
msgid "CI will be triggered every time you push commits to an open PR."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:111
msgid ""
"You can prepend ``[skip ci]`` to your commit message to avoid triggering "
"CI. e.g. ``[skip ci] This commit will not trigger CI``"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:112
msgid ""
"A tick on the right of commit hash means CI passed, a cross means CI "
"failed."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:116
msgid "Enforcing code style"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:117
msgid ""
"Locally, you can run ``ti format`` in the command line to re-format code "
"style. Note that you have to install ``clang-format-6.0`` and ``yapf "
"v0.29.0`` locally before you use ``ti format``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:120
msgid ""
"If you don't have to install these formatting tools locally, use the "
"**format server**. It's an online version of ``ti format``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:122
msgid "Go to http://kun.csail.mit.edu:31415/, and click at the desired PR id."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:123
msgid ""
"Come back to the PR page, you'll see a user called @taichi-gardener (bot)"
" pushed a commit named ``[skip ci] enforce code format``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:124
msgid ""
"You won't see the bot's commit if it didn't find anything not matching "
"the format."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:125
msgid ""
"Then please run ``git pull`` in your local branch to pull the formatted "
"code."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:126
msgid ""
"Note that commit messages marked with ``[format]`` will automatically "
"trigger the format server. e.g. ``[format] your commit message``"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:132
msgid "PR title format and tags"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:133
msgid ""
"PR titles will be part of the commit history reflected in the ``master`` "
"branch, therefore it is important to keep PR titles readable."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:135
msgid ""
"Please always prepend **at least one tag** such as ``[Lang]`` to PR "
"titles:"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:137
msgid ""
"When using multiple tags, make sure there is exactly one space between "
"tags;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:138
msgid ""
"E.g., \"[Lang][refactor]\" (no space) should be replaced by \"[Lang] "
"[refactor]\";"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:140
msgid "The first letter of the PR title body should be capitalized:"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:142
msgid ""
"E.g., ``[Doc] improve documentation`` should be replaced by ``[Doc] "
"Improve documentation``;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:143
msgid ""
"``[Lang] \"ti.sqr(x)\" is now deprecated`` is fine because ``\"`` is a "
"symbol."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:145
msgid "Please do not include back quotes (\"`\") in PR titles."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:147
msgid ""
"For example, \"[Metal] Support bitmasked SNode\", \"[OpenGL] "
"AtomicMin/Max support\", or \"[Opt] [IR] Enhanced constant folding\"."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:149
msgid "Frequently used tags:"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:151
msgid "``[Metal], [OpenGL], [CPU], [CUDA]``: backends;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:152
msgid "``[LLVM]``: the LLVM backend shared by CPUs and CUDA;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:153
msgid "``[Lang]``: frontend language features, including syntax sugars;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:154
msgid "``[Std]``: standard library, e.g. ``ti.Matrix`` and ``ti.Vector``;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:155
msgid "``[Sparse]``: sparse computation;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:156
msgid "``[IR]``: intermediate representation;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:157
msgid "``[Opt]``: IR optimization passes;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:158
msgid "``[GUI]``: the built-in GUI system;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:159
msgid "``[Refactor]``: code refactoring;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:160
msgid "``[CLI]``: commandline interfaces, e.g. the ``ti`` command;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:161
msgid "``[Doc]``: documentation under ``docs/``;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:162
msgid "``[Example]``: examples under ``examples/``;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:163
msgid "``[Test]``: adding or improving tests under ``tests/``;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:164
msgid "``[Linux]``: Linux platform;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:165
msgid "``[Mac]``: Mac OS X platform;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:166
msgid "``[Windows]``: Windows platform;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:167
msgid "``[Perf]``: performance improvements;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:168
msgid ""
"``[Misc]``: something that doesn't belong to any category, such as "
"version bump, reformatting;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:169
msgid "``[Bug]``: bug fixes;"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:170
msgid ""
"Check out more tags in `misc/prtags.json <https://github.com/taichi-"
"dev/taichi/blob/master/misc/prtags.json>`_."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:171
msgid ""
"When introducing a new tag, please update the list in "
"``misc/prtags.json`` in the first PR with that tag, so that people can "
"follow."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:175
msgid ""
"We do appreciate all kinds of contributions, yet we should not expose the"
" title of every PR to end-users. Therefore the changelog will distinguish"
" `what the user should know` from `what the developers are doing`. This "
"is done by **capitalizing PR tags**:"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:179
msgid ""
"PRs with visible/notable features to the users should be marked with tags"
" starting with **the first letter capitalized**, e.g. ``[Metal], "
"[OpenGL], [IR], [Lang], [CLI]``. When releasing a new version, a script "
"(``python/taichi/make_changelog.py``) will generate a changelog with "
"these changes (PR title) highlighted. Therefore it is **important** to "
"make sure the end-users can understand what your PR does, **based on your"
" PR title**."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:181
msgid ""
"Other PRs (underlying development/intermediate implementation) should use"
" tags with **everything in lowercase letters**: e.g. ``[metal], [opengl],"
" [ir], [lang], [cli]``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:182
msgid ""
"Because of the way the release changelog is generated, there should be "
"**at most one captialized tag** in a PR title to prevent duplicate PR "
"highlights. For example, ``[GUI] [Mac] Support modifier keys`` (#1189) is"
" a bad example, we should use ``[gui] [Mac] Support modifier keys in "
"GUI`` instead. Please capitalize the tag that is most relevant to the PR."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:186
msgid "C++ and Python standards"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:188
msgid ""
"The C++ part of Taichi is written in C++17, and the Python part in 3.6+. "
"You can assume that C++17 and Python 3.6 features are always available."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:193
msgid "Tips on the Taichi compiler development"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:195
msgid ""
":ref:`compilation` may worth checking out. It explains the whole "
"compilation process."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:197
msgid "See also :ref:`regress` if your work involves IR optimization."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:199
msgid ""
"When creating a Taichi program using ``ti.init(arch=desired_arch, "
"**kwargs)``, pass in the following parameters to make the Taichi compiler"
" print out IR:"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:201
msgid ""
"``print_preprocessed = True``: print results of the frontend Python AST "
"transform. The resulting scripts will generate a Taichi Frontend AST when"
" executed."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:202
msgid ""
"``print_ir = True``: print the Taichi IR transformation process of kernel"
" (excluding accessors) compilation."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:203
msgid ""
"``print_accessor_ir = True``: print the IR transformation process of data"
" accessors, which are special and simple kernels. (This is rarely used, "
"unless you are debugging the compilation of data accessors.)"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:204
msgid ""
"``print_struct_llvm_ir = True``: save the emitted LLVM IR by Taichi "
"struct compilers."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:205
msgid ""
"``print_kernel_llvm_ir = True``: save the emitted LLVM IR by Taichi "
"kernel compilers."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:206
msgid ""
"``print_kernel_llvm_ir_optimized = True``: save the optimized LLVM IR of "
"each kernel."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:207
msgid ""
"``print_kernel_nvptx = True``: save the emitted NVPTX of each kernel "
"(CUDA only)."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:211
msgid ""
"Data accessors in Python-scope are implemented as special Taichi kernels."
" For example, ``x[1, 2, 3] = 3`` will call the writing accessor kernel of"
" ``x``, and ``print(y[42])`` will call the reading accessor kernel of "
"``y``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:217
msgid "Folder structure"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:219
msgid "Key folders are"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:221
msgid "``taichi``: The core compiler implementation"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:223
msgid "``program``: Top-level constructs"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:224
msgid "``ir``: Intermediate representation"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:225
msgid "``analysis``: Static analysis passes"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:226
msgid "``transforms``: IR transform passes"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:227
msgid "``inc``: Small definition files to be included repeatedly"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:229
msgid "``jit``: Just-In-Time compilation base classes"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:230
msgid "``llvm``: LLVM utilities"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:231
msgid "``runtime``: LLVM runtime environments"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:233
msgid "``struct``: Struct compiler base classes"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:234
msgid "``codegen``: Code generation base classes"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:235
msgid "``backends``: Device-dependent code generators/runtime environments"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:237
msgid "``cpu``: CPU backend implementation"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:238
msgid "``cuda``: CUDA backend implementation"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:239
msgid "``opengl``: OpenGL backend implementation"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:240
msgid "``metal``: Metal backend implementation"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:241
msgid "``cc``: C backend implementation (WIP)"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:243
msgid "``gui``: GUI system"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:244
msgid "``math``: Math utilities"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:245
msgid "``python``: C++/Python interfaces"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:247
msgid "``platform``: Platform supports"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:248
msgid "``system``: OS-related infrastructure"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:249
msgid "``util``:  Miscellaneous utilities"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:252
msgid "``python/taichi``: Python frontend implementation"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:254
msgid "``core``: Loading & interacting with Taichi core"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:255
msgid "``lang``: Python-embbed Taichi language & syntax (major)"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:256
msgid "``misc``: Miscellaneous utilities"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:257
msgid "``tools``: Handy end-user tools"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:259
msgid "``tests``: Functional tests"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:261
msgid "``python``: Python tests (major)"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:262
msgid "``cpp``: C++ tests"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:264
msgid "``examples``: Examples"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:265
msgid "``docs``: Documentation"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:266
msgid "``benchmarks``: Performance benchmarks"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:267
msgid "``external``: External libraries"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:268
msgid "``misc``: Random (yet useful) files"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:269
#: ../../taichi/docs/taichicon.rst:73
msgid "..."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:275
msgid "Testing"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:277
msgid "Tests should be added to ``tests/``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:280
msgid "Command line tools"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:282
msgid "Use ``ti test`` to run all the tests."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:283
msgid "Use ``ti test -v`` for verbose outputs."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:284
msgid ""
"Use ``ti test -C`` to run tests and record code coverage, see "
":ref:`coverage` for more infomations."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:286
msgid ""
"Use ``ti test -a <arch(s)>`` for testing against specified backend(s). "
"e.g. ``ti test -a cuda,metal``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:289
msgid ""
"Use ``ti test -na <arch(s)>`` for testing all architectures excluding "
"some of them. e.g. ``ti test -na opengl,x64``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:292
msgid ""
"Use ``ti test <filename(s)>`` to run specific tests in filenames. e.g. "
"``ti test numpy_io`` will run all tests in "
"``tests/python/test_numpy_io.py``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:295
msgid ""
"Use ``ti test -c`` to run only the C++ tests. e.g. ``ti test -c "
"alg_simp`` will run ``tests/cpp/test_alg_simp.cpp``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:298
msgid ""
"Use ``ti test -k <key>`` to run tests that match the specified key. e.g. "
"``ti test linalg -k \"cross or diag\"`` will run the ``test_cross`` and "
"``test_diag`` in ``tests/python/test_linalg.py``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:301
msgid "For more options, see ``ti test -h``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:303
msgid "For more details on how to write a test case, see :ref:`write_test`."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:306
msgid "Documentation"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:308
msgid "Documentations are put under the folder ``docs/``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:310
msgid ""
"We use `reStructured text <https://www.sphinx-"
"doc.org/en/master/usage/restructuredtext/basics.html>`_ (.rst) to write "
"documentation."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:311
msgid ""
"We host our documentation online using `readthedocs.io "
"<https://taichi.readthedocs.io/en/stable>`_."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:312
msgid "Use ``ti doc`` to build the documentation locally."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:313
msgid "Open the documentation at ``docs/build/index.html``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:317
msgid ""
"On Linux/OS X, use ``watch -n 1 ti doc`` to continuously build the "
"documentation."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:319
msgid ""
"If the OpenGL backend detector keeps creating new windows, execute "
"``export TI_WITH_OPENGL=0`` for ``ti doc``."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:323
msgid "Efficient code navigation across Python/C++"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:324
msgid ""
"If you work on the language frontend (Python/C++ interface), to navigate "
"around the code base, `ffi-navigator <https://github.com/tqchen/ffi-"
"navigator>`_ allows you to jump from Python bindings to their definitions"
" in C++. Follow their README to set up your editor."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:330
msgid "Upgrading CUDA"
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:332
msgid ""
"Right now we are targeting CUDA 10. When upgrading CUDA version, the file"
" ``external/cuda_libdevice/slim_libdevice.10.bc`` should also be replaced"
" with a newer version."
msgstr ""

#: ../../taichi/docs/contributor_guide.rst:335
msgid ""
"To generate the slimmed version of libdevice based on a full "
"``libdevice.X.bc`` file from a CUDA installation, use ``ti task "
"make_slim_libdevice [libdevice.X.bc file]``"
msgstr ""

#: ../../taichi/docs/cpp_style.rst:2
msgid "C++ style"
msgstr ""

#: ../../taichi/docs/cpp_style.rst:4
msgid ""
"We generally follow `Google C++ Style Guide "
"<https://google.github.io/styleguide/cppguide.html>`_."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:7
msgid "Naming"
msgstr ""

#: ../../taichi/docs/cpp_style.rst:8
msgid ""
"Variable names should consist of lowercase words connected by "
"underscores, e.g. ``llvm_context``."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:9
msgid ""
"Class and struct names should consist of words with first letters "
"capitalized, e.g. ``CodegenLLVM``."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:10
msgid ""
"Macros should be capital start with ``TI``, such as ``TI_INFO``, "
"``TI_IMPLEMENTATION``."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:12
msgid ""
"We do not encourage the use of macro, although there are cases where "
"macros are inevitable."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:14
msgid ""
"Filenames should consist of lowercase words connected by underscores, "
"e.g. ``ir_printer.cpp``."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:17
msgid "Dos"
msgstr ""

#: ../../taichi/docs/cpp_style.rst:18
msgid "Use ``auto`` for local variables when appropriate."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:19
msgid "Mark ``override`` and ``const`` when necessary."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:22
msgid "Don'ts"
msgstr ""

#: ../../taichi/docs/cpp_style.rst:23
msgid "C language legacies:"
msgstr ""

#: ../../taichi/docs/cpp_style.rst:25
msgid "``printf`` (Use ``fmtlib::print`` instead)."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:26
msgid ""
"``new`` and ``free``. (Use smart pointers ``std::unique_ptr, "
"std::shared_ptr`` instead for ownership management)."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:27
msgid "``#include <math.h>`` (Use ``#include <cmath>`` instead)."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:29
msgid ""
"Exceptions (We are on our way to **remove** all C++ exception usages in "
"Taichi)."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:30
msgid "Prefix member functions with ``m_`` or ``_``."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:31
msgid "Virtual function call in constructors/destructors."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:32
msgid "``NULL`` (Use ``nullptr`` instead)."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:33
msgid "``using namespace std;`` in the global scope."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:34
msgid "``typedef`` (Use ``using`` instead)."
msgstr ""

#: ../../taichi/docs/cpp_style.rst:37
msgid "Automatic code formatting"
msgstr ""

#: ../../taichi/docs/cpp_style.rst:38
msgid "Please run ``ti format``"
msgstr ""

#: ../../taichi/docs/debugging.rst:2
msgid "Debugging"
msgstr ""

#: ../../taichi/docs/debugging.rst:4
msgid ""
"Debugging a parallel program is not easy, so Taichi provides builtin "
"utilities that could hopefully help you debug your Taichi program."
msgstr ""

#: ../../taichi/docs/debugging.rst:8
msgid "Run-time ``print`` in kernels"
msgstr ""

#: ../../taichi/docs/debugging.rst:12
msgid "Debug your program with ``print()`` in Taichi-scope. For example:"
msgstr ""

#: ../../taichi/docs/debugging.rst:14
msgid ""
"@ti.kernel\n"
"def inside_taichi_scope():\n"
"    x = 233\n"
"    print('hello', x)\n"
"    #=> hello 233\n"
"\n"
"    print('hello', x * 2 + 200)\n"
"    #=> hello 666\n"
"\n"
"    print('hello', x, sep='')\n"
"    #=> hello233\n"
"\n"
"    print('hello', x, sep='', end='')\n"
"    print('world', x, sep='')\n"
"    #=> hello233world233\n"
"\n"
"    m = ti.Matrix([[2, 3, 4], [5, 6, 7]])\n"
"    print('m =', m)\n"
"    #=> m = [[2, 3, 4], [5, 6, 7]]\n"
"\n"
"    v = ti.Vector([3, 4])\n"
"    print('v =', v)\n"
"    #=> v = [3, 4]"
msgstr ""

#: ../../taichi/docs/debugging.rst:40
msgid ""
"For now, Taichi-scope ``print`` supports string, scalar, vector, and "
"matrix expressions as arguments. ``print`` in Taichi-scope may be a "
"little different from ``print`` in Python-scope. Please see details "
"below."
msgstr ""

#: ../../taichi/docs/debugging.rst:45
msgid ""
"For the **CPU and CUDA backend**, ``print`` will not work in Graphical "
"Python Shells including IDLE and Jupyter notebook. This is because these "
"backends print the outputs to the console instead of the GUI. Use the "
"**OpenGL or Metal backend** if you wish to use ``print`` in IDLE / "
"Jupyter."
msgstr ""

#: ../../taichi/docs/debugging.rst:49
msgid ""
"For the **CUDA backend**, the printed result will not show up until "
"``ti.sync()`` is called:"
msgstr ""

#: ../../taichi/docs/debugging.rst:51
msgid ""
"import taichi as ti\n"
"ti.init(arch=ti.cuda)\n"
"\n"
"@ti.kernel\n"
"def kern():\n"
"    print('inside kernel')\n"
"\n"
"print('before kernel')\n"
"kern()\n"
"print('after kernel')\n"
"ti.sync()\n"
"print('after sync')"
msgstr ""

#: ../../taichi/docs/debugging.rst:66
msgid "obtains:"
msgstr ""

#: ../../taichi/docs/debugging.rst:68
msgid ""
"before kernel\n"
"after kernel\n"
"inside kernel\n"
"after sync"
msgstr ""

#: ../../taichi/docs/debugging.rst:75
msgid ""
"Note that host access or program end will also implicitly invoke "
"``ti.sync()``."
msgstr ""

#: ../../taichi/docs/debugging.rst:79
msgid ""
"Note that ``print`` in Taichi-scope can only receive **comma-separated "
"parameter**. Neither f-string nor formatted string should be used. For "
"example:"
msgstr ""

#: ../../taichi/docs/debugging.rst:81
#, python-format
msgid ""
"import taichi as ti\n"
"ti.init(arch=ti.cpu)\n"
"a = ti.field(ti.f32, 4)\n"
"\n"
"\n"
"@ti.kernel\n"
"def foo():\n"
"    a[0] = 1.0\n"
"    print('a[0] = ', a[0]) # right\n"
"    print(f'a[0] = {a[0]}') # wrong, f-string is not supported\n"
"    print(\"a[0] = %f\" % a[0]) # wrong, formatted string is not "
"supported\n"
"\n"
"foo()"
msgstr ""

#: ../../taichi/docs/debugging.rst:99
msgid "Compile-time ``ti.static_print``"
msgstr ""

#: ../../taichi/docs/debugging.rst:101
msgid ""
"Sometimes it is useful to print Python-scope objects and constants like "
"data types or SNodes in Taichi-scope. So, similar to ``ti.static`` we "
"provide ``ti.static_print`` to print compile-time constants. It is "
"similar to Python-scope ``print``."
msgstr ""

#: ../../taichi/docs/debugging.rst:105
msgid ""
"x = ti.field(ti.f32, (2, 3))\n"
"y = 1\n"
"\n"
"@ti.kernel\n"
"def inside_taichi_scope():\n"
"    ti.static_print(y)\n"
"    # => 1\n"
"    ti.static_print(x.shape)\n"
"    # => (2, 3)\n"
"    ti.static_print(x.dtype)\n"
"    # => DataType.float32\n"
"    for i in range(4):\n"
"            ti.static_print(i.dtype)\n"
"            # => DataType.int32\n"
"            # will only print once"
msgstr ""

#: ../../taichi/docs/debugging.rst:123
msgid ""
"Unlike ``print``, ``ti.static_print`` will only print the expression once"
" at compile-time, and therefore it has no runtime cost."
msgstr ""

#: ../../taichi/docs/debugging.rst:128
msgid "Runtime ``assert`` in kernel"
msgstr ""

#: ../../taichi/docs/debugging.rst:130
msgid ""
"Programmers may use ``assert`` statements in Taichi-scope. When the "
"assertion condition failed, a ``RuntimeError`` will be raised to indicate"
" the error."
msgstr ""

#: ../../taichi/docs/debugging.rst:133
msgid ""
"To make ``assert`` work, first make sure you are using the **CPU "
"backend**. For performance reason, ``assert`` only works when ``debug`` "
"mode is on, For example:"
msgstr ""

#: ../../taichi/docs/debugging.rst:136
msgid ""
"ti.init(arch=ti.cpu, debug=True)\n"
"\n"
"x = ti.field(ti.f32, 128)\n"
"\n"
"@ti.kernel\n"
"def do_sqrt_all():\n"
"    for i in x:\n"
"        assert x[i] >= 0\n"
"        x[i] = ti.sqrt(x)"
msgstr ""

#: ../../taichi/docs/debugging.rst:149
msgid ""
"When you are done with debugging, simply set ``debug=False``. Now "
"``assert`` will be ignored and there will be no runtime overhead."
msgstr ""

#: ../../taichi/docs/debugging.rst:154
msgid "Compile-time ``ti.static_assert``"
msgstr ""

#: ../../taichi/docs/debugging.rst:158
msgid ""
"Like ``ti.static_print``, we also provide a static version of ``assert``:"
" ``ti.static_assert``. It can be useful to make assertions on data types,"
" dimensionality, and shapes. It works whether ``debug=True`` is specified"
" or not. When an assertion fails, it will raise an ``AssertionError``, "
"just like a Python-scope ``assert``."
msgstr ""

#: ../../taichi/docs/debugging.rst:163 ../../taichi/docs/gui.rst:302
#: ../../taichi/docs/gui.rst:365
msgid "For example:"
msgstr ""

#: ../../taichi/docs/debugging.rst:165
msgid ""
"@ti.func\n"
"def copy(dst: ti.template(), src: ti.template()):\n"
"    ti.static_assert(dst.shape == src.shape, \"copy() needs src and dst "
"fields to be same shape\")\n"
"    for I in ti.grouped(src):\n"
"        dst[I] = src[I]\n"
"    return x % 2 == 1"
msgstr ""

#: ../../taichi/docs/debugging.rst:176
msgid "Pretty Taichi-scope traceback"
msgstr ""

#: ../../taichi/docs/debugging.rst:178
msgid ""
"As we all know, Python provides a useful stack traceback system, which "
"could help you locate the issue easily. But sometimes stack tracebacks "
"from **Taichi-scope** could be extremely complicated and hard to read. "
"For example:"
msgstr ""

#: ../../taichi/docs/debugging.rst:182
msgid ""
"import taichi as ti\n"
"ti.init()\n"
"\n"
"@ti.func\n"
"def func3():\n"
"    ti.static_assert(1 + 1 == 3)\n"
"\n"
"@ti.func\n"
"def func2():\n"
"    func3()\n"
"\n"
"@ti.func\n"
"def func1():\n"
"    func2()\n"
"\n"
"@ti.kernel\n"
"def func0():\n"
"    func1()\n"
"\n"
"func0()"
msgstr ""

#: ../../taichi/docs/debugging.rst:205
msgid "Running this code, of course, will result in an ``AssertionError``:"
msgstr ""

#: ../../taichi/docs/debugging.rst:207
msgid ""
"Traceback (most recent call last):\n"
"  File \"misc/demo_excepthook.py\", line 20, in <module>\n"
"    func0()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 559, in "
"wrapped\n"
"    return primal(*args, **kwargs)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 488, in "
"__call__\n"
"    self.materialize(key=key, args=args, arg_features=arg_features)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 367, in "
"materialize\n"
"    taichi_kernel = taichi_kernel.define(taichi_ast_generator)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 364, in "
"taichi_ast_generator\n"
"    compiled()\n"
"  File \"misc/demo_excepthook.py\", line 18, in func0\n"
"    func1()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 39, in "
"decorated\n"
"    return fun.__call__(*args)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 79, in "
"__call__\n"
"    ret = self.compiled(*args)\n"
"  File \"misc/demo_excepthook.py\", line 14, in func1\n"
"    func2()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 39, in "
"decorated\n"
"    return fun.__call__(*args)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 79, in "
"__call__\n"
"    ret = self.compiled(*args)\n"
"  File \"misc/demo_excepthook.py\", line 10, in func2\n"
"    func3()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 39, in "
"decorated\n"
"    return fun.__call__(*args)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 79, in "
"__call__\n"
"    ret = self.compiled(*args)\n"
"  File \"misc/demo_excepthook.py\", line 6, in func3\n"
"    ti.static_assert(1 + 1 == 3)\n"
"  File \"/root/taichi/python/taichi/lang/error.py\", line 14, in wrapped\n"
"    return foo(*args, **kwargs)\n"
"  File \"/root/taichi/python/taichi/lang/impl.py\", line 252, in "
"static_assert\n"
"    assert cond\n"
"AssertionError"
msgstr ""

#: ../../taichi/docs/debugging.rst:246
msgid ""
"You may already feel brain fried by the annoying ``decorated``'s and "
"``__call__``'s. These are the Taichi internal stack frames. They have "
"almost no benefit for end-users but make the traceback hard to read."
msgstr ""

#: ../../taichi/docs/debugging.rst:250
msgid ""
"For this purpose, we may want to use ``ti.init(excepthook=True)``, which "
"*hooks* on the exception handler, and make the stack traceback from "
"Taichi-scope easier to read and intuitive. e.g.:"
msgstr ""

#: ../../taichi/docs/debugging.rst:255
msgid ""
"import taichi as ti\n"
"ti.init(excepthook=True)  # just add this option!\n"
"\n"
"..."
msgstr ""

#: ../../taichi/docs/debugging.rst:263
msgid "And the result will be:"
msgstr ""

#: ../../taichi/docs/debugging.rst:265
msgid ""
"========== Taichi Stack Traceback ==========\n"
"In <module>() at misc/demo_excepthook.py:21:\n"
"--------------------------------------------\n"
"@ti.kernel\n"
"def func0():\n"
"    func1()\n"
"\n"
"func0()  <--\n"
"--------------------------------------------\n"
"In func0() at misc/demo_excepthook.py:19:\n"
"--------------------------------------------\n"
"    func2()\n"
"\n"
"@ti.kernel\n"
"def func0():\n"
"    func1()  <--\n"
"\n"
"func0()\n"
"--------------------------------------------\n"
"In func1() at misc/demo_excepthook.py:15:\n"
"--------------------------------------------\n"
"    func3()\n"
"\n"
"@ti.func\n"
"def func1():\n"
"    func2()  <--\n"
"\n"
"@ti.kernel\n"
"--------------------------------------------\n"
"In func2() at misc/demo_excepthook.py:11:\n"
"--------------------------------------------\n"
"    ti.static_assert(1 + 1 == 3)\n"
"\n"
"@ti.func\n"
"def func2():\n"
"    func3()  <--\n"
"\n"
"@ti.func\n"
"--------------------------------------------\n"
"In func3() at misc/demo_excepthook.py:7:\n"
"--------------------------------------------\n"
"ti.enable_excepthook()\n"
"\n"
"@ti.func\n"
"def func3():\n"
"    ti.static_assert(1 + 1 == 3)  <--\n"
"\n"
"@ti.func\n"
"--------------------------------------------\n"
"AssertionError"
msgstr ""

#: ../../taichi/docs/debugging.rst:318
msgid ""
"See? Our exception hook has removed some useless Taichi internal frames "
"from traceback. What's more, although not visible in the doc, the output "
"is **colorful**!"
msgstr ""

#: ../../taichi/docs/debugging.rst:325
msgid ""
"For IPython / Jupyter notebook users, the IPython stack traceback hook "
"will be overriden by the Taichi one when ``ti.enable_excepthook()``."
msgstr ""

#: ../../taichi/docs/debugging.rst:330
msgid "Debugging Tips"
msgstr ""

#: ../../taichi/docs/debugging.rst:332
msgid ""
"Debugging a Taichi program can be hard even with the builtin tools above."
" Here we showcase some common bugs that one may encounter in a Taichi "
"program."
msgstr ""

#: ../../taichi/docs/debugging.rst:336
msgid "Static type system"
msgstr ""

#: ../../taichi/docs/debugging.rst:338
msgid ""
"Python code in Taichi-scope is translated into a statically typed "
"language for high performance. This means code in Taichi-scope can have a"
" different behavior compared with that in Python-scope, especially when "
"it comes to types."
msgstr ""

#: ../../taichi/docs/debugging.rst:340
msgid ""
"The type of a variable is simply **determined at its initialization and "
"never changes later**."
msgstr ""

#: ../../taichi/docs/debugging.rst:342
msgid ""
"Although Taichi's static type system provides better performance, it may "
"lead to bugs if programmers carelessly used the wrong types. For example,"
msgstr ""

#: ../../taichi/docs/debugging.rst:345
msgid ""
"@ti.kernel\n"
"def buggy():\n"
"    ret = 0  # 0 is an integer, so `ret` is typed as int32\n"
"    for i in range(3):\n"
"        ret += 0.1 * i  # i32 += f32, the result is still stored in "
"int32!\n"
"    print(ret)  # will show 0\n"
"\n"
"buggy()"
msgstr ""

#: ../../taichi/docs/debugging.rst:356
msgid ""
"The code above shows a common bug due to Taichi's static type system. The"
" Taichi compiler should show a warning like:"
msgstr ""

#: ../../taichi/docs/debugging.rst:359
msgid ""
"[W 06/27/20 21:43:51.853] [type_check.cpp:visit@66] [$19] Atomic add "
"(float32 to int32) may lose precision."
msgstr ""

#: ../../taichi/docs/debugging.rst:363
msgid ""
"This means that Taichi cannot store a ``float32`` result precisely to "
"``int32``. The solution is to initialize ``ret`` as a float-point value:"
msgstr ""

#: ../../taichi/docs/debugging.rst:366
msgid ""
"@ti.kernel\n"
"def not_buggy():\n"
"    ret = 0.0  # 0 is a floating point number, so `ret` is typed as "
"float32\n"
"    for i in range(3):\n"
"        ret += 0.1 * i  # f32 += f32. OK!\n"
"    print(ret)  # will show 0.6\n"
"\n"
"not_buggy()"
msgstr ""

#: ../../taichi/docs/debugging.rst:380
msgid "Advanced Optimization"
msgstr ""

#: ../../taichi/docs/debugging.rst:382
msgid ""
"Taichi has an advanced optimization engine to make your Taichi kernel to "
"be as fast as it could. But like what ``gcc -O3`` does, advanced "
"optimization may occasionally lead to bugs as it tries too hard. This "
"includes runtime errors such as:"
msgstr ""

#: ../../taichi/docs/debugging.rst:386
msgid ""
"```RuntimeError: [verify.cpp:basic_verify@40] stmt 8 cannot have operand "
"7.```"
msgstr ""

#: ../../taichi/docs/debugging.rst:388
msgid ""
"You may use ``ti.init(advanced_optimization=False)`` to turn off advanced"
" optimization and see if the issue still exists:"
msgstr ""

#: ../../taichi/docs/debugging.rst:391
msgid ""
"import taichi as ti\n"
"\n"
"ti.init(advanced_optimization=False)\n"
"\n"
"..."
msgstr ""

#: ../../taichi/docs/debugging.rst:399
msgid ""
"Whether or not turning off optimization fixes the issue, please feel free"
" to report this bug on `GitHub <https://github.com/taichi-"
"dev/taichi/issues/new?labels=potential+bug&template=bug_report.md>`_. "
"Thank you!"
msgstr ""

#: ../../taichi/docs/dev_install.rst:4
msgid "Developer installation"
msgstr ""

#: ../../taichi/docs/dev_install.rst:6
msgid ""
"Note this is for the compiler developers of the Taichi programming "
"language. End users should use the pip packages instead of building from "
"source. To build with NVIDIA GPU support, CUDA 10.0+ is needed. This "
"installation guide works for Ubuntu 16.04+ and OS X 10.14+. For precise "
"build instructions on Windows, please check out `appveyor.yml "
"<https://github.com/taichi-dev/taichi/blob/master/appveyor.yml>`_, which "
"does basically the same thing as the following instructions. We use "
"MSBUILD.exe to build the generated project. Please note that Windows "
"could have multiple instances of MSBUILD.exe shipped with different "
"products. Please make sure you add the path for MSBUILD.exe within your "
"MSVS directory and make it a higher priority (for instance than the one "
"shipped with .NET)."
msgstr ""

#: ../../taichi/docs/dev_install.rst:12
msgid ""
"Note that on Linux/OS X, ``clang`` is the only supported compiler for "
"compiling the Taichi compiler. On Windows only MSVC supported."
msgstr ""

#: ../../taichi/docs/dev_install.rst:15
msgid "Installing Dependencies"
msgstr ""

#: ../../taichi/docs/dev_install.rst:17
msgid "Make sure you are using Python 3.6/3.7/3.8"
msgstr ""

#: ../../taichi/docs/dev_install.rst:18
msgid "Install Python dependencies:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:20
msgid ""
"python3 -m pip install --user setuptools astpretty astor pybind11 Pillow "
"dill\n"
"python3 -m pip install --user pytest pytest-rerunfailures pytest-xdist "
"yapf\n"
"python3 -m pip install --user numpy GitPython coverage colorama autograd"
msgstr ""

#: ../../taichi/docs/dev_install.rst:27
msgid "Make sure you have ``clang`` with version >= 7:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:29
msgid ""
"On Windows: Download `clang-10 <https://github.com/taichi-"
"dev/taichi_assets/releases/download/llvm10/clang-10.0.0-win.zip>`_. Make "
"sure you add the ``bin`` folder containing ``clang.exe`` to the ``PATH`` "
"environment variable."
msgstr ""

#: ../../taichi/docs/dev_install.rst:32
msgid "On OS X: you don't need to do anything."
msgstr ""

#: ../../taichi/docs/dev_install.rst:34
msgid "On Ubuntu, execute ``sudo apt install libtinfo-dev clang-8``."
msgstr ""

#: ../../taichi/docs/dev_install.rst:36
msgid "On Arch Linux, execute ``sudo pacman -S clang``. (This is ``clang-10``)."
msgstr ""

#: ../../taichi/docs/dev_install.rst:38
msgid ""
"On other Linux distributions, please search `this site <pkgs.org>`_ for "
"clang version >= 7."
msgstr ""

#: ../../taichi/docs/dev_install.rst:41
msgid ""
"Make sure you have LLVM 10.0.0. Note that Taichi uses a **customized "
"LLVM** so the pre-built binaries from the LLVM official website or other "
"sources probably won't work. Here we provide LLVM binaries customized for"
" Taichi, which may or may not work depending on your system environment:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:44
msgid ""
"`LLVM 10.0.0 for Linux <https://github.com/taichi-"
"dev/taichi_assets/releases/download/llvm10/taichi-"
"llvm-10.0.0-linux.zip>`_"
msgstr ""

#: ../../taichi/docs/dev_install.rst:45
msgid ""
"`LLVM 10.0.0 for Windows MSVC 2019 <https://github.com/taichi-"
"dev/taichi_assets/releases/download/llvm10/taichi-"
"llvm-10.0.0-msvc2019.zip>`_"
msgstr ""

#: ../../taichi/docs/dev_install.rst:46
msgid ""
"`LLVM 10.0.0 for OS X <https://github.com/taichi-"
"dev/taichi_assets/releases/download/llvm10/taichi-"
"llvm-10.0.0-macos.zip>`_"
msgstr ""

#: ../../taichi/docs/dev_install.rst:50
msgid ""
"On Windows, if you use the pre-built LLVM for Taichi, please add "
"``$LLVM_FOLDER/bin`` to ``PATH``. Later, when you build Taichi using "
"``CMake``, set ``LLVM_DIR`` to ``$LLVM_FOLDER/lib/cmake/llvm``."
msgstr ""

#: ../../taichi/docs/dev_install.rst:54
msgid "If the downloaded LLVM does not work, please build from source:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:56
msgid "On Linux or OS X:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:58
msgid ""
"wget https://github.com/llvm/llvm-"
"project/releases/download/llvmorg-10.0.0/llvm-10.0.0.src.tar.xz\n"
"tar xvJf llvm-10.0.0.src.tar.xz\n"
"cd llvm-10.0.0.src\n"
"mkdir build\n"
"cd build\n"
"cmake .. -DLLVM_ENABLE_RTTI:BOOL=ON -DBUILD_SHARED_LIBS:BOOL=OFF "
"-DCMAKE_BUILD_TYPE=Release -DLLVM_TARGETS_TO_BUILD=\"X86;NVPTX\" "
"-DLLVM_ENABLE_ASSERTIONS=ON\n"
"# If you are building on NVIDIA Jetson TX2, use "
"-DLLVM_TARGETS_TO_BUILD=\"ARM;NVPTX\"\n"
"\n"
"make -j 8\n"
"sudo make install\n"
"\n"
"# Check your LLVM installation\n"
"llvm-config --version  # You should get 10.0.0"
msgstr ""

#: ../../taichi/docs/dev_install.rst:74
msgid "On Windows:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:76
msgid ""
"# LLVM 10.0.0 + MSVC 2019\n"
"cmake .. -G\"Visual Studio 16 2019\" -A x64 -DLLVM_ENABLE_RTTI:BOOL=ON "
"-DBUILD_SHARED_LIBS:BOOL=OFF -DCMAKE_BUILD_TYPE=Release "
"-DLLVM_TARGETS_TO_BUILD=\"X86;NVPTX\" -DLLVM_ENABLE_ASSERTIONS=ON "
"-Thost=x64 -DLLVM_BUILD_TESTS:BOOL=OFF -DCMAKE_INSTALL_PREFIX=installed"
msgstr ""

#: ../../taichi/docs/dev_install.rst:81
msgid "Then open ``LLVM.sln`` and use Visual Studio 2017+ to build."
msgstr ""

#: ../../taichi/docs/dev_install.rst:82
msgid ""
"Please make sure you are using the ``Release`` configuration. After "
"building the ``INSTALL`` project (under folder ``CMakePredefinedTargets``"
" in the Solution Explorer window)."
msgstr ""

#: ../../taichi/docs/dev_install.rst:83
msgid ""
"If you use MSVC 2019, **make sure you use C++17** for the ``INSTALL`` "
"project."
msgstr ""

#: ../../taichi/docs/dev_install.rst:84
msgid ""
"After the build is complete, find your LLVM binaries and headers in "
"``build/installed``."
msgstr ""

#: ../../taichi/docs/dev_install.rst:86
msgid ""
"Please add ``build/installed/bin`` to ``PATH``. Later, when you build "
"Taichi using ``CMake``, set ``LLVM_DIR`` to "
"``build/installed/lib/cmake/llvm``."
msgstr ""

#: ../../taichi/docs/dev_install.rst:91
msgid "Setting up CUDA (optional)"
msgstr ""

#: ../../taichi/docs/dev_install.rst:93
msgid ""
"If you don't have CUDA, go to `this website <https://developer.nvidia.com"
"/cuda-downloads>`_ and download the installer."
msgstr ""

#: ../../taichi/docs/dev_install.rst:95
msgid ""
"To check if CUDA is installed, run ``nvcc --version`` or ``cat "
"/usr/local/cuda/version.txt``."
msgstr ""

#: ../../taichi/docs/dev_install.rst:96
msgid "On **Ubuntu** we recommend choosing ``deb (local)`` as **Installer Type**."
msgstr ""

#: ../../taichi/docs/dev_install.rst:97
msgid ""
"On **Arch Linux**, you can easily install CUDA via ``pacman -S cuda`` "
"without downloading the installer manually."
msgstr ""

#: ../../taichi/docs/dev_install.rst:103
msgid "Setting up Taichi for development"
msgstr ""

#: ../../taichi/docs/dev_install.rst:105
msgid "Set up environment variables for Taichi:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:107
msgid ""
"On Linux / OS X, please add the following script to your rc file "
"(``~/.bashrc``, ``~/.zshrc`` or etc. , same for other occurrences in this"
" documentation):"
msgstr ""

#: ../../taichi/docs/dev_install.rst:109
msgid ""
"export TAICHI_REPO_DIR=/path/to/taichi  # Path to your taichi repository\n"
"export PYTHONPATH=$TAICHI_REPO_DIR/python:$PYTHONPATH\n"
"export PATH=$TAICHI_REPO_DIR/bin:$PATH\n"
"# export CXX=/path/to/clang  # Uncomment if you encounter issue about "
"compiler in the next step.\n"
"# export PATH=/opt/llvm/bin:$PATH  # Uncomment if your llvm or clang is "
"installed in /opt"
msgstr ""

#: ../../taichi/docs/dev_install.rst:117
msgid "Then execute ``source ~/.bashrc`` to reload shell config."
msgstr ""

#: ../../taichi/docs/dev_install.rst:119
msgid "On Windows, please add these variables by accessing your system settings:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:121
msgid ""
"Add ``TAICHI_REPO_DIR`` whose value is the path to your taichi repository"
" so that Taichi knows you're a developer."
msgstr ""

#: ../../taichi/docs/dev_install.rst:122
msgid ""
"Add or append ``PYTHONPATH`` with ``%TAICHI_REPO_DIR%/python`` so that "
"Python imports Taichi from the local repo."
msgstr ""

#: ../../taichi/docs/dev_install.rst:123
msgid ""
"Add or append ``PATH`` with ``%TAICHI_REPO_DIR%/bin`` so that you can use"
" ``ti`` command."
msgstr ""

#: ../../taichi/docs/dev_install.rst:124
msgid ""
"Add or append ``PATH`` with path to LLVM binary directory installed in "
"previous section."
msgstr ""

#: ../../taichi/docs/dev_install.rst:126
msgid "Clone the taichi repo **recursively**, and build:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:128
msgid ""
"git clone https://github.com/taichi-dev/taichi --depth=1 --branch=master\n"
"cd taichi\n"
"git submodule update --init --recursive --depth=1\n"
"mkdir build\n"
"cd build\n"
"cmake ..\n"
"# On Linux / OS X, if you do not set clang as the default compiler\n"
"# use the line below:\n"
"#   cmake .. -DCMAKE_CXX_COMPILER=clang\n"
"#\n"
"# Alternatively, if you would like to set clang as the default compiler\n"
"# On Unix CMake honors environment variables $CC and $CXX upon deciding "
"which C and C++ compilers to use\n"
"make -j 8"
msgstr ""

#: ../../taichi/docs/dev_install.rst:144
msgid ""
"Check out ``examples`` for runnable examples. Run them with commands like"
" ``python3 examples/mpm128.py``."
msgstr ""

#: ../../taichi/docs/dev_install.rst:145
msgid ""
"Execute ``python3 -m taichi test`` to run all the tests. It may take up "
"to 5 minutes to run all tests."
msgstr ""

#: ../../taichi/docs/dev_install.rst:149
msgid "Troubleshooting Developer Installation"
msgstr ""

#: ../../taichi/docs/dev_install.rst:151
msgid ""
"If ``make`` fails to compile and reports ``fatal error: 'spdlog/XXX.h' "
"file not found``, please try runing ``git submodule update --init "
"--recursive --depth=1``."
msgstr ""

#: ../../taichi/docs/dev_install.rst:155
msgid "If importing Taichi causes"
msgstr ""

#: ../../taichi/docs/dev_install.rst:157
msgid ""
"FileNotFoundError: [Errno 2] No such file or directory: "
"'/root/taichi/python/taichi/core/../lib/taichi_core.so' -> "
"'/root/taichi/python/taichi/core/../lib/libtaichi_core.so'``"
msgstr ""

#: ../../taichi/docs/dev_install.rst:161
msgid ""
"Please try adding ``TAICHI_REPO_DIR`` to environment variables, see "
":ref:`dev_env_settings`."
msgstr ""

#: ../../taichi/docs/dev_install.rst:163
msgid ""
"If the build succeeded but running any Taichi code results in errors like"
" ``Bitcode file (/tmp/taichi-tero94pl/runtime//runtime_x64.bc) not "
"found``, please double check ``clang`` is in your ``PATH``:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:166
msgid ""
"clang --version\n"
"# version should be >= 7"
msgstr ""

#: ../../taichi/docs/dev_install.rst:171
msgid "and our **Taichi configured** ``llvm-as``:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:173
msgid ""
"llvm-as --version\n"
"# version should be >= 8\n"
"which llvm-as\n"
"# should be /usr/local/bin/llvm-as or /opt/XXX/bin/llvm-as, which is our "
"configured installation"
msgstr ""

#: ../../taichi/docs/dev_install.rst:180
msgid ""
"If not, please install ``clang`` and **build LLVM from source** with "
"instructions above in :ref:`dev_install`, then add their path to "
"environment variable ``PATH``."
msgstr ""

#: ../../taichi/docs/dev_install.rst:182
msgid ""
"If you encounter other issues, feel free to report by `opening an issue "
"on GitHub <https://github.com/taichi-"
"dev/taichi/issues/new?labels=potential+bug&template=bug_report.md>`_. We "
"are willing to help!"
msgstr ""

#: ../../taichi/docs/dev_install.rst:184
msgid ""
"See also :ref:`troubleshooting` for issues that may share with end-user "
"installation."
msgstr ""

#: ../../taichi/docs/dev_install.rst:187
msgid "Docker"
msgstr ""

#: ../../taichi/docs/dev_install.rst:189
msgid ""
"For those who prefer to use Docker, we also provide a Dockerfile which "
"helps setup the Taichi development environment with CUDA support based on"
" Ubuntu docker image."
msgstr ""

#: ../../taichi/docs/dev_install.rst:193
msgid ""
"In order to follow the instructions in this section, please make sure you"
" have the `Docker DeskTop (or Engine for Linux) "
"<https://www.docker.com/products/docker-desktop>`_ installed and set up "
"properly."
msgstr ""

#: ../../taichi/docs/dev_install.rst:198
msgid "Build the Docker Image"
msgstr ""

#: ../../taichi/docs/dev_install.rst:199
msgid ""
"From within the root directory of the taichi Git repository, execute "
"``docker build -t taichi:latest .`` to build a Docker image based off the"
" local master branch tagged with *latest*. Since this builds the image "
"from source, please expect up to 40 mins build time if you don't have "
"cached Docker image layers."
msgstr ""

#: ../../taichi/docs/dev_install.rst:204
msgid ""
"In order to save the time on building Docker images, you could always "
"visit our `Docker Hub repository "
"<https://hub.docker.com/r/taichidev/taichi>`_ and pull the versions of "
"pre-built images you would like to use. Currently the builds are "
"triggered per taichi Github release."
msgstr ""

#: ../../taichi/docs/dev_install.rst:207
msgid ""
"For example, to pull a image built from release v0.6.17, run ``docker "
"pull taichidev/taichi:v0.6.17``"
msgstr ""

#: ../../taichi/docs/dev_install.rst:210
msgid "Use Docker Image on macOS (cpu only)"
msgstr ""

#: ../../taichi/docs/dev_install.rst:211
msgid "Make sure ``XQuartz`` and ``socat`` are installed:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:213
msgid ""
"brew cask install xquartz\n"
"brew install socat"
msgstr ""

#: ../../taichi/docs/dev_install.rst:218 ../../taichi/docs/dev_install.rst:239
msgid "Temporally disable the xhost access-control: ``xhost +``"
msgstr ""

#: ../../taichi/docs/dev_install.rst:219
msgid ""
"Start the Docker container with ``docker run -it -e DISPLAY=$(ipconfig "
"getifaddr en0):0 taichidev/taichi:v0.6.17``"
msgstr ""

#: ../../taichi/docs/dev_install.rst:220 ../../taichi/docs/dev_install.rst:241
msgid ""
"Do whatever you want within the container, e.g. you could run tests or an"
" example, try: ``ti test`` or ``ti example mpm88``"
msgstr ""

#: ../../taichi/docs/dev_install.rst:221 ../../taichi/docs/dev_install.rst:242
msgid "Exit from the container with ``exit`` or ``ctrl+D``"
msgstr ""

#: ../../taichi/docs/dev_install.rst:222 ../../taichi/docs/dev_install.rst:243
msgid "[To keep your xhost safe] Re-enable the xhost access-control: ``xhost -``"
msgstr ""

#: ../../taichi/docs/dev_install.rst:225
msgid "Use Docker Image on Ubuntu (with CUDA support)"
msgstr ""

#: ../../taichi/docs/dev_install.rst:226
msgid ""
"Make sure your host machine has CUDA properly installed and configured. "
"Usually you could verify it by running ``nvidia-smi``"
msgstr ""

#: ../../taichi/docs/dev_install.rst:227
msgid ""
"Make sure ` NVIDIA Container Toolkit <https://github.com/NVIDIA/nvidia-"
"docker>`_ is properly installed:"
msgstr ""

#: ../../taichi/docs/dev_install.rst:229
msgid ""
"distribution=$(. /etc/os-release;echo $ID$VERSION_ID)\n"
"curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key "
"add -\n"
"curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-"
"docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list\n"
"\n"
"sudo apt-get update && sudo apt-get install -y nvidia-container-toolkit\n"
"sudo systemctl restart docker"
msgstr ""

#: ../../taichi/docs/dev_install.rst:238
msgid "Make sure ``xorg`` is installed: ``sudo apt-get install xorg``"
msgstr ""

#: ../../taichi/docs/dev_install.rst:240
msgid ""
"Start the Docker container with ``sudo docker run -it --gpus all -e "
"DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix "
"taichidev/taichi:v0.6.17``"
msgstr ""

#: ../../taichi/docs/dev_install.rst:246
msgid ""
"The nature of Docker container determines that no changes to the file "
"system on the container could be preserved once you exit from the "
"container. If you want to use Docker as a persistent development "
"environment, we recommend you `mount the taichi Git repository to the "
"container as a volume <https://docs.docker.com/storage/volumes/>`_ and "
"set the Python path to the mounted directory."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:4
#: ../../taichi/docs/overview.rst:10
msgid "Differentiable programming"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:6
msgid ""
"We suggest starting with the ``ti.Tape()``, and then migrate to more "
"advanced differentiable programming using the ``kernel.grad()`` syntax if"
" necessary."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:10
msgid "Introduction"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:12
msgid "For example, you have the following kernel:"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:14
msgid ""
"x = ti.var(ti.f32, ())\n"
"y = ti.var(ti.f32, ())\n"
"\n"
"@ti.kernel\n"
"def compute_y():\n"
"    y[None] = ti.sin(x[None])"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:24
msgid ""
"Now if you want to get the derivative of y corresponding to x, i.e., "
"dy/dx. You may want to implement the derivative kernel by yourself:"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:27
msgid ""
"x = ti.var(ti.f32, ())\n"
"y = ti.var(ti.f32, ())\n"
"dy_dx = ti.var(ti.f32, ())\n"
"\n"
"@ti.kernel\n"
"def compute_dy_dx():\n"
"    dy_dx[None] = ti.cos(x[None])"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:38
msgid ""
"But wait, what if I changed the original ``compute_y``? We will have to "
"recalculate the derivative by hand and rewrite ``compute_dy_dx`` again, "
"which is very error-prone and not convenient at all."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:42
msgid ""
"If this situation occurs, don't worry! Taichi provides a handy autodiff "
"system that can help you obtain the derivative of a kernel without any "
"pain!"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:47
msgid "Using ``ti.Tape()``"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:49
msgid ""
"Let's still take the ``compute_y`` in above example for explaination. "
"What's the most convienent way to obtain a kernel that computes x to "
"dy/dx?"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:52
msgid ""
"Use the ``needs_grad=True`` option when declaring fields involved in the "
"derivative chain."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:54
msgid ""
"Use ``with ti.Tape(y):`` to embrace the invocation into kernel(s) you "
"want to compute derivative."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:56
msgid "Now ``x.grad[None]`` is the dy/dx value at current x."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:58
msgid ""
"x = ti.var(ti.f32, (), needs_grad=True)\n"
"y = ti.var(ti.f32, (), needs_grad=True)\n"
"\n"
"@ti.kernel\n"
"def compute_y():\n"
"    y[None] = ti.sin(x[None])\n"
"\n"
"with ti.Tape(y):\n"
"    compute_y()\n"
"\n"
"print('dy/dx =', x.grad[None])\n"
"print('at x =', x[None])"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:74
msgid "It's equivalant to:"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:76
msgid ""
"x = ti.var(ti.f32, ())\n"
"y = ti.var(ti.f32, ())\n"
"dy_dx = ti.var(ti.f32, ())\n"
"\n"
"@ti.kernel\n"
"def compute_dy_dx():\n"
"    dy_dx[None] = ti.cos(x[None])\n"
"\n"
"compute_dy_dx()\n"
"\n"
"print('dy/dx =', dy_dx[None])\n"
"print('at x =', x[None])"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:93
msgid "Usage example"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:95
msgid ""
"For a physical simulation, sometimes it could be easy to compute the "
"energy but hard to compute the force on each particles."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:98
msgid ""
"But recall that we can differentiate (negative) potential energy to get "
"forces. a.k.a.: ``F_i = -dU / dx_i``. So once you've write a kernel that "
"is able to compute the potential energy, you may use Taichi's autodiff "
"system to obtain the derivative of it and then the force on each "
"particles."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:104
msgid ""
"Take `examples/ad_gravity.py <https://github.com/taichi-"
"dev/taichi/blob/master/examples/ad_gravity.py>`_ as an example:"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:106
msgid ""
"import taichi as ti\n"
"ti.init()\n"
"\n"
"N = 8\n"
"dt = 1e-5\n"
"\n"
"x = ti.Vector.var(2, ti.f32, N, needs_grad=True)  # position of particles"
"\n"
"v = ti.Vector.var(2, ti.f32, N)                   # velocity of particles"
"\n"
"U = ti.var(ti.f32, (), needs_grad=True)           # potential energy\n"
"\n"
"\n"
"@ti.kernel\n"
"def compute_U():\n"
"    for i, j in ti.ndrange(N, N):\n"
"        r = x[i] - x[j]\n"
"        # r.norm(1e-3) is equivalent to ti.sqrt(r.norm()**2 + 1e-3)\n"
"        # This is to prevent 1/0 error which can cause wrong derivative\n"
"        U[None] += -1 / r.norm(1e-3)  # U += -1 / |r|\n"
"\n"
"\n"
"@ti.kernel\n"
"def advance():\n"
"    for i in x:\n"
"        v[i] += dt * -x.grad[i]  # dv/dt = -dU/dx\n"
"    for i in x:\n"
"        x[i] += dt * v[i]        # dx/dt = v\n"
"\n"
"\n"
"def substep():\n"
"    with ti.Tape(U):\n"
"        # every kernel invocation within this indent scope\n"
"        # will also be accounted into the partial derivate of U\n"
"        # with corresponding input variables like x.\n"
"        compute_U()   # will also computes dU/dx and save in x.grad\n"
"    advance()\n"
"\n"
"\n"
"@ti.kernel\n"
"def init():\n"
"    for i in x:\n"
"        x[i] = [ti.random(), ti.random()]\n"
"\n"
"\n"
"init()\n"
"gui = ti.GUI('Autodiff gravity')\n"
"while gui.running:\n"
"    for i in range(50):\n"
"        substep()\n"
"    print('U = ', U[None])\n"
"    gui.circles(x.to_numpy(), radius=3)\n"
"    gui.show()"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:163
msgid "The argument ``U`` to ``ti.Tape(U)`` must be a 0D field."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:165
msgid ""
"For using autodiff with multiple output variables, please see the "
"``kernel.grad()`` usage below."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:170
msgid "``ti.Tape(U)`` will automatically set `U[None]`` to 0 on start up."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:173
msgid ""
"See `examples/mpm_lagrangian_forces.py <https://github.com/taichi-"
"dev/taichi/blob/master/examples/mpm_lagrangian_forces.py>`_ and "
"`examples/fem99.py <https://github.com/taichi-"
"dev/taichi/blob/master/examples/fem99.py>`_ for examples on using "
"autodiff for MPM and FEM."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:177
msgid "Using ``kernel.grad()``"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:179
msgid "TODO: Documentation WIP."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:185
msgid "Kernel Simplicity Rule"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:187
msgid ""
"Unlike tools such as TensorFlow where **immutable** output buffers are "
"generated, the **imperative** programming paradigm adopted in Taichi "
"allows programmers to freely modify global fields."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:189
msgid ""
"To make automatic differentiation well-defined under this setting, we "
"make the following assumption on Taichi programs for differentiable "
"programming:"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:191
msgid "**Global Data Access Rules:**"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:193
msgid ""
"If a global field element is written more than once, then starting from "
"the second write, the write **must** come in the form of an atomic add "
"(“accumulation\", using ``ti.atomic_add`` or simply ``+=``)."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:194
msgid ""
"No read accesses happen to a global field element, until its accumulation"
" is done."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:196
msgid ""
"**Kernel Simplicity Rule:** Kernel body consists of multiple `simply "
"nested` for-loops. I.e., each for-loop can either contain exactly one "
"(nested) for-loop (and no other statements), or a group of statements "
"without loops."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:199
msgid "Example:"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:201
msgid ""
"@ti.kernel\n"
"def differentiable_task():\n"
"  for i in x:\n"
"    x[i] = y[i]\n"
"\n"
"  for i in range(10):\n"
"    for j in range(20):\n"
"      for k in range(300):\n"
"        ... do whatever you want, as long as there are no loops\n"
"\n"
"  # Not allowed. The outer for loop contains two for loops\n"
"  for i in range(10):\n"
"    for j in range(20):\n"
"      ...\n"
"    for j in range(20):\n"
"      ..."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:220
msgid "Taichi programs that violate this rule will result in an error."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:224
msgid ""
"**static for-loops** (e.g. ``for i in ti.static(range(4))``) will get "
"unrolled by the Python frontend preprocessor and therefore does not count"
" as a level of loop."
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:228
msgid "DiffTaichi"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:230
msgid ""
"The `DiffTaichi repo <https://github.com/yuanming-hu/difftaichi>`_ "
"contains 10 differentiable physical simulators built with Taichi "
"differentiable programming. A few examples with neural network "
"controllers optimized using differentiable simulators and brute-force "
"gradient descent:"
msgstr ""

#: ../../taichi/docs/differentiable_programming.rst:239
msgid ""
"Check out `the DiffTaichi paper <https://arxiv.org/pdf/1910.00935.pdf>`_ "
"and `video <https://www.youtube.com/watch?v=Z1xvAZve9aE>`_ to learn more "
"about Taichi differentiable programming."
msgstr ""

#: ../../taichi/docs/export_results.rst:4
msgid "Export your results"
msgstr ""

#: ../../taichi/docs/export_results.rst:5
msgid ""
"Taichi has functions that help you **export visual results to images or "
"videos**. This tutorial demonstrates how to use them step by step."
msgstr ""

#: ../../taichi/docs/export_results.rst:8
msgid "Export images"
msgstr ""

#: ../../taichi/docs/export_results.rst:10
msgid "There are two ways to export visual results of your program to images."
msgstr ""

#: ../../taichi/docs/export_results.rst:11
msgid "The first and easier way is to make use of ``ti.GUI``."
msgstr ""

#: ../../taichi/docs/export_results.rst:12
msgid "The second way is to call some Taichi functions such as ``ti.imwrite``."
msgstr ""

#: ../../taichi/docs/export_results.rst:15
msgid "Export images using ``ti.GUI.show``"
msgstr ""

#: ../../taichi/docs/export_results.rst:17
msgid ""
"``ti.GUI.show(filename)`` can not only display the GUI canvas on your "
"screen, but also save the image to your specified ``filename``."
msgstr ""

#: ../../taichi/docs/export_results.rst:18
msgid ""
"Note that the format of the image is fully determined by the suffix of "
"``filename``."
msgstr ""

#: ../../taichi/docs/export_results.rst:19
msgid "Taichi now supports saving to ``png``, ``jpg``, and ``bmp`` formats."
msgstr ""

#: ../../taichi/docs/export_results.rst:20
msgid "We recommend using ``png`` format. For example:"
msgstr ""

#: ../../taichi/docs/export_results.rst:22
msgid ""
"import taichi as ti\n"
"import os\n"
"\n"
"ti.init()\n"
"\n"
"pixels = ti.field(ti.u8, shape=(512, 512, 3))\n"
"\n"
"@ti.kernel\n"
"def paint():\n"
"    for i, j, k in pixels:\n"
"        pixels[i, j, k] = ti.random() * 255\n"
"\n"
"iterations = 1000\n"
"gui = ti.GUI(\"Random pixels\", res=512)\n"
"\n"
"# mainloop\n"
"for i in range(iterations):\n"
"    paint()\n"
"    gui.set_image(pixels)\n"
"\n"
"    filename = f'frame_{i:05d}.png'   # create filename with suffix png\n"
"    print(f'Frame {i} is recorded in {filename}')\n"
"    gui.show(filename)  # export and show in GUI"
msgstr ""

#: ../../taichi/docs/export_results.rst:48
msgid ""
"After running the code above, you will get a series of images in the "
"current folder."
msgstr ""

#: ../../taichi/docs/export_results.rst:51
msgid "Export images using ``ti.imwrite``"
msgstr ""

#: ../../taichi/docs/export_results.rst:52
msgid ""
"To save images without invoking ``ti.GUI.show(filename)``, use "
"``ti.imwrite(filename)``. For example:"
msgstr ""

#: ../../taichi/docs/export_results.rst:54
msgid ""
"import taichi as ti\n"
"\n"
"ti.init()\n"
"\n"
"pixels = ti.field(ti.u8, shape=(512, 512, 3))\n"
"\n"
"@ti.kernel\n"
"def set_pixels():\n"
"    for i, j, k in pixels:\n"
"        pixels[i, j, k] = ti.random() * 255\n"
"\n"
"set_pixels()\n"
"filename = f'imwrite_export.png'\n"
"ti.imwrite(pixels.to_numpy(), filename)\n"
"print(f'The image has been saved to {filename}')"
msgstr ""

#: ../../taichi/docs/export_results.rst:72
msgid ""
"``ti.imwrite`` can export Taichi fields (``ti.Matrix.field``, "
"``ti.Vector.field``, ``ti.field``) and numpy arrays ``np.ndarray``."
msgstr ""

#: ../../taichi/docs/export_results.rst:73
msgid ""
"Same as above ``ti.GUI.show(filename)``, the image format (``png``, "
"``jpg`` and ``bmp``) is also controlled by the suffix of ``filename`` in "
"``ti.imwrite(filename)``."
msgstr ""

#: ../../taichi/docs/export_results.rst:74
msgid ""
"Meanwhile, the resulted image type (grayscale, RGB, or RGBA) is "
"determined by **the number of channels in the input field**, i.e., the "
"length of the third dimension (``field.shape[2]``)."
msgstr ""

#: ../../taichi/docs/export_results.rst:75
msgid ""
"In other words, a field that has shape ``(w, h)`` or ``(w, h, 1)`` will "
"be exported as a grayscale image."
msgstr ""

#: ../../taichi/docs/export_results.rst:76
msgid ""
"If you want to export ``RGB`` or ``RGBA`` images instead, the input field"
" should have a shape ``(w, h, 3)`` or ``(w, h, 4)`` respectively."
msgstr ""

#: ../../taichi/docs/export_results.rst:80
msgid ""
"All Taichi fields have their own data types, such as ``ti.u8`` and "
"``ti.f32``. Different data types can lead to different behaviors of "
"``ti.imwrite``. Please check out :ref:`gui` for more details."
msgstr ""

#: ../../taichi/docs/export_results.rst:82
msgid ""
"Taichi offers other helper functions that read and show images in "
"addition to ``ti.imwrite``. They are also demonstrated in :ref:`gui`."
msgstr ""

#: ../../taichi/docs/export_results.rst:85
msgid "Export videos"
msgstr ""

#: ../../taichi/docs/export_results.rst:89
msgid ""
"The video export utilities of Taichi depend on ``ffmpeg``. If ``ffmpeg`` "
"is not installed on your machine, please follow the installation "
"instructions of ``ffmpeg`` at the end of this page."
msgstr ""

#: ../../taichi/docs/export_results.rst:91
msgid ""
"``ti.VideoManager`` can help you export results in ``mp4`` or ``gif`` "
"format. For example,"
msgstr ""

#: ../../taichi/docs/export_results.rst:93
msgid ""
"import taichi as ti\n"
"\n"
"ti.init()\n"
"\n"
"pixels = ti.field(ti.u8, shape=(512, 512, 3))\n"
"\n"
"@ti.kernel\n"
"def paint():\n"
"    for i, j, k in pixels:\n"
"        pixels[i, j, k] = ti.random() * 255\n"
"\n"
"result_dir = \"./results\"\n"
"video_manager = ti.VideoManager(output_dir=result_dir, framerate=24, "
"automatic_build=False)\n"
"\n"
"for i in range(50):\n"
"    paint()\n"
"\n"
"    pixels_img = pixels.to_numpy()\n"
"    video_manager.write_frame(pixels_img)\n"
"    print(f'\\rFrame {i+1}/50 is recorded', end='')\n"
"\n"
"print()\n"
"print('Exporting .mp4 and .gif videos...')\n"
"video_manager.make_video(gif=True, mp4=True)\n"
"print(f'MP4 video is saved to "
"{video_manager.get_output_filename(\".mp4\")}')\n"
"print(f'GIF video is saved to "
"{video_manager.get_output_filename(\".gif\")}')"
msgstr ""

#: ../../taichi/docs/export_results.rst:122
msgid ""
"After running the code above, you will find the output videos in the "
"``./results/`` folder."
msgstr ""

#: ../../taichi/docs/export_results.rst:125
msgid "Install ffmpeg"
msgstr ""

#: ../../taichi/docs/export_results.rst:128
msgid "Install ffmpeg on Windows"
msgstr ""

#: ../../taichi/docs/export_results.rst:130
msgid ""
"Download the ``ffmpeg`` archive(named ``ffmpeg-2020xxx.zip``) from "
"`ffmpeg <https://ffmpeg.org/download.html>`_;"
msgstr ""

#: ../../taichi/docs/export_results.rst:132
msgid "Unzip this archive to a folder, such as \"D:/YOUR_FFMPEG_FOLDER\";"
msgstr ""

#: ../../taichi/docs/export_results.rst:134
msgid ""
"**Important:** add ``D:/YOUR_FFMPEG_FOLDER/bin`` to the ``PATH`` "
"environment variable;"
msgstr ""

#: ../../taichi/docs/export_results.rst:136
msgid ""
"Open the Windows ``cmd`` or ``PowerShell`` and type the line of code "
"below to test your installation. If ``ffmpeg`` is set up properly, the "
"version information will be printed."
msgstr ""

#: ../../taichi/docs/export_results.rst:138
msgid "ffmpeg -version"
msgstr ""

#: ../../taichi/docs/export_results.rst:143
msgid "Install ``ffmpeg`` on Linux"
msgstr ""

#: ../../taichi/docs/export_results.rst:144
msgid ""
"Most Linux distribution came with ``ffmpeg`` natively, so you do not need"
" to read this part if the ``ffmpeg`` command is already there on your "
"machine."
msgstr ""

#: ../../taichi/docs/export_results.rst:145
msgid "Install ``ffmpeg`` on Ubuntu"
msgstr ""

#: ../../taichi/docs/export_results.rst:147
msgid ""
"sudo apt-get update\n"
"sudo apt-get install ffmpeg"
msgstr ""

#: ../../taichi/docs/export_results.rst:152
msgid "Install ``ffmpeg`` on CentOS and RHEL"
msgstr ""

#: ../../taichi/docs/export_results.rst:154
msgid "sudo yum install ffmpeg ffmpeg-devel"
msgstr ""

#: ../../taichi/docs/export_results.rst:158
msgid "Install ``ffmpeg`` on Arch Linux:"
msgstr ""

#: ../../taichi/docs/export_results.rst:164
msgid "Test your installation using"
msgstr ""

#: ../../taichi/docs/export_results.rst:166
msgid "ffmpeg -h"
msgstr ""

#: ../../taichi/docs/export_results.rst:171
msgid "Install ``ffmpeg`` on OS X"
msgstr ""

#: ../../taichi/docs/export_results.rst:173
msgid "``ffmpeg`` can be installed on OS X using ``homebrew``:"
msgstr ""

#: ../../taichi/docs/export_results.rst:175
msgid "brew install ffmpeg"
msgstr ""

#: ../../taichi/docs/export_results.rst:182
msgid "Export PLY files"
msgstr ""

#: ../../taichi/docs/export_results.rst:183
msgid ""
"``ti.PLYwriter`` can help you export results in the ``ply`` format. Below"
" is a short example of exporting 10 frames of a moving cube with vertices"
" randomly colored,"
msgstr ""

#: ../../taichi/docs/export_results.rst:185
msgid ""
"import taichi as ti\n"
"import numpy as np\n"
"\n"
"ti.init(arch=ti.cpu)\n"
"\n"
"num_vertices = 1000\n"
"pos = ti.Vector.field(3, dtype=ti.f32, shape=(10, 10, 10))\n"
"rgba = ti.Vector.field(4, dtype=ti.f32, shape=(10, 10, 10))\n"
"\n"
"\n"
"@ti.kernel\n"
"def place_pos():\n"
"    for i, j, k in pos:\n"
"        pos[i, j, k] = 0.1 * ti.Vector([i, j, k])\n"
"\n"
"\n"
"@ti.kernel\n"
"def move_particles():\n"
"    for i, j, k in pos:\n"
"        pos[i, j, k] += ti.Vector([0.1, 0.1, 0.1])\n"
"\n"
"\n"
"@ti.kernel\n"
"def fill_rgba():\n"
"    for i, j, k in rgba:\n"
"        rgba[i, j, k] = ti.Vector(\n"
"            [ti.random(), ti.random(), ti.random(), ti.random()])\n"
"\n"
"\n"
"place_pos()\n"
"series_prefix = \"example.ply\"\n"
"for frame in range(10):\n"
"    move_particles()\n"
"    fill_rgba()\n"
"    # now adding each channel only supports passing individual np.array\n"
"    # so converting into np.ndarray, reshape\n"
"    # remember to use a temp var to store so you dont have to convert "
"back\n"
"    np_pos = np.reshape(pos.to_numpy(), (num_vertices, 3))\n"
"    np_rgba = np.reshape(rgba.to_numpy(), (num_vertices, 4))\n"
"    # create a PLYWriter\n"
"    writer = ti.PLYWriter(num_vertices=num_vertices)\n"
"    writer.add_vertex_pos(np_pos[:, 0], np_pos[:, 1], np_pos[:, 2])\n"
"    writer.add_vertex_rgba(\n"
"        np_rgba[:, 0], np_rgba[:, 1], np_rgba[:, 2], np_rgba[:, 3])\n"
"    writer.export_frame_ascii(frame, series_prefix)"
msgstr ""

#: ../../taichi/docs/export_results.rst:233
msgid ""
"After running the code above, you will find the output sequence of "
"``ply`` files in the current working directory. Next, we will break down "
"the usage of ``ti.PLYWriter`` into 4 steps and show some examples."
msgstr ""

#: ../../taichi/docs/export_results.rst:235
msgid "Setup ``ti.PLYWriter``"
msgstr ""

#: ../../taichi/docs/export_results.rst:237
msgid ""
"# num_vertices must be a positive int\n"
"# num_faces is optional, default to 0\n"
"# face_type can be either \"tri\" or \"quad\", default to \"tri\"\n"
"\n"
"# in our previous example, a writer with 1000 vertices and 0 triangle "
"faces is created\n"
"num_vertices = 1000\n"
"writer = ti.PLYWriter(num_vertices=num_vertices)\n"
"\n"
"# in the below example, a writer with 20 vertices and 5 quadrangle faces "
"is created\n"
"writer2 = ti.PLYWriter(num_vertices=20, num_faces=5, face_type=\"quad\")"
msgstr ""

#: ../../taichi/docs/export_results.rst:250
msgid "Add required channels"
msgstr ""

#: ../../taichi/docs/export_results.rst:252
msgid ""
"# A 2D grid with quad faces\n"
"#     y\n"
"#     |\n"
"# z---/\n"
"#    x\n"
"#         19---15---11---07---03\n"
"#         |    |    |    |    |\n"
"#         18---14---10---06---02\n"
"#         |    |    |    |    |\n"
"#         17---13---19---05---01\n"
"#         |    |    |    |    |\n"
"#         16---12---08---04---00\n"
"\n"
"writer = ti.PLYWriter(num_vertices=20, num_faces=12, face_type=\"quad\")\n"
"\n"
"# For the vertices, the only required channel is the position,\n"
"# which can be added by passing 3 np.array x, y, z into the following "
"function.\n"
"\n"
"x = np.zeros(20)\n"
"y = np.array(list(np.arange(0, 4))*5)\n"
"z = np.repeat(np.arange(5), 4)\n"
"writer.add_vertex_pos(x, y, z)\n"
"\n"
"# For faces (if any), the only required channel is the list of vertex "
"indices that each face contains.\n"
"indices = np.array([0, 1, 5, 4]*12)+np.repeat(\n"
"    np.array(list(np.arange(0, 3))*4)+4*np.repeat(np.arange(4), 3), 4)\n"
"writer.add_faces(indices)"
msgstr ""

#: ../../taichi/docs/export_results.rst:282
msgid "Add optional channels"
msgstr ""

#: ../../taichi/docs/export_results.rst:284
msgid ""
"# Add custome vertex channel, the input should include a key, a supported"
" datatype and, the data np.array\n"
"vdata = np.random.rand(20)\n"
"writer.add_vertex_channel(\"vdata1\", \"double\", vdata)\n"
"\n"
"# Add custome face channel\n"
"foo_data = np.zeros(12)\n"
"writer.add_face_channel(\"foo_key\", \"foo_data_type\", foo_data)\n"
"# error! because \"foo_data_type\" is not a supported datatype. Supported"
" ones are\n"
"# ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'double']\n"
"\n"
"# PLYwriter already defines several useful helper functions for common "
"channels\n"
"# Add vertex color, alpha, and rgba\n"
"# using float/double r g b alpha to reprent color, the range should be 0 "
"to 1\n"
"r = np.random.rand(20)\n"
"g = np.random.rand(20)\n"
"b = np.random.rand(20)\n"
"alpha = np.random.rand(20)\n"
"writer.add_vertex_color(r, g, b)\n"
"writer.add_vertex_alpha(alpha)\n"
"# equivilantly\n"
"# add_vertex_rgba(r, g, b, alpha)\n"
"\n"
"# vertex normal\n"
"writer.add_vertex_normal(np.ones(20), np.zeros(20), np.zeros(20))\n"
"\n"
"# vertex index, and piece (group id)\n"
"writer.add_vertex_id()\n"
"writer.add_vertex_piece(np.ones(20))\n"
"\n"
"# Add face index, and piece (group id)\n"
"# Indexing the existing faces in the writer and add this channel to face "
"channels\n"
"writer.add_face_id()\n"
"# Set all the faces is in group 1\n"
"writer.add_face_piece(np.ones(12))"
msgstr ""

#: ../../taichi/docs/export_results.rst:321
msgid "Export files"
msgstr ""

#: ../../taichi/docs/export_results.rst:323
msgid ""
"series_prefix = \"example.ply\"\n"
"series_prefix_ascii = \"example_ascii.ply\"\n"
"# Export a single file\n"
"# use ascii so you can read the content\n"
"writer.export_ascii(series_prefix_ascii)\n"
"\n"
"# alternatively, use binary for a bit better performance\n"
"# writer.export(series_prefix)\n"
"\n"
"# Export a sequence of files, ie in 10 frames\n"
"for frame in range(10):\n"
"    # write each frame as i.e. \"example_000000.ply\" in your current "
"running folder\n"
"    writer.export_frame_ascii(frame, series_prefix_ascii)\n"
"    # alternatively, use binary\n"
"    # writer.export_frame(frame, series_prefix)\n"
"\n"
"    # update location/color\n"
"    x = x + 0.1*np.random.rand(20)\n"
"    y = y + 0.1*np.random.rand(20)\n"
"    z = z + 0.1*np.random.rand(20)\n"
"    r = np.random.rand(20)\n"
"    g = np.random.rand(20)\n"
"    b = np.random.rand(20)\n"
"    alpha = np.random.rand(20)\n"
"    # re-fill\n"
"    writer = ti.PLYWriter(num_vertices=20, num_faces=12, "
"face_type=\"quad\")\n"
"    writer.add_vertex_pos(x, y, z)\n"
"    writer.add_faces(indices)\n"
"    writer.add_vertex_channel(\"vdata1\", \"double\", vdata)\n"
"    writer.add_vertex_color(r, g, b)\n"
"    writer.add_vertex_alpha(alpha)\n"
"    writer.add_vertex_normal(np.ones(20), np.zeros(20), np.zeros(20))\n"
"    writer.add_vertex_id()\n"
"    writer.add_vertex_piece(np.ones(20))\n"
"    writer.add_face_id()\n"
"    writer.add_face_piece(np.ones(12))"
msgstr ""

#: ../../taichi/docs/export_results.rst:363
msgid "Import ``ply`` files into Houdini and Blender"
msgstr ""

#: ../../taichi/docs/export_results.rst:364
msgid ""
"Houdini supports importing a series of ``ply`` files sharing the same "
"prefix/post-fix. Our ``export_frame`` can achieve the requirement for "
"you. In Houdini, click ``File->Import->Geometry`` and navigate to the "
"folder containing your frame results, who should be collapsed into one "
"single entry like ``example_$F6.ply (0-9)``. Double-click this entry to "
"finish the importing process."
msgstr ""

#: ../../taichi/docs/export_results.rst:366
msgid ""
"Blender requires an add-on called `Stop-motion-OBJ "
"<https://github.com/neverhood311/Stop-motion-OBJ>`_ to load the result "
"sequences. `Detailed documentation <https://github.com/neverhood311/Stop-"
"motion-OBJ/wiki>`_ is provided by the author on how to install and use "
"the add-on. If you're using the latest version of Blender (2.80+), "
"download and install the `latest release <https://github.com/neverhood311"
"/Stop-motion-OBJ/releases/latest>`_ of Stop-motion-OBJ. For Blender 2.79 "
"and older, use version ``v1.1.1`` of the add-on."
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:2
msgid "Extension libraries"
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:4
msgid ""
"The Taichi programming language offers a minimal and generic built-in "
"standard library. Extra domain-specific functionalities are provided via "
"**extension libraries**:"
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:8
msgid "Taichi GLSL"
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:10
msgid ""
"`Taichi GLSL <https://github.com/taichi-dev/taichi_glsl>`_ is an "
"extension library of Taichi, aiming at providing useful helper functions "
"including:"
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:13
msgid "Handy scalar functions like ``clamp``, ``smoothstep``, ``mix``, ``round``."
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:14
msgid "GLSL-alike vector functions like ``normalize``, ``distance``, ``reflect``."
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:15
msgid "Well-behaved random generators including ``randUnit2D``, ``randNDRange``."
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:16
msgid "Handy vector and matrix initializer: ``vec`` and ``mat``."
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:17
msgid "Handy vector component shuffle accessor like ``v.xy``."
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:19
msgid ""
"Click here for `Taichi GLSL Documentation <https://taichi-"
"glsl.readthedocs.io>`_."
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:21
msgid "python3 -m pip install taichi_glsl"
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:27
msgid "Taichi THREE"
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:29
msgid ""
"`Taichi THREE <https://github.com/taichi-dev/taichi_three>`_ is an "
"extension library of Taichi to render 3D scenes into nice-looking 2D "
"images in real-time (work in progress)."
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:35
msgid ""
"Click here for `Taichi THREE Tutorial <https://github.com/taichi-"
"dev/taichi_three#how-to-play>`_."
msgstr ""

#: ../../taichi/docs/extension_libraries.rst:37
msgid "python3 -m pip install taichi_three"
msgstr ""

#: ../../taichi/docs/external.rst:4
msgid "Interacting with external arrays"
msgstr ""

#: ../../taichi/docs/external.rst:6
msgid "**External arrays** refer to ``numpy.ndarray`` or ``torch.Tensor``."
msgstr ""

#: ../../taichi/docs/external.rst:9
msgid "Conversion between Taichi fields and external arrays"
msgstr ""

#: ../../taichi/docs/external.rst:11
msgid "Use ``to_numpy``/``from_numpy``/``to_torch``/``from_torch``:"
msgstr ""

#: ../../taichi/docs/external.rst:13
msgid ""
"import taichi as ti\n"
"import numpy as np\n"
"\n"
"ti.init()\n"
"\n"
"n = 4\n"
"m = 7\n"
"\n"
"# Taichi fields\n"
"val = ti.field(ti.i32, shape=(n, m))\n"
"vec = ti.Vector.field(3, dtype=ti.i32, shape=(n, m))\n"
"mat = ti.Matrix.field(3, 4, dtype=ti.i32, shape=(n, m))\n"
"\n"
"# Scalar\n"
"arr = np.ones(shape=(n, m), dtype=np.int32)\n"
"\n"
"val.from_numpy(arr)\n"
"\n"
"arr = val.to_numpy()\n"
"\n"
"# Vector\n"
"arr = np.ones(shape=(n, m, 3), dtype=np.int32)\n"
"\n"
"vec.from_numpy(arr)\n"
"\n"
"arr = np.ones(shape=(n, m, 3, 1), dtype=np.int32)\n"
"vec.from_numpy(arr)\n"
"\n"
"arr = vec.to_numpy()\n"
"assert arr.shape == (n, m, 3)\n"
"\n"
"arr = vec.to_numpy(keep_dims=True)\n"
"assert arr.shape == (n, m, 3, 1)\n"
"\n"
"# Matrix\n"
"arr = np.ones(shape=(n, m, 3, 4), dtype=np.int32)\n"
"\n"
"mat.from_numpy(arr)\n"
"\n"
"arr = mat.to_numpy()\n"
"assert arr.shape == (n, m, 3, 4)"
msgstr ""

#: ../../taichi/docs/external.rst:58
msgid "TODO: add API reference"
msgstr ""

#: ../../taichi/docs/external.rst:62
msgid "Using external arrays as Taichi kernel parameters"
msgstr ""

#: ../../taichi/docs/external.rst:64
msgid ""
"The type hint for external array parameters is ``ti.ext_arr()``. Please "
"see the example below. Note that struct-for's on external arrays are not "
"supported."
msgstr ""

#: ../../taichi/docs/external.rst:67
msgid ""
"import taichi as ti\n"
"import numpy as np\n"
"\n"
"ti.init()\n"
"\n"
"n = 4\n"
"m = 7\n"
"\n"
"val = ti.field(ti.i32, shape=(n, m))\n"
"\n"
"@ti.kernel\n"
"def test_numpy(arr: ti.ext_arr()):\n"
"  for i in range(n):\n"
"    for j in range(m):\n"
"      arr[i, j] += i + j\n"
"\n"
"a = np.empty(shape=(n, m), dtype=np.int32)\n"
"\n"
"for i in range(n):\n"
"  for j in range(m):\n"
"    a[i, j] = i * j\n"
"\n"
"test_numpy(a)\n"
"\n"
"for i in range(n):\n"
"  for j in range(m):\n"
"    assert a[i, j] == i * j + i + j"
msgstr ""

#: ../../taichi/docs/faq.rst:2
msgid "Frequently asked questions"
msgstr ""

#: ../../taichi/docs/faq.rst:5
msgid "**Q:** Installing Taichi with ``pip``, complains ``package not found``."
msgstr ""

#: ../../taichi/docs/faq.rst:7
msgid ""
"**A:** Is your Python version >= 3.6, and 64-bit? See "
":ref:`troubleshooting`."
msgstr ""

#: ../../taichi/docs/faq.rst:9
msgid "**Q:** Do we have something like ``ti.pi``?"
msgstr ""

#: ../../taichi/docs/faq.rst:11
msgid ""
"**A:** No, but you may use ``math.pi`` or ``numpy.pi`` instead. Taichi is"
" able to bake in these constants during JIT, so your kernels incur no "
"runtime cost."
msgstr ""

#: ../../taichi/docs/faq.rst:13
msgid ""
"**Q:** How do I **force** an outermost loop to be serial, i.e. **not "
"parallelized**?"
msgstr ""

#: ../../taichi/docs/faq.rst:15
msgid "**A:** Try this trick:"
msgstr ""

#: ../../taichi/docs/faq.rst:17
msgid ""
"for _ in range(1):  # I'm the outer-most loop!\n"
"    for i in range(100):  # This loop will not be parallelized\n"
"        ..."
msgstr ""

#: ../../taichi/docs/faq.rst:23
msgid ""
"**Q:** What's the most convenient way to load images / textures into "
"Taichi fields?"
msgstr ""

#: ../../taichi/docs/faq.rst:25
msgid "**A:** Simply use ``field.from_numpy(ti.imread('filename.png'))``."
msgstr ""

#: ../../taichi/docs/faq.rst:27
msgid ""
"**Q:** Can Taichi co-operate with **other Python packages** like "
"``matplotlib``?"
msgstr ""

#: ../../taichi/docs/faq.rst:29
msgid ""
"**A:** Yes, as long as that *package* provides an interface with "
"``numpy``, see :ref:`other_python_packages`."
msgstr ""

#: ../../taichi/docs/faq.rst:31
msgid ""
"**Q:** Shall we add some handy functions like ``ti.smoothstep`` or "
"``ti.vec3``?"
msgstr ""

#: ../../taichi/docs/faq.rst:33
msgid ""
"**A:** No, but we provide them in an extension library `Taichi GLSL "
"<https://taichi-glsl.readthedocs.io>`_ , install it using:"
msgstr ""

#: ../../taichi/docs/faq.rst:35
msgid "python -m pip install taichi_glsl"
msgstr ""

#: ../../taichi/docs/faq.rst:39
msgid ""
"**Q:** How can I **render 3D results** without writing a ray tracer "
"myself?"
msgstr ""

#: ../../taichi/docs/faq.rst:42
msgid ""
"**A:** You may export it with :ref:`export_ply_files` so that you could "
"view it in Houdini or Blender."
msgstr ""

#: ../../taichi/docs/faq.rst:42
msgid ""
"Or make use the extension library `Taichi THREE <https://github.com"
"/taichi-dev/taichi_glsl>`_ to render images and update to GUI in real-"
"time."
msgstr ""

#: ../../taichi/docs/faq.rst:44
msgid "**Q:** How do I declare a field with **dynamic length**?"
msgstr ""

#: ../../taichi/docs/faq.rst:48
msgid ""
"**A:** What you want may be the ``dynamic`` SNode, a kind of sparse "
"field, see :ref:`dynamic`."
msgstr ""

#: ../../taichi/docs/faq.rst:47
msgid ""
"Or simply allocate a dense field large enough, and another 0-D field "
"``field_len[None]`` for length record. But in fact, the ``dynamic`` SNode"
" could be slower than the latter solution, due to the cost of maintaining"
" the sparsity information."
msgstr ""

#: ../../taichi/docs/faq.rst:50
msgid ""
"**Q:** Can a user iterate over irregular topologies (e.g., graphs or "
"tetrahedral meshes) instead of regular grids?"
msgstr ""

#: ../../taichi/docs/faq.rst:52
msgid ""
"**A:** These structures have to be represented using 1D arrays in Taichi."
" You can still iterate over them using ``for i in x`` or ``for i in "
"range(n)``."
msgstr ""

#: ../../taichi/docs/faq.rst:53
msgid ""
"However, at compile time, there's little the Taichi compiler can do for "
"you to optimize it. You can still tweak the data layout to get different "
"runtime cache behaviors and performance numbers."
msgstr ""

#: ../../taichi/docs/global_settings.rst:2
msgid "Global settings"
msgstr ""

#: ../../taichi/docs/global_settings.rst:5
msgid "Backends"
msgstr ""

#: ../../taichi/docs/global_settings.rst:7
msgid "To specify which Arch to use: ``ti.init(arch=ti.cuda)``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:8
msgid ""
"To specify pre-allocated memory size for CUDA: "
"``ti.init(device_memory_GB=0.5)``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:9
msgid ""
"To disable unified memory usage on CUDA: "
"``ti.init(use_unified_memory=False)``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:10
msgid ""
"To specify which GPU to use for CUDA: ``export "
"CUDA_VISIBLE_DEVICES=[gpuid]``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:11
msgid "To disable a backend on start up, say, CUDA: ``export TI_ENABLE_CUDA=0``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:14
msgid "Compilation"
msgstr ""

#: ../../taichi/docs/global_settings.rst:16
msgid ""
"Disable advanced optimization to save compile time & possible errors: "
"``ti.init(advanced_optimization=False)``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:17
msgid ""
"Disable fast math to prevent possible undefined math behavior: "
"``ti.init(fast_math=False)``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:18
msgid "To print preprocessed Python code: ``ti.init(print_preprocessed=True)``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:19
msgid "To show pretty Taichi-scope stack traceback: ``ti.init(excepthook=True)``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:20
msgid "To print intermediate IR generated: ``ti.init(print_ir=True)``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:23
msgid "Runtime"
msgstr ""

#: ../../taichi/docs/global_settings.rst:25
msgid ""
"Restart the entire Taichi system (destroy all fields and kernels): "
"``ti.reset()``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:26
msgid ""
"To start program in debug mode: ``ti.init(debug=True)`` or ``ti debug "
"your_script.py``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:27
msgid "To disable importing torch on start up: ``export TI_ENABLE_TORCH=0``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:30 ../../taichi/docs/utilities.rst:7
msgid "Logging"
msgstr ""

#: ../../taichi/docs/global_settings.rst:32
msgid ""
"Show more detailed log to level TRACE: ``ti.init(log_level=ti.TRACE)`` or"
" ``ti.set_logging_level(ti.TRACE)``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:33
msgid "Eliminate verbose outputs: ``ti.init(verbose=False)``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:36
msgid "Develop"
msgstr ""

#: ../../taichi/docs/global_settings.rst:38
msgid "To trigger GDB when Taichi crashes: ``ti.init(gdb_trigger=True)``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:39
msgid ""
"Cache compiled runtime bitcode in **dev mode** to save start up time: "
"``export TI_CACHE_RUNTIME_BITCODE=1``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:40
msgid ""
"To specify how many threads to run test: ``export TI_TEST_THREADS=4`` or "
"``ti test -t4``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:44
msgid "Specifying ``ti.init`` arguments from environment variables"
msgstr ""

#: ../../taichi/docs/global_settings.rst:46
msgid ""
"Arguments for ``ti.init`` may also be specified from environment "
"variables. For example:"
msgstr ""

#: ../../taichi/docs/global_settings.rst:48
msgid "``ti.init(arch=ti.cuda)`` is equivalent to ``export TI_ARCH=cuda``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:49
msgid ""
"``ti.init(log_level=ti.TRACE)`` is equivalent to ``export "
"TI_LOG_LEVEL=trace``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:50
msgid "``ti.init(debug=True)`` is equivalent to ``export TI_DEBUG=1``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:51
msgid ""
"``ti.init(use_unified_memory=False)`` is equivalent to ``export "
"TI_USE_UNIFIED_MEMORY=0``."
msgstr ""

#: ../../taichi/docs/global_settings.rst:53
msgid ""
"If both ``ti.init`` argument and the corresponding environment variable "
"are specified, then the one in the environment variable will **override**"
" the one in the argument, e.g.:"
msgstr ""

#: ../../taichi/docs/global_settings.rst:56
msgid ""
"if ``ti.init(arch=ti.cuda)`` and ``export TI_ARCH=opengl`` are specified "
"at the same time, then Taichi will choose ``ti.opengl`` as backend."
msgstr ""

#: ../../taichi/docs/global_settings.rst:58
msgid ""
"if ``ti.init(debug=True)`` and ``export TI_DEBUG=0`` are specified at the"
" same time, then Taichi will disable debug mode."
msgstr ""

#: ../../taichi/docs/global_settings.rst:63
msgid ""
"If ``ti.init`` is called twice, then the configuation in first invocation"
" will be completely discarded, e.g.:"
msgstr ""

#: ../../taichi/docs/global_settings.rst:68
msgid ""
"ti.init(debug=True)\n"
"print(ti.cfg.debug)  # True\n"
"ti.init()\n"
"print(ti.cfg.debug)  # False"
msgstr ""

#: ../../taichi/docs/gui.rst:4
msgid "GUI system"
msgstr ""

#: ../../taichi/docs/gui.rst:6
msgid "Taichi has a built-in GUI system to help users visualize results."
msgstr ""

#: ../../taichi/docs/gui.rst:10
msgid "Create a window"
msgstr ""

#: ../../taichi/docs/gui.rst ../../taichi/docs/matrix.rst
#: ../../taichi/docs/scalar_tensor.rst ../../taichi/docs/snode.rst
#: ../../taichi/docs/vector.rst
msgid "Parameters"
msgstr ""

#: ../../taichi/docs/gui.rst:15
msgid "(optional, string) the window title"
msgstr ""

#: ../../taichi/docs/gui.rst:16
msgid "(optional, scalar or tuple) resolution / size of the window"
msgstr ""

#: ../../taichi/docs/gui.rst:17
msgid "(optional, RGB hex) background color of the window"
msgstr ""

#: ../../taichi/docs/gui.rst:18
msgid "(GUI) an object represents the window"
msgstr ""

#: ../../taichi/docs/gui.rst:20
msgid "Create a window. If ``res`` is scalar, then width will be equal to height."
msgstr ""

#: ../../taichi/docs/gui.rst:23
msgid "The following code creates a window of resolution ``640x360``:"
msgstr ""

#: ../../taichi/docs/gui.rst:27
msgid "gui = ti.GUI('Window Title', (640, 360))"
msgstr ""

#: ../../taichi/docs/gui.rst:32 ../../taichi/docs/gui.rst:55
#: ../../taichi/docs/gui.rst:109 ../../taichi/docs/gui.rst:119
#: ../../taichi/docs/gui.rst:134 ../../taichi/docs/gui.rst:145
#: ../../taichi/docs/gui.rst:156 ../../taichi/docs/gui.rst:167
#: ../../taichi/docs/gui.rst:178 ../../taichi/docs/gui.rst:189
msgid "(GUI) the window object"
msgstr ""

#: ../../taichi/docs/gui.rst:33
msgid "(optional, string) see notes below"
msgstr ""

#: ../../taichi/docs/gui.rst:35
msgid "Show the window on the screen."
msgstr ""

#: ../../taichi/docs/gui.rst:38
msgid ""
"If ``filename`` is specified, a screenshot will be saved to the file "
"specified by the name. For example, the following saves frames of the "
"window to ``.png``'s:"
msgstr ""

#: ../../taichi/docs/gui.rst:43
msgid ""
"for frame in range(10000):\n"
"    render(img)\n"
"    gui.set_image(img)\n"
"    gui.show(f'{frame:06d}.png')"
msgstr ""

#: ../../taichi/docs/gui.rst:50
msgid "Paint on a window"
msgstr ""

#: ../../taichi/docs/gui.rst:56
msgid "(np.array or ti.field) field containing the image, see notes below"
msgstr ""

#: ../../taichi/docs/gui.rst:58
msgid "Set an image to display on the window."
msgstr ""

#: ../../taichi/docs/gui.rst:60
msgid ""
"The image pixels are set from the values of ``img[i, j]``, where ``i`` "
"indicates the horizontal coordinates (from left to right) and ``j`` the "
"vertical coordinates (from bottom to top)."
msgstr ""

#: ../../taichi/docs/gui.rst:63
msgid "If the window size is ``(x, y)``, then ``img`` must be one of:"
msgstr ""

#: ../../taichi/docs/gui.rst:65
msgid "``ti.field(shape=(x, y))``, a grey-scale image"
msgstr ""

#: ../../taichi/docs/gui.rst:67
msgid "``ti.field(shape=(x, y, 3))``, where `3` is for ``(r, g, b)`` channels"
msgstr ""

#: ../../taichi/docs/gui.rst:69
msgid "``ti.field(shape=(x, y, 2))``, where `2` is for ``(r, g)`` channels"
msgstr ""

#: ../../taichi/docs/gui.rst:71
msgid ""
"``ti.Vector.field(3, shape=(x, y))`` ``(r, g, b)`` channels on each "
"component (see :ref:`vector`)"
msgstr ""

#: ../../taichi/docs/gui.rst:73
msgid "``ti.Vector.field(2, shape=(x, y))`` ``(r, g)`` channels on each component"
msgstr ""

#: ../../taichi/docs/gui.rst:75
msgid "``np.ndarray(shape=(x, y))``"
msgstr ""

#: ../../taichi/docs/gui.rst:77
msgid "``np.ndarray(shape=(x, y, 3))``"
msgstr ""

#: ../../taichi/docs/gui.rst:79
msgid "``np.ndarray(shape=(x, y, 2))``"
msgstr ""

#: ../../taichi/docs/gui.rst:82
msgid "The data type of ``img`` must be one of:"
msgstr ""

#: ../../taichi/docs/gui.rst:84
msgid "``uint8``, range ``[0, 255]``"
msgstr ""

#: ../../taichi/docs/gui.rst:86
msgid "``uint16``, range ``[0, 65535]``"
msgstr ""

#: ../../taichi/docs/gui.rst:88
msgid "``uint32``, range ``[0, 4294967295]``"
msgstr ""

#: ../../taichi/docs/gui.rst:90
msgid "``float32``, range ``[0, 1]``"
msgstr ""

#: ../../taichi/docs/gui.rst:92
msgid "``float64``, range ``[0, 1]``"
msgstr ""

#: ../../taichi/docs/gui.rst:96
msgid ""
"When using ``float32`` or ``float64`` as the data type, ``img`` entries "
"will be clipped into range ``[0, 1]`` for display."
msgstr ""

#: ../../taichi/docs/gui.rst:102
msgid "(np.array) the current image shown on the GUI"
msgstr ""

#: ../../taichi/docs/gui.rst:104
msgid "Get the 4-channel (RGBA) image shown in the current GUI system."
msgstr ""

#: ../../taichi/docs/gui.rst:110
msgid "(tuple of 2) the position of the circle"
msgstr ""

#: ../../taichi/docs/gui.rst:111
msgid "(optional, RGB hex) the color to fill the circle"
msgstr ""

#: ../../taichi/docs/gui.rst:112
msgid "(optional, scalar) the radius of the circle"
msgstr ""

#: ../../taichi/docs/gui.rst:114
msgid "Draw a solid circle."
msgstr ""

#: ../../taichi/docs/gui.rst:120
msgid "(np.array) the positions of the circles"
msgstr ""

#: ../../taichi/docs/gui.rst:121
msgid "(optional, RGB hex or np.array of uint32) the color(s) to fill the circles"
msgstr ""

#: ../../taichi/docs/gui.rst:122
msgid ""
"(optional, scalar or np.array of float32) the radius (radii) of the "
"circles"
msgstr ""

#: ../../taichi/docs/gui.rst:124
msgid "Draw solid circles."
msgstr ""

#: ../../taichi/docs/gui.rst:128
msgid ""
"If ``color`` is a numpy array, the circle at ``pos[i]`` will be colored "
"with ``color[i]``. In this case, ``color`` must have the same size as "
"``pos``."
msgstr ""

#: ../../taichi/docs/gui.rst:135
msgid "(tuple of 2) the first end point position of line"
msgstr ""

#: ../../taichi/docs/gui.rst:136
msgid "(tuple of 2) the second end point position of line"
msgstr ""

#: ../../taichi/docs/gui.rst:137
msgid "(optional, RGB hex) the color of line"
msgstr ""

#: ../../taichi/docs/gui.rst:138
msgid "(optional, scalar) the width of line"
msgstr ""

#: ../../taichi/docs/gui.rst:140
msgid "Draw a line."
msgstr ""

#: ../../taichi/docs/gui.rst:146
msgid "(np.array) the positions of the first end point of lines"
msgstr ""

#: ../../taichi/docs/gui.rst:147
msgid "(np.array) the positions of the second end point of lines"
msgstr ""

#: ../../taichi/docs/gui.rst:148
msgid "(optional, RGB hex or np.array of uint32) the color(s) of lines"
msgstr ""

#: ../../taichi/docs/gui.rst:149
msgid "(optional, scalar or np.array of float32) the width(s) of the lines"
msgstr ""

#: ../../taichi/docs/gui.rst:151
msgid "Draw lines."
msgstr ""

#: ../../taichi/docs/gui.rst:157
msgid "(tuple of 2) the first end point position of triangle"
msgstr ""

#: ../../taichi/docs/gui.rst:158
msgid "(tuple of 2) the second end point position of triangle"
msgstr ""

#: ../../taichi/docs/gui.rst:159
msgid "(tuple of 2) the third end point position of triangle"
msgstr ""

#: ../../taichi/docs/gui.rst:160
msgid "(optional, RGB hex) the color to fill the triangle"
msgstr ""

#: ../../taichi/docs/gui.rst:162
msgid "Draw a solid triangle."
msgstr ""

#: ../../taichi/docs/gui.rst:168
msgid "(np.array) the positions of the first end point of triangles"
msgstr ""

#: ../../taichi/docs/gui.rst:169
msgid "(np.array) the positions of the second end point of triangles"
msgstr ""

#: ../../taichi/docs/gui.rst:170
msgid "(np.array) the positions of the third end point of triangles"
msgstr ""

#: ../../taichi/docs/gui.rst:171
msgid ""
"(optional, RGB hex or np.array of uint32) the color(s) to fill the "
"triangles"
msgstr ""

#: ../../taichi/docs/gui.rst:173
msgid "Draw solid triangles."
msgstr ""

#: ../../taichi/docs/gui.rst:179
msgid "(tuple of 2) the top-left point position of rectangle"
msgstr ""

#: ../../taichi/docs/gui.rst:180
msgid "(tuple of 2) the bottom-right point position of rectangle"
msgstr ""

#: ../../taichi/docs/gui.rst:181
msgid "(optional, RGB hex) the color of stroke line"
msgstr ""

#: ../../taichi/docs/gui.rst:182
msgid "(optional, scalar) the width of stroke line"
msgstr ""

#: ../../taichi/docs/gui.rst:184
msgid "Draw a hollow rectangle."
msgstr ""

#: ../../taichi/docs/gui.rst:190
msgid "(str) the text to draw"
msgstr ""

#: ../../taichi/docs/gui.rst:191
msgid "(tuple of 2) the top-left point position of the fonts / texts"
msgstr ""

#: ../../taichi/docs/gui.rst:192
msgid "(optional, scalar) the size of font (in height)"
msgstr ""

#: ../../taichi/docs/gui.rst:193
msgid "(optional, RGB hex) the foreground color of text"
msgstr ""

#: ../../taichi/docs/gui.rst:195
msgid "Draw a line of text on screen."
msgstr ""

#: ../../taichi/docs/gui.rst:200
msgid "(tuple of 3 floats) The (R, G, B) float values, in range [0, 1]"
msgstr ""

#: ../../taichi/docs/gui.rst:201
msgid "(RGB hex or np.array of uint32) The converted hex value"
msgstr ""

#: ../../taichi/docs/gui.rst:203
msgid "Convert a (R, G, B) tuple of floats into a single integer value. E.g.,"
msgstr ""

#: ../../taichi/docs/gui.rst:205
msgid ""
"rgb = (0.4, 0.8, 1.0)\n"
"hex = ti.rgb_to_hex(rgb)  # 0x66ccff\n"
"\n"
"rgb = np.array([[0.4, 0.8, 1.0], [0.0, 0.5, 1.0]])\n"
"hex = ti.rgb_to_hex(rgb)  # np.array([0x66ccff, 0x007fff])"
msgstr ""

#: ../../taichi/docs/gui.rst:213
msgid "The return values can be used in GUI drawing APIs."
msgstr ""

#: ../../taichi/docs/gui.rst:219
msgid "Event processing"
msgstr ""

#: ../../taichi/docs/gui.rst:221
msgid "Every event have a key and type."
msgstr ""

#: ../../taichi/docs/gui.rst:223
msgid ""
"*Event type* is the type of event, for now, there are just three type of "
"event:"
msgstr ""

#: ../../taichi/docs/gui.rst:227
msgid ""
"ti.GUI.RELEASE  # key up or mouse button up\n"
"ti.GUI.PRESS    # key down or mouse button down\n"
"ti.GUI.MOTION   # mouse motion or mouse wheel"
msgstr ""

#: ../../taichi/docs/gui.rst:231
msgid ""
"*Event key* is the key that you pressed on keyboard or mouse, can be one "
"of:"
msgstr ""

#: ../../taichi/docs/gui.rst:235
msgid ""
"# for ti.GUI.PRESS and ti.GUI.RELEASE event:\n"
"ti.GUI.ESCAPE  # Esc\n"
"ti.GUI.SHIFT   # Shift\n"
"ti.GUI.LEFT    # Left Arrow\n"
"'a'            # we use lowercase for alphabet\n"
"'b'\n"
"...\n"
"ti.GUI.LMB     # Left Mouse Button\n"
"ti.GUI.RMB     # Right Mouse Button\n"
"\n"
"# for ti.GUI.MOTION event:\n"
"ti.GUI.MOVE    # Mouse Moved\n"
"ti.GUI.WHEEL   # Mouse Wheel Scrolling"
msgstr ""

#: ../../taichi/docs/gui.rst:249
msgid ""
"A *event filter* is a list combined of *key*, *type* and *(type, key)* "
"tuple, e.g.:"
msgstr ""

#: ../../taichi/docs/gui.rst:251
msgid ""
"# if ESC pressed or released:\n"
"gui.get_event(ti.GUI.ESCAPE)\n"
"\n"
"# if any key is pressed:\n"
"gui.get_event(ti.GUI.PRESS)\n"
"\n"
"# if ESC pressed or SPACE released:\n"
"gui.get_event((ti.GUI.PRESS, ti.GUI.ESCAPE), (ti.GUI.RELEASE, "
"ti.GUI.SPACE))"
msgstr ""

#: ../../taichi/docs/gui.rst:265 ../../taichi/docs/gui.rst:296
#: ../../taichi/docs/gui.rst:322 ../../taichi/docs/gui.rst:341
#: ../../taichi/docs/gui.rst:362 ../../taichi/docs/gui.rst:374
msgid "(GUI)"
msgstr ""

#: ../../taichi/docs/gui.rst:266
msgid "(bool) ``True`` if ``ti.GUI.EXIT`` event occurred, vice versa"
msgstr ""

#: ../../taichi/docs/gui.rst:268
msgid ""
"``ti.GUI.EXIT`` occurs when you click on the close (X) button of a "
"window. So ``gui.running`` will obtain ``False`` when the GUI is being "
"closed."
msgstr ""

#: ../../taichi/docs/gui.rst:271
msgid "For example, loop until the close button is clicked:"
msgstr ""

#: ../../taichi/docs/gui.rst:275
msgid ""
"while gui.running:\n"
"    render()\n"
"    gui.set_image(pixels)\n"
"    gui.show()"
msgstr ""

#: ../../taichi/docs/gui.rst:281
msgid ""
"You can also close the window by manually setting ``gui.running`` to "
"``False``:"
msgstr ""

#: ../../taichi/docs/gui.rst:285
msgid ""
"while gui.running:\n"
"    if gui.get_event(ti.GUI.ESCAPE):\n"
"        gui.running = False\n"
"\n"
"    render()\n"
"    gui.set_image(pixels)\n"
"    gui.show()"
msgstr ""

#: ../../taichi/docs/gui.rst:297 ../../taichi/docs/gui.rst:323
msgid "(optional, EventFilter) filter out matched events"
msgstr ""

#: ../../taichi/docs/gui.rst:298
msgid "(bool) ``False`` if there is no pending event, vise versa"
msgstr ""

#: ../../taichi/docs/gui.rst:300
msgid "Try to pop a event from the queue, and store it in ``gui.event``."
msgstr ""

#: ../../taichi/docs/gui.rst:306
msgid ""
"if gui.get_event():\n"
"    print('Got event, key =', gui.event.key)"
msgstr ""

#: ../../taichi/docs/gui.rst:310
msgid "For example, loop until ESC is pressed:"
msgstr ""

#: ../../taichi/docs/gui.rst:314
msgid ""
"gui = ti.GUI('Title', (640, 480))\n"
"while not gui.get_event(ti.GUI.ESCAPE):\n"
"    gui.set_image(img)\n"
"    gui.show()"
msgstr ""

#: ../../taichi/docs/gui.rst:324
msgid "(generator) a python generator, see below"
msgstr ""

#: ../../taichi/docs/gui.rst:326
msgid ""
"Basically the same as ``gui.get_event``, except for this one returns a "
"generator of events instead of storing into ``gui.event``:"
msgstr ""

#: ../../taichi/docs/gui.rst:330
msgid ""
"for e in gui.get_events():\n"
"    if e.key == ti.GUI.ESCAPE:\n"
"        exit()\n"
"    elif e.key == ti.GUI.SPACE:\n"
"        do_something()\n"
"    elif e.key in ['a', ti.GUI.LEFT]:\n"
"        ..."
msgstr ""

#: ../../taichi/docs/gui.rst:342
msgid "(EventKey) keys you want to detect"
msgstr ""

#: ../../taichi/docs/gui.rst:343
msgid "(bool) ``True`` if one of the keys pressed, vice versa"
msgstr ""

#: ../../taichi/docs/gui.rst:347
msgid ""
"Must be used together with ``gui.get_event``, or it won't be updated! For"
" example:"
msgstr ""

#: ../../taichi/docs/gui.rst:352
msgid ""
"while True:\n"
"    gui.get_event()  # must be called before is_pressed\n"
"    if gui.is_pressed('a', ti.GUI.LEFT):\n"
"        print('Go left!')\n"
"    elif gui.is_pressed('d', ti.GUI.RIGHT):\n"
"        print('Go right!')"
msgstr ""

#: ../../taichi/docs/gui.rst:363
msgid "(tuple of 2) current cursor position within the window"
msgstr ""

#: ../../taichi/docs/gui.rst:369
msgid "mouse_x, mouse_y = gui.get_cursor_pos()"
msgstr ""

#: ../../taichi/docs/gui.rst:375
msgid "(scalar or None) the maximum FPS, ``None`` for no limit"
msgstr ""

#: ../../taichi/docs/gui.rst:377
msgid "The default value is 60."
msgstr ""

#: ../../taichi/docs/gui.rst:379
msgid ""
"For example, to restrict FPS to be below 24, simply ``gui.fps_limit = "
"24``. This helps reduce the overload on your hardware especially when "
"you're using OpenGL on your intergrated GPU which could make desktop slow"
" to response."
msgstr ""

#: ../../taichi/docs/gui.rst:386
msgid "GUI Widgets"
msgstr ""

#: ../../taichi/docs/gui.rst:388
msgid ""
"Sometimes it's more intuitive to use widgets like slider, button to "
"control program variables instead of chaotic keyboard bindings. Taichi "
"GUI provides a set of widgets that hopefully could make variable control "
"more intuitive:"
msgstr ""

#: ../../taichi/docs/gui.rst:395
msgid "(str) the text to be displayed above this slider."
msgstr ""

#: ../../taichi/docs/gui.rst:396
msgid "(float) the minimum value of the slider value."
msgstr ""

#: ../../taichi/docs/gui.rst:397
msgid "(float) the maximum value of the slider value."
msgstr ""

#: ../../taichi/docs/gui.rst:398
msgid "(optional, float) the step between two separate value."
msgstr ""

#: ../../taichi/docs/gui.rst:400 ../../taichi/docs/gui.rst:409
msgid "(WidgetValue) a value getter / setter, see :class:`WidgetValue`."
msgstr ""

#: ../../taichi/docs/gui.rst:402
msgid ""
"The widget will be display as: ``{text}: {value:.3f}``, followed with a "
"slider."
msgstr ""

#: ../../taichi/docs/gui.rst:407
msgid "(str) the text to be displayed in the label."
msgstr ""

#: ../../taichi/docs/gui.rst:411
msgid "The widget will be display as: ``{text}: {value:.3f}``."
msgstr ""

#: ../../taichi/docs/gui.rst:416
msgid "(str) the text to be displayed in the button."
msgstr ""

#: ../../taichi/docs/gui.rst:417
msgid "(optional, str) customize the event name."
msgstr ""

#: ../../taichi/docs/gui.rst:419
msgid "(EventKey) the event key for this button, see :ref:`gui_event`."
msgstr ""

#: ../../taichi/docs/gui.rst:424
msgid "A getter / setter for widget values."
msgstr ""

#: ../../taichi/docs/gui.rst:428
msgid "Get / set the current value in the widget where we're returned from."
msgstr ""

#: ../../taichi/docs/gui.rst:430 ../../taichi/docs/matrix.rst:150
msgid "For example::"
msgstr ""

#: ../../taichi/docs/gui.rst:432
msgid ""
"radius = gui.slider('Radius', 1, 50)\n"
"\n"
"while gui.running:\n"
"    print('The radius now is', radius.value)\n"
"    ...\n"
"    radius.value += 0.01\n"
"    ...\n"
"    gui.show()"
msgstr ""

#: ../../taichi/docs/gui.rst:442
msgid "Image I/O"
msgstr ""

#: ../../taichi/docs/gui.rst:446
msgid "(ti.Vector.field or ti.field) the image you want to export"
msgstr ""

#: ../../taichi/docs/gui.rst:447
msgid "(string) the location you want to save to"
msgstr ""

#: ../../taichi/docs/gui.rst:449
msgid ""
"Export a ``np.ndarray`` or Taichi field (``ti.Matrix.field``, "
"``ti.Vector.field``, or ``ti.field``) to a specified location "
"``filename``."
msgstr ""

#: ../../taichi/docs/gui.rst:451
msgid ""
"Same as ``ti.GUI.show(filename)``, the format of the exported image is "
"determined by **the suffix of** ``filename`` as well. Now ``ti.imwrite`` "
"supports exporting images to ``png``, ``img`` and ``jpg`` and we "
"recommend using ``png``."
msgstr ""

#: ../../taichi/docs/gui.rst:453
msgid ""
"Please make sure that the input image has **a valid shape**. If you want "
"to export a grayscale image, the input shape of field should be "
"``(height, weight)`` or ``(height, weight, 1)``. For example:"
msgstr ""

#: ../../taichi/docs/gui.rst:455
msgid ""
"import taichi as ti\n"
"\n"
"ti.init()\n"
"\n"
"shape = (512, 512)\n"
"type = ti.u8\n"
"pixels = ti.field(dtype=type, shape=shape)\n"
"\n"
"@ti.kernel\n"
"def draw():\n"
"    for i, j in pixels:\n"
"        pixels[i, j] = ti.random() * 255    # integars between [0, 255] "
"for ti.u8\n"
"\n"
"draw()\n"
"\n"
"ti.imwrite(pixels, f\"export_u8.png\")"
msgstr ""

#: ../../taichi/docs/gui.rst:474
msgid ""
"Besides, for RGB or RGBA images, ``ti.imwrite`` needs to receive a field "
"which has shape ``(height, width, 3)`` and ``(height, width, 4)`` "
"individually."
msgstr ""

#: ../../taichi/docs/gui.rst:476
msgid ""
"Generally the value of the pixels on each channel of a ``png`` image is "
"an integar in [0, 255]. For this reason, ``ti.imwrite`` will **cast "
"fields** which has different datatypes all **into integars between [0, "
"255]**. As a result, ``ti.imwrite`` has the following requirements for "
"different datatypes of input fields:"
msgstr ""

#: ../../taichi/docs/gui.rst:478
msgid ""
"For float-type (``ti.f16``, ``ti.f32``, etc) input fields, **the value of"
" each pixel should be float between [0.0, 1.0]**. Otherwise "
"``ti.imwrite`` will first clip them into [0.0, 1.0]. Then they are "
"multiplied by 256 and casted to integaters ranging from [0, 255]."
msgstr ""

#: ../../taichi/docs/gui.rst:480
msgid ""
"For int-type (``ti.u8``, ``ti.u16``, etc) input fields, **the value of "
"each pixel can be any valid integer in its own bounds**. These integers "
"in this field will be scaled to [0, 255] by being divided over the upper "
"bound of its basic type accordingly."
msgstr ""

#: ../../taichi/docs/gui.rst:482
msgid "Here is another example:"
msgstr ""

#: ../../taichi/docs/gui.rst:484
msgid ""
"import taichi as ti\n"
"\n"
"ti.init()\n"
"\n"
"shape = (512, 512)\n"
"channels = 3\n"
"type = ti.f32\n"
"pixels = ti.Matrix.field(channels, dtype=type, shape=shape)\n"
"\n"
"@ti.kernel\n"
"def draw():\n"
"    for i, j in pixels:\n"
"        for k in ti.static(range(channels)):\n"
"            pixels[i, j][k] = ti.random()   # floats between [0, 1] for "
"ti.f32\n"
"\n"
"draw()\n"
"\n"
"ti.imwrite(pixels, f\"export_f32.png\")"
msgstr ""

#: ../../taichi/docs/gui.rst:508
msgid "(string) the filename of the image to load"
msgstr ""

#: ../../taichi/docs/gui.rst:509
msgid ""
"(optional int) the number of channels in your specified image. The "
"default value ``0`` means the channels of the returned image is adaptive "
"to the image file"
msgstr ""

#: ../../taichi/docs/gui.rst:511
msgid "(np.ndarray) the image read from ``filename``"
msgstr ""

#: ../../taichi/docs/gui.rst:513
msgid ""
"This function loads an image from the target filename and returns it as a"
" ``np.ndarray(dtype=np.uint8)``."
msgstr ""

#: ../../taichi/docs/gui.rst:515
msgid "Each value in this returned field is an integer in [0, 255]."
msgstr ""

#: ../../taichi/docs/gui.rst:519
msgid "(ti.Vector.field or ti.field) the image to show in the GUI"
msgstr ""

#: ../../taichi/docs/gui.rst:520
msgid "(string) the name of the GUI window"
msgstr ""

#: ../../taichi/docs/gui.rst:522
msgid ""
"This function will create an instance of ``ti.GUI`` and show the input "
"image on the screen."
msgstr ""

#: ../../taichi/docs/gui.rst:524
msgid "It has the same logic as ``ti.imwrite`` for different datatypes."
msgstr ""

#: ../../taichi/docs/hello.rst:2
msgid "Hello, world!"
msgstr ""

#: ../../taichi/docs/hello.rst:4
msgid ""
"We introduce the Taichi programming language through a very basic "
"`fractal` example."
msgstr ""

#: ../../taichi/docs/hello.rst:6
msgid ""
"Running the Taichi code below (``python3 fractal.py`` or ``ti example "
"fractal``) will give you an animation of `Julia set "
"<https://en.wikipedia.org/wiki/Julia_set>`_:"
msgstr ""

#: ../../taichi/docs/hello.rst:11
msgid ""
"# fractal.py\n"
"\n"
"import taichi as ti\n"
"\n"
"ti.init(arch=ti.gpu)\n"
"\n"
"n = 320\n"
"pixels = ti.field(dtype=float, shape=(n * 2, n))\n"
"\n"
"\n"
"@ti.func\n"
"def complex_sqr(z):\n"
"    return ti.Vector([z[0]**2 - z[1]**2, z[1] * z[0] * 2])\n"
"\n"
"\n"
"@ti.kernel\n"
"def paint(t: float):\n"
"    for i, j in pixels:  # Parallized over all pixels\n"
"        c = ti.Vector([-0.8, ti.cos(t) * 0.2])\n"
"        z = ti.Vector([i / n - 1, j / n - 0.5]) * 2\n"
"        iterations = 0\n"
"        while z.norm() < 20 and iterations < 50:\n"
"            z = complex_sqr(z) + c\n"
"            iterations += 1\n"
"        pixels[i, j] = 1 - iterations * 0.02\n"
"\n"
"\n"
"gui = ti.GUI(\"Julia Set\", res=(n * 2, n))\n"
"\n"
"for i in range(1000000):\n"
"    paint(i * 0.03)\n"
"    gui.set_image(pixels)\n"
"    gui.show()"
msgstr ""

#: ../../taichi/docs/hello.rst:47
msgid "Let's dive into this simple Taichi program."
msgstr ""

#: ../../taichi/docs/hello.rst:50
msgid "import taichi as ti"
msgstr ""

#: ../../taichi/docs/hello.rst:51
msgid ""
"Taichi is a domain-specific language (DSL) embedded in Python. To make "
"Taichi as easy to use as a Python package, we have done heavy engineering"
" with this goal in mind - letting every Python programmer write Taichi "
"programs with minimal learning effort. You can even use your favorite "
"Python package management system, Python IDEs and other Python packages "
"in conjunction with Taichi."
msgstr ""

#: ../../taichi/docs/hello.rst:57 ../../taichi/docs/overview.rst:8
msgid "Portability"
msgstr ""

#: ../../taichi/docs/hello.rst:59
msgid ""
"Taichi programs run on either CPUs or GPUs. Initialize Taichi according "
"to your hardware platform as follows:"
msgstr ""

#: ../../taichi/docs/hello.rst:61
msgid ""
"# Run on GPU, automatically detect backend\n"
"ti.init(arch=ti.gpu)\n"
"\n"
"# Run on GPU, with the NVIDIA CUDA backend\n"
"ti.init(arch=ti.cuda)\n"
"# Run on GPU, with the OpenGL backend\n"
"ti.init(arch=ti.opengl)\n"
"# Run on GPU, with the Apple Metal backend, if you are on OS X\n"
"ti.init(arch=ti.metal)\n"
"\n"
"# Run on CPU (default)\n"
"ti.init(arch=ti.cpu)"
msgstr ""

#: ../../taichi/docs/hello.rst:78
msgid "Supported backends on different platforms:"
msgstr ""

#: ../../taichi/docs/hello.rst:81
msgid "platform"
msgstr ""

#: ../../taichi/docs/hello.rst:81
msgid "CPU"
msgstr ""

#: ../../taichi/docs/hello.rst:81
msgid "CUDA"
msgstr ""

#: ../../taichi/docs/hello.rst:83 ../../taichi/docs/legacy_installation.rst:34
msgid "Windows"
msgstr ""

#: ../../taichi/docs/hello.rst:85
msgid "Linux"
msgstr ""

#: ../../taichi/docs/hello.rst:87
msgid "Mac OS X"
msgstr ""

#: ../../taichi/docs/hello.rst:90
msgid "(OK: supported; N/A: not available)"
msgstr ""

#: ../../taichi/docs/hello.rst:92
msgid ""
"With ``arch=ti.gpu``, Taichi will first try to run with CUDA. If CUDA is "
"not supported on your machine, Taichi will fall back on Metal or OpenGL. "
"If no GPU backend (CUDA, Metal, or OpenGL) is supported, Taichi will fall"
" back on CPUs."
msgstr ""

#: ../../taichi/docs/hello.rst:98
msgid ""
"When used with the CUDA backend on Windows or ARM devices (e.g. NVIDIA "
"Jetson), Taichi by default allocates 1 GB GPU memory for field storage. "
"You can override this behavior by initializing with "
"``ti.init(arch=ti.cuda, device_memory_GB=3.4)`` to allocate ``3.4`` GB "
"GPU memory, or ``ti.init(arch=ti.cuda, device_memory_fraction=0.3)`` to "
"allocate ``30%`` of the total GPU memory."
msgstr ""

#: ../../taichi/docs/hello.rst:103
msgid ""
"On other platforms, Taichi will make use of its on-demand memory "
"allocator to adaptively allocate memory."
msgstr ""

#: ../../taichi/docs/hello.rst:106
msgid "Fields"
msgstr ""

#: ../../taichi/docs/hello.rst:108
msgid ""
"Taichi is a data-oriented programming language where dense or spatially-"
"sparse fields are the first-class citizens. See :ref:`scalar_tensor` for "
"more details on fields."
msgstr ""

#: ../../taichi/docs/hello.rst:111
msgid ""
"In the code above, ``pixels = ti.field(dtype=float, shape=(n * 2, n))`` "
"allocates a 2D dense field named ``pixels`` of size ``(640, 320)`` and "
"element data type ``float``."
msgstr ""

#: ../../taichi/docs/hello.rst:114
msgid "Functions and kernels"
msgstr ""

#: ../../taichi/docs/hello.rst:116
msgid "Computation resides in Taichi **kernels** and Taichi **functions**."
msgstr ""

#: ../../taichi/docs/hello.rst:118
msgid ""
"Taichi **kernels** are defined with the decorator ``@ti.kernel``. They "
"can be called from Python to perform computation. Kernel arguments must "
"be type-hinted (if any)."
msgstr ""

#: ../../taichi/docs/hello.rst:122
msgid ""
"Taichi **functions** are defined with the decorator ``@ti.func``. They "
"can be called by Taichi kernels or other Taichi functions."
msgstr ""

#: ../../taichi/docs/hello.rst:125
msgid "See :ref:`syntax` for more details about Taichi kernels and functions."
msgstr ""

#: ../../taichi/docs/hello.rst:127
msgid ""
"The language used in Taichi kernels and functions looks exactly like "
"Python, yet the Taichi frontend compiler converts it into a language that"
" is **compiled, statically-typed, lexically-scoped, parallel and "
"differentiable**."
msgstr ""

#: ../../taichi/docs/hello.rst:131
msgid "**Taichi-scopes v.s. Python-scopes**:"
msgstr ""

#: ../../taichi/docs/hello.rst:133
msgid ""
"Everything decorated with ``@ti.kernel`` and ``@ti.func`` is in Taichi-"
"scope and hence will be compiled by the Taichi compiler."
msgstr ""

#: ../../taichi/docs/hello.rst:136
msgid "Everything else is in Python-scope. They are simply Python native code."
msgstr ""

#: ../../taichi/docs/hello.rst:140
msgid ""
"Taichi kernels must be called from the Python-scope. Taichi functions "
"must be called from the Taichi-scope."
msgstr ""

#: ../../taichi/docs/hello.rst:145
msgid ""
"For those who come from the world of CUDA, ``ti.func`` corresponds to "
"``__device__`` while ``ti.kernel`` corresponds to ``__global__``."
msgstr ""

#: ../../taichi/docs/hello.rst:149
msgid "Nested kernels are **not supported**."
msgstr ""

#: ../../taichi/docs/hello.rst:151
msgid "Nested functions are **supported**."
msgstr ""

#: ../../taichi/docs/hello.rst:153
msgid "Recursive functions are **not supported for now**."
msgstr ""

#: ../../taichi/docs/hello.rst:157
msgid "Parallel for-loops"
msgstr ""

#: ../../taichi/docs/hello.rst:158
msgid ""
"For loops at the outermost scope in a Taichi kernel is **automatically "
"parallelized**. For loops can have two forms, i.e. `range-for loops` and "
"`struct-for loops`."
msgstr ""

#: ../../taichi/docs/hello.rst:161
msgid ""
"**Range-for loops** are no different from Python for loops, except that "
"it will be parallelized when used at the outermost scope. Range-for loops"
" can be nested."
msgstr ""

#: ../../taichi/docs/hello.rst:164
msgid ""
"@ti.kernel\n"
"def fill():\n"
"    for i in range(10): # Parallelized\n"
"        x[i] += i\n"
"\n"
"        s = 0\n"
"        for j in range(5): # Serialized in each parallel thread\n"
"            s += j\n"
"\n"
"        y[i] = s\n"
"\n"
"@ti.kernel\n"
"def fill_3d():\n"
"    # Parallelized for all 3 <= i < 8, 1 <= j < 6, 0 <= k < 9\n"
"    for i, j, k in ti.ndrange((3, 8), (1, 6), 9):\n"
"        x[i, j, k] = i + j + k"
msgstr ""

#: ../../taichi/docs/hello.rst:185 ../../taichi/docs/hello.rst:211
msgid ""
"It is the loop **at the outermost scope** that gets parallelized, not the"
" outermost loop."
msgstr ""

#: ../../taichi/docs/hello.rst:187
msgid ""
"@ti.kernel\n"
"def foo():\n"
"    for i in range(10): # Parallelized :-)\n"
"        ...\n"
"\n"
"@ti.kernel\n"
"def bar(k: ti.i32):\n"
"    if k > 42:\n"
"        for i in range(10): # Serial :-(\n"
"            ..."
msgstr ""

#: ../../taichi/docs/hello.rst:200
msgid ""
"**Struct-for loops** are particularly useful when iterating over (sparse)"
" field elements. In the code above, ``for i, j in pixels`` loops over all"
" the pixel coordinates, i.e. ``(0, 0), (0, 1), (0, 2), ... , (0, 319), "
"(1, 0), ..., (639, 319)``."
msgstr ""

#: ../../taichi/docs/hello.rst:205
msgid ""
"Struct-for is the key to :ref:`sparse` in Taichi, as it will only loop "
"over active elements in a sparse field. In dense fields, all elements are"
" active."
msgstr ""

#: ../../taichi/docs/hello.rst:209
msgid "Struct-for loops must live at the outer-most scope of kernels."
msgstr ""

#: ../../taichi/docs/hello.rst:213
msgid ""
"@ti.kernel\n"
"def foo():\n"
"    for i in x:\n"
"        ...\n"
"\n"
"@ti.kernel\n"
"def bar(k: ti.i32):\n"
"    # The outermost scope is a `if` statement\n"
"    if k > 42:\n"
"        for i in x: # Not allowed. Struct-fors must live in the outermost"
" scope.\n"
"            ..."
msgstr ""

#: ../../taichi/docs/hello.rst:232
msgid "``break`` **is not supported in parallel loops**:"
msgstr ""

#: ../../taichi/docs/hello.rst:234
msgid ""
"@ti.kernel\n"
"def foo():\n"
"  for i in x:\n"
"      ...\n"
"      break # Error!\n"
"\n"
"  for i in range(10):\n"
"      ...\n"
"      break # Error!\n"
"\n"
"@ti.kernel\n"
"def foo():\n"
"  for i in x:\n"
"      for j in range(10):\n"
"          ...\n"
"          break # OK!"
msgstr ""

#: ../../taichi/docs/hello.rst:257
msgid "Interacting with other Python packages"
msgstr ""

#: ../../taichi/docs/hello.rst:260
msgid "Python-scope data access"
msgstr ""

#: ../../taichi/docs/hello.rst:262
msgid ""
"Everything outside Taichi-scopes (``ti.func`` and ``ti.kernel``) is "
"simply Python code. In Python-scopes, you can access Taichi field "
"elements using plain indexing syntax. For example, to access a single "
"pixel of the rendered image in Python-scope, simply use:"
msgstr ""

#: ../../taichi/docs/hello.rst:266
msgid ""
"import taichi as ti\n"
"pixels = ti.field(ti.f32, (1024, 512))\n"
"\n"
"pixels[42, 11] = 0.7  # store data into pixels\n"
"print(pixels[42, 11]) # prints 0.7"
msgstr ""

#: ../../taichi/docs/hello.rst:276
msgid "Sharing data with other packages"
msgstr ""

#: ../../taichi/docs/hello.rst:278
msgid ""
"Taichi provides helper functions such as ``from_numpy`` and ``to_numpy`` "
"for transfer data between Taichi fields and NumPy arrays, So that you can"
" also use your favorite Python packages (e.g. ``numpy``, ``pytorch``, "
"``matplotlib``) together with Taichi. e.g.:"
msgstr ""

#: ../../taichi/docs/hello.rst:281
msgid ""
"import taichi as ti\n"
"pixels = ti.field(ti.f32, (1024, 512))\n"
"\n"
"import numpy as np\n"
"arr = np.random.rand(1024, 512)\n"
"pixels.from_numpy(arr)   # load numpy data into taichi fields\n"
"\n"
"import matplotlib.pyplot as plt\n"
"arr = pixels.to_numpy()  # store taichi data into numpy arrays\n"
"plt.imshow(arr)\n"
"plt.show()\n"
"\n"
"import matplotlib.cm as cm\n"
"cmap = cm.get_cmap('magma')\n"
"gui = ti.GUI('Color map')\n"
"while gui.running:\n"
"    render_pixels()\n"
"    arr = pixels.to_numpy()\n"
"    gui.set_image(cmap(arr))\n"
"    gui.show()"
msgstr ""

#: ../../taichi/docs/hello.rst:304
msgid "See :ref:`external` for more details."
msgstr ""

#: ../../taichi/docs/index.rst:4
msgid "Overview"
msgstr ""

#: ../../taichi/docs/index.rst:13
msgid "Basic Concepts"
msgstr ""

#: ../../taichi/docs/index.rst:24
msgid "API References"
msgstr ""

#: ../../taichi/docs/index.rst:34
msgid "Advanced Programming"
msgstr ""

#: ../../taichi/docs/index.rst:48
msgid "Contributing"
msgstr ""

#: ../../taichi/docs/index.rst:63
msgid "Miscellaneous"
msgstr ""

#: ../../taichi/docs/index.rst:77
msgid "Legacy"
msgstr ""

#: ../../taichi/docs/index.rst:2
msgid "The Taichi Programming Language"
msgstr ""

#: ../../taichi/docs/install.rst:2
msgid "Installation"
msgstr ""

#: ../../taichi/docs/install.rst:4
msgid "Taichi can be easily installed via ``pip``:"
msgstr ""

#: ../../taichi/docs/install.rst:6
msgid "python3 -m pip install taichi"
msgstr ""

#: ../../taichi/docs/install.rst:12
msgid "Currently, Taichi only supports Python 3.6/3.7/3.8 (64-bit)."
msgstr ""

#: ../../taichi/docs/install.rst:15
msgid "On Ubuntu 19.04+, please execute ``sudo apt install libtinfo5``."
msgstr ""

#: ../../taichi/docs/install.rst:16
msgid "On Arch Linux, please execute ``yaourt -S ncurses5-compat-libs``."
msgstr ""

#: ../../taichi/docs/install.rst:17
msgid ""
"On Windows, please install `Microsoft Visual C++ Redistributable "
"<https://aka.ms/vs/16/release/vc_redist.x64.exe>`_ if you haven't."
msgstr ""

#: ../../taichi/docs/install.rst:23
msgid "Troubleshooting"
msgstr ""

#: ../../taichi/docs/install.rst:26
msgid "Windows issues"
msgstr ""

#: ../../taichi/docs/install.rst:28
msgid ""
"If Taichi crashes and reports ``ImportError`` on Windows: Please consider"
" installing `Microsoft Visual C++ Redistributable "
"<https://aka.ms/vs/16/release/vc_redist.x64.exe>`_."
msgstr ""

#: ../../taichi/docs/install.rst:31
msgid "Python issues"
msgstr ""

#: ../../taichi/docs/install.rst:33
msgid "If ``pip`` complains that it could not find a satisfying package, i.e.,"
msgstr ""

#: ../../taichi/docs/install.rst:35
msgid ""
"ERROR: Could not find a version that satisfies the requirement taichi "
"(from versions: none)\n"
"ERROR: No matching distribution found for taichi"
msgstr ""

#: ../../taichi/docs/install.rst:40
msgid "Make sure you're using Python version 3.6/3.7/3.8:"
msgstr ""

#: ../../taichi/docs/install.rst:42
msgid ""
"python3 -c \"print(__import__('sys').version[:3])\"\n"
"# 3.6, 3.7 or 3.8"
msgstr ""

#: ../../taichi/docs/install.rst:47
msgid "Make sure your Python executable is 64-bit:"
msgstr ""

#: ../../taichi/docs/install.rst:49
msgid ""
"python3 -c \"print(__import__('platform').architecture()[0])\"\n"
"# 64bit"
msgstr ""

#: ../../taichi/docs/install.rst:55
msgid "CUDA issues"
msgstr ""

#: ../../taichi/docs/install.rst:57
msgid "If Taichi crashes with the following messages:"
msgstr ""

#: ../../taichi/docs/install.rst:59
msgid ""
"[Taichi] mode=release\n"
"[Taichi] version 0.6.0, supported archs: [cpu, cuda, opengl], commit "
"14094f25, python 3.8.2\n"
"[W 05/14/20 10:46:49.549] [cuda_driver.h:call_with_warning@60] CUDA Error"
" CUDA_ERROR_INVALID_DEVICE: invalid device ordinal while calling "
"mem_advise (cuMemAdvise)\n"
"[E 05/14/20 10:46:49.911] Received signal 7 (Bus error)"
msgstr ""

#: ../../taichi/docs/install.rst:67
msgid ""
"This might be due to the fact that your NVIDIA GPU is pre-Pascal and has "
"limited support for `Unified Memory "
"<https://www.nextplatform.com/2019/01/24/unified-memory-the-final-piece-"
"of-the-gpu-programming-puzzle/>`_."
msgstr ""

#: ../../taichi/docs/install.rst:69
msgid ""
"**Possible solution**: add ``export TI_USE_UNIFIED_MEMORY=0`` to your "
"``~/.bashrc``. This disables unified memory usage in CUDA backend."
msgstr ""

#: ../../taichi/docs/install.rst:72
msgid "If you find other CUDA problems:"
msgstr ""

#: ../../taichi/docs/install.rst:74
msgid ""
"**Possible solution**: add ``export TI_ENABLE_CUDA=0`` to your  "
"``~/.bashrc``. This disables the CUDA backend completely and Taichi will "
"fall back on other GPU backends such as OpenGL."
msgstr ""

#: ../../taichi/docs/install.rst:77
msgid "OpenGL issues"
msgstr ""

#: ../../taichi/docs/install.rst:79
msgid ""
"If Taichi crashes with a stack backtrace containing a line of "
"``glfwCreateWindow`` (see `#958 <https://github.com/taichi-"
"dev/taichi/issues/958>`_):"
msgstr ""

#: ../../taichi/docs/install.rst:81
msgid ""
"[Taichi] mode=release\n"
"[E 05/12/20 18.25:00.129] Received signal 11 (Segmentation Fault)\n"
"***********************************\n"
"* Taichi Compiler Stack Traceback *\n"
"***********************************\n"
"\n"
"... (many lines, omitted)\n"
"\n"
"/lib/python3.8/site-packages/taichi/core/../lib/taichi_core.so: "
"_glfwPlatformCreateWindow\n"
"/lib/python3.8/site-packages/taichi/core/../lib/taichi_core.so: "
"glfwCreateWindow\n"
"/lib/python3.8/site-packages/taichi/core/../lib/taichi_core.so: "
"taichi::lang::opengl::initialize_opengl(bool)\n"
"\n"
"... (many lines, omitted)"
msgstr ""

#: ../../taichi/docs/install.rst:97
msgid ""
"This is likely because you are running Taichi on a (virtual) machine with"
" an old OpenGL API. Taichi requires OpenGL 4.3+ to work."
msgstr ""

#: ../../taichi/docs/install.rst:99
msgid ""
"**Possible solution**: add ``export TI_ENABLE_OPENGL=0`` to your  "
"``~/.bashrc`` even if you initialize Taichi with other backends than "
"OpenGL. This disables the OpenGL backend detection to avoid "
"incompatibilities."
msgstr ""

#: ../../taichi/docs/install.rst:103
msgid "Linux issues"
msgstr ""

#: ../../taichi/docs/install.rst:105
msgid "If Taichi crashes and reports ``libtinfo.so.5 not found``:"
msgstr ""

#: ../../taichi/docs/install.rst:107
msgid "On Ubuntu, execute ``sudo apt install libtinfo-dev``."
msgstr ""

#: ../../taichi/docs/install.rst:109
msgid "On Arch Linux, first edit ``/etc/pacman.conf``, and append these lines:"
msgstr ""

#: ../../taichi/docs/install.rst:111
msgid ""
"[archlinuxcn]\n"
"Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch"
msgstr ""

#: ../../taichi/docs/install.rst:116
msgid "Then execute ``sudo pacman -Syy ncurses5-compat-libs``."
msgstr ""

#: ../../taichi/docs/install.rst:118
msgid ""
"If Taichi crashes and reports ``/usr/lib/libstdc++.so.6: version "
"`CXXABI_1.3.11' not found``:"
msgstr ""

#: ../../taichi/docs/install.rst:120
msgid ""
"You might be using Ubuntu 16.04, please try the solution in `this thread "
"<https://github.com/tensorflow/serving/issues/819#issuecomment-377776784>`_:"
msgstr ""

#: ../../taichi/docs/install.rst:122
msgid ""
"sudo add-apt-repository ppa:ubuntu-toolchain-r/test -y\n"
"sudo apt-get update\n"
"sudo apt-get install libstdc++6"
msgstr ""

#: ../../taichi/docs/install.rst:130
msgid "Other issues"
msgstr ""

#: ../../taichi/docs/install.rst:132
msgid ""
"If none of those above address your problem, please report this by "
"`opening an issue <https://github.com/taichi-"
"dev/taichi/issues/new?labels=potential+bug&template=bug_report.md>`_ on "
"GitHub. This would help us improve user experiences and compatibility, "
"many thanks!"
msgstr ""

#: ../../taichi/docs/internal.rst:2
msgid "Internal designs (WIP)"
msgstr ""

#: ../../taichi/docs/internal.rst:5
msgid "Intermediate representation"
msgstr ""

#: ../../taichi/docs/internal.rst:6
msgid "Use ``ti.init(print_ir=True)`` to print IR on the console."
msgstr ""

#: ../../taichi/docs/internal.rst:10
msgid "List generation (WIP)"
msgstr ""

#: ../../taichi/docs/internal.rst:12
msgid ""
"Struct-fors in Taichi loop over all active elements of a (sparse) data "
"structure **in parallel**. Evenly distributing work onto processor cores "
"is challenging on sparse data structures: naively splitting an irregular "
"tree into pieces can easily lead to partitions with drastically different"
" numbers of leaf elements."
msgstr ""

#: ../../taichi/docs/internal.rst:17
msgid ""
"Our strategy is to generate lists of active SNode elements layer by "
"layer. The list generation computation happens on the same device as "
"normal computation kernels, depending on the ``arch`` argument when the "
"user calls ``ti.init``."
msgstr ""

#: ../../taichi/docs/internal.rst:21
msgid ""
"List generations flatten the data structure leaf elements into a 1D dense"
" array, circumventing the irregularity of incomplete trees. Then we can "
"simply invoke a regular **parallel for** over the list."
msgstr ""

#: ../../taichi/docs/internal.rst:24 ../../taichi/docs/internal.rst:144
#: ../../taichi/docs/snode.rst:43
msgid "For example,"
msgstr ""

#: ../../taichi/docs/internal.rst:26
msgid ""
"# misc/listgen_demo.py\n"
"\n"
"import taichi as ti\n"
"\n"
"ti.init(print_ir=True)\n"
"\n"
"x = ti.field(ti.i32)\n"
"ti.root.dense(ti.i, 4).bitmasked(ti.i, 4).place(x)\n"
"\n"
"@ti.kernel\n"
"def func():\n"
"    for i in x:\n"
"        print(i)\n"
"\n"
"func()"
msgstr ""

#: ../../taichi/docs/internal.rst:45
msgid "gives you the following IR:"
msgstr ""

#: ../../taichi/docs/internal.rst:47
msgid ""
"$0 = offloaded clear_list S1dense\n"
"$1 = offloaded listgen S0root->S1dense\n"
"$2 = offloaded clear_list S2bitmasked\n"
"$3 = offloaded listgen S1dense->S2bitmasked\n"
"$4 = offloaded struct_for(S2bitmasked) block_dim=0 {\n"
"  <i32 x1> $5 = loop index 0\n"
"  print i, $5\n"
"}"
msgstr ""

#: ../../taichi/docs/internal.rst:59
msgid "Note that ``func`` leads to two list generations:"
msgstr ""

#: ../../taichi/docs/internal.rst:61
msgid ""
"(Tasks ``$0`` and ``$1``) based on the list of ``root`` node (``S0``), "
"generate the list of the ``dense`` nodes (``S1``);"
msgstr ""

#: ../../taichi/docs/internal.rst:62
msgid ""
"(Tasks ``$2`` and ``$3``) based on the list of ``dense`` nodes (``S1``), "
"generate the list of ``bitmasked`` nodes (``S2``)."
msgstr ""

#: ../../taichi/docs/internal.rst:64
msgid ""
"The list of ``root`` node always has exactly one element (instance), so "
"we never clear or re-generate this list."
msgstr ""

#: ../../taichi/docs/internal.rst:68
msgid ""
"The list of ``place`` (leaf) nodes (e.g., ``S3`` in this example) is "
"never generated. Instead, we simply loop over the list of their parent "
"nodes, and for each parent node we enumerate the ``place`` nodes on-the-"
"fly (without actually generating a list)."
msgstr ""

#: ../../taichi/docs/internal.rst:72
msgid ""
"The motivation for this design is to amortize list generation overhead. "
"Generating one list element per leaf node (``place`` SNode) element is "
"too expensive, likely much more expensive than the essential computation "
"happening on the leaf element. Therefore we only generate their parent "
"element list, so that the list generation cost is amortized over multiple"
" child elements of a second-to-last-level SNode element."
msgstr ""

#: ../../taichi/docs/internal.rst:78
msgid ""
"In the example above, although we have ``16`` instances of ``x``, we only"
" generate a list of ``4`` ``bitmasked`` nodes (and ``1`` ``dense`` node)."
msgstr ""

#: ../../taichi/docs/internal.rst:83
msgid "Code generation"
msgstr ""

#: ../../taichi/docs/internal.rst:87
msgid "Statistics"
msgstr ""

#: ../../taichi/docs/internal.rst:89
msgid ""
"In some cases, it is helpful to gather certain quantitative information "
"about internal events during Taichi program execution. The ``Statistics``"
" class is designed for this purpose."
msgstr ""

#: ../../taichi/docs/internal.rst:92
msgid "Usage:"
msgstr ""

#: ../../taichi/docs/internal.rst:94
msgid ""
"#include \"taichi/util/statistics.h\"\n"
"\n"
"// add 1.0 to counter \"codegen_offloaded_tasks\"\n"
"taichi::stat.add(\"codegen_offloaded_tasks\");\n"
"\n"
"// add the number of statements in \"ir\" to counter "
"\"codegen_statements\"\n"
"taichi::stat.add(\"codegen_statements\", "
"irpass::analysis::count_statements(this->ir));"
msgstr ""

#: ../../taichi/docs/internal.rst:105
msgid "Note the keys are ``std::string`` and values are ``double``."
msgstr ""

#: ../../taichi/docs/internal.rst:107
msgid "To print out all statistics in Python:"
msgstr ""

#: ../../taichi/docs/internal.rst:109
msgid "ti.core.print_stat()"
msgstr ""

#: ../../taichi/docs/internal.rst:115
msgid "Why Python frontend"
msgstr ""

#: ../../taichi/docs/internal.rst:117
msgid "Embedding Taichi in ``python`` has the following advantages:"
msgstr ""

#: ../../taichi/docs/internal.rst:119
msgid "Easy to learn. Taichi has a very similar syntax to Python."
msgstr ""

#: ../../taichi/docs/internal.rst:120
msgid "Easy to run. No ahead-of-time compilation is needed."
msgstr ""

#: ../../taichi/docs/internal.rst:121
msgid "This design allows people to reuse existing python infrastructure:"
msgstr ""

#: ../../taichi/docs/internal.rst:123
msgid ""
"IDEs. A python IDE mostly works for Taichi with syntax highlighting, "
"syntax checking, and autocomplete."
msgstr ""

#: ../../taichi/docs/internal.rst:124
msgid ""
"Package manager (pip). A developed Taichi application and be easily "
"submitted to ``PyPI`` and others can easily set it up with ``pip``."
msgstr ""

#: ../../taichi/docs/internal.rst:125
msgid ""
"Existing packages. Interacting with other python components (e.g. "
"``matplotlib`` and ``numpy``) is just trivial."
msgstr ""

#: ../../taichi/docs/internal.rst:127
msgid ""
"The built-in AST manipulation tools in ``python`` allow us to do magical "
"things, as long as the kernel body can be parsed by the Python parser."
msgstr ""

#: ../../taichi/docs/internal.rst:129
msgid "However, this design has drawbacks as well:"
msgstr ""

#: ../../taichi/docs/internal.rst:131
msgid ""
"Taichi kernels must parse-able by Python parsers. This means Taichi "
"syntax cannot go beyond Python syntax."
msgstr ""

#: ../../taichi/docs/internal.rst:133
msgid ""
"For example, indexing is always needed when accessing elements in Taichi "
"fields, even if the fields is 0D. Use ``x[None] = 123`` to set the value "
"in ``x`` if ``x`` is 0D. This is because ``x = 123`` will set ``x`` "
"itself (instead of its containing value) to be the constant ``123`` in "
"python syntax, and, unfortunately, we cannot modify this behavior."
msgstr ""

#: ../../taichi/docs/internal.rst:135
msgid ""
"Python has relatively low performance. This can cause a performance issue"
" when initializing large Taichi fields with pure python scripts. A Taichi"
" kernel should be used to initialize a huge fields."
msgstr ""

#: ../../taichi/docs/internal.rst:139
msgid "Virtual indices v.s. physical indices"
msgstr ""

#: ../../taichi/docs/internal.rst:141
msgid ""
"In Taichi, *virtual indices* are used to locate elements in fields, and "
"*physical indices* are used to specify data layouts in memory."
msgstr ""

#: ../../taichi/docs/internal.rst:146
msgid "In ``a[i, j, k]``, ``i``, ``j``, and ``k`` are **virtual** indices."
msgstr ""

#: ../../taichi/docs/internal.rst:147
msgid "In ``for i, j in x:``, ``i`` and ``j`` are **virtual** indices."
msgstr ""

#: ../../taichi/docs/internal.rst:148
msgid "``ti.i, ti.j, ti.k, ti.l, ...`` are **physical** indices."
msgstr ""

#: ../../taichi/docs/internal.rst:149
msgid ""
"In struct-for statements, ``LoopIndexStmt::index`` is a **physical** "
"index."
msgstr ""

#: ../../taichi/docs/internal.rst:151
msgid ""
"The mapping between virtual indices and physical indices for each "
"``SNode`` is stored in ``SNode::physical_index_position``. I.e.,  "
"``physical_index_position[i]`` answers the question: **which physical "
"index does the i-th virtual index** correspond to?"
msgstr ""

#: ../../taichi/docs/internal.rst:156
msgid ""
"Each ``SNode`` can have a different virtual-to-physical mapping. "
"``physical_index_position[i] == -1`` means the ``i``-th virtual index "
"does not corrspond to any physical index in this ``SNode``."
msgstr ""

#: ../../taichi/docs/internal.rst:159
msgid ""
"``SNode`` s in handy dense fields (i.e., ``a = ti.field(ti.i32, "
"shape=(128, 256, 512))``) have **trivial** virtual-to-physical mapping, "
"e.g. ``physical_index_position[i] = i``."
msgstr ""

#: ../../taichi/docs/internal.rst:162
msgid ""
"However, more complex data layouts, such as column-major 2D fields can "
"lead to ``SNodes`` with ``physical_index_position[0] = 1`` and "
"``physical_index_position[1] = 0``."
msgstr ""

#: ../../taichi/docs/internal.rst:165
msgid ""
"a = ti.field(ti.f32, shape=(128, 32, 8))\n"
"\n"
"b = ti.field(ti.f32)\n"
"ti.root.dense(ti.j, 32).dense(ti.i, 16).place(b)\n"
"\n"
"ti.get_runtime().materialize()\n"
"\n"
"mapping_a = a.snode().physical_index_position()\n"
"\n"
"assert mapping_a == {0: 0, 1: 1, 2: 2}\n"
"\n"
"mapping_b = b.snode().physical_index_position()\n"
"\n"
"assert mapping_b == {0: 1, 1: 0}\n"
"# Note that b is column-major:\n"
"# the virtual first index exposed to the user comes second in memory "
"layout."
msgstr ""

#: ../../taichi/docs/internal.rst:184
msgid ""
"Taichi supports up to 8 (``constexpr int taichi_max_num_indices = 8``) "
"virtual indices and physical indices."
msgstr ""

#: ../../taichi/docs/layout.rst:4
msgid "Advanced dense layouts"
msgstr ""

#: ../../taichi/docs/layout.rst:6
msgid ""
"Fields (:ref:`scalar_tensor`) can be *placed* in a specific shape and "
"*layout*. Defining a proper layout can be critical to performance, "
"especially for memory-bound applications. A carefully designed data "
"layout can significantly improve cache/TLB-hit rates and cacheline "
"utilization. Although when performance is not the first priority, you "
"probably don't have to worry about it."
msgstr ""

#: ../../taichi/docs/layout.rst:9
msgid ""
"Taichi decouples algorithms from data layouts, and the Taichi compiler "
"automatically optimizes data accesses on a specific data layout. These "
"Taichi features allow programmers to quickly experiment with different "
"data layouts and figure out the most efficient one on a specific task and"
" computer architecture."
msgstr ""

#: ../../taichi/docs/layout.rst:11
msgid ""
"In Taichi, the layout is defined in a recursive manner. See :ref:`snode` "
"for more details about how this works. We suggest starting with the "
"default layout specification (simply by specifying ``shape`` when "
"creating fields using ``ti.field/ti.Vector.field/ti.Matrix.field``), and "
"then migrate to more advanced layouts using the ``ti.root.X`` syntax if "
"necessary."
msgstr ""

#: ../../taichi/docs/layout.rst:15
msgid "From ``shape`` to ``ti.root.X``"
msgstr ""

#: ../../taichi/docs/layout.rst:17
msgid "For example, this declares a 0-D field:"
msgstr ""

#: ../../taichi/docs/layout.rst:19
msgid ""
"x = ti.field(ti.f32)\n"
"ti.root.place(x)\n"
"# is equivalent to:\n"
"x = ti.field(ti.f32, shape=())"
msgstr ""

#: ../../taichi/docs/layout.rst:26
msgid "This declares a 1D field of size ``3``:"
msgstr ""

#: ../../taichi/docs/layout.rst:28
msgid ""
"x = ti.field(ti.f32)\n"
"ti.root.dense(ti.i, 3).place(x)\n"
"# is equivalent to:\n"
"x = ti.field(ti.f32, shape=3)"
msgstr ""

#: ../../taichi/docs/layout.rst:35
msgid "This declares a 2D field of shape ``(3, 4)``:"
msgstr ""

#: ../../taichi/docs/layout.rst:37
msgid ""
"x = ti.field(ti.f32)\n"
"ti.root.dense(ti.ij, (3, 4)).place(x)\n"
"# is equivalent to:\n"
"x = ti.field(ti.f32, shape=(3, 4))"
msgstr ""

#: ../../taichi/docs/layout.rst:44
msgid ""
"You may wonder, why not simply specify the ``shape`` of the field? Why "
"bother using the more complex version? Good question, let go forward and "
"figure out why."
msgstr ""

#: ../../taichi/docs/layout.rst:49
msgid "Row-major versus column-major"
msgstr ""

#: ../../taichi/docs/layout.rst:51
msgid "Let's start with the simplest layout."
msgstr ""

#: ../../taichi/docs/layout.rst:53
msgid ""
"Since address spaces are linear in modern computers, for 1D Taichi "
"fields, the address of the ``i``-th element is simply ``i``."
msgstr ""

#: ../../taichi/docs/layout.rst:55
msgid ""
"To store a multi-dimensional field, however, it has to be flattened, in "
"order to fit into the 1D address space. For example, to store a 2D field "
"of size ``(3, 2)``, there are two ways to do this:"
msgstr ""

#: ../../taichi/docs/layout.rst:58
msgid "The address of ``(i, j)``-th is ``base + i * 2 + j`` (row-major)."
msgstr ""

#: ../../taichi/docs/layout.rst:60
msgid "The address of ``(i, j)``-th is ``base + j * 3 + i`` (column-major)."
msgstr ""

#: ../../taichi/docs/layout.rst:62
msgid "To specify which layout to use in Taichi:"
msgstr ""

#: ../../taichi/docs/layout.rst:64
msgid ""
"ti.root.dense(ti.i, 3).dense(ti.j, 2).place(x)    # row-major (default)\n"
"ti.root.dense(ti.j, 2).dense(ti.i, 3).place(y)    # column-major"
msgstr ""

#: ../../taichi/docs/layout.rst:69
msgid ""
"Both ``x`` and ``y`` have the same shape of ``(3, 2)``, and they can be "
"accessed in the same manner, where ``0 <= i < 3 && 0 <= j < 2``. They can"
" be accessed in the same manner: ``x[i, j]`` and ``y[i, j]``. However, "
"they have a very different memory layouts:"
msgstr ""

#: ../../taichi/docs/layout.rst:72
msgid ""
"#     address low ........................... address high\n"
"# x:  x[0,0]   x[0,1]   x[0,2] | x[1,0]   x[1,1]   x[1,2]\n"
"# y:  y[0,0]   y[1,0] | y[0,1]   y[1,1] | y[0,2]   y[1,2]"
msgstr ""

#: ../../taichi/docs/layout.rst:78
msgid ""
"See? ``x`` first increases the first index (i.e. row-major), while ``y`` "
"first increases the second index (i.e. column-major)."
msgstr ""

#: ../../taichi/docs/layout.rst:82
msgid "For those people from C/C++, here's what they looks like:"
msgstr ""

#: ../../taichi/docs/layout.rst:84
msgid ""
"int x[3][2];  // row-major\n"
"int y[2][3];  // column-major\n"
"\n"
"for (int i = 0; i < 3; i++) {\n"
"    for (int j = 0; j < 2; j++) {\n"
"        do_something ( x[i][j] );\n"
"        do_something ( y[j][i] );\n"
"    }\n"
"}"
msgstr ""

#: ../../taichi/docs/layout.rst:98
msgid "Array of Structures (AoS), Structure of Arrays (SoA)"
msgstr ""

#: ../../taichi/docs/layout.rst:100
msgid "Fields of same size can be placed together."
msgstr ""

#: ../../taichi/docs/layout.rst:102
msgid ""
"For example, this places two 1D fields of size ``3`` (array of structure,"
" AoS):"
msgstr ""

#: ../../taichi/docs/layout.rst:104
msgid "ti.root.dense(ti.i, 3).place(x, y)"
msgstr ""

#: ../../taichi/docs/layout.rst:108
msgid "Their memory layout:"
msgstr ""

#: ../../taichi/docs/layout.rst:110
msgid ""
"#  address low ............. address high\n"
"#  x[0]   y[0] | x[1]  y[1] | x[2]   y[2]"
msgstr ""

#: ../../taichi/docs/layout.rst:115
msgid ""
"In contrast, this places two field placed separately (structure of array,"
" SoA):"
msgstr ""

#: ../../taichi/docs/layout.rst:117
msgid ""
"ti.root.dense(ti.i, 3).place(x)\n"
"ti.root.dense(ti.i, 3).place(y)"
msgstr ""

#: ../../taichi/docs/layout.rst:122
msgid "Now, their memory layout:"
msgstr ""

#: ../../taichi/docs/layout.rst:124
msgid ""
"#  address low ............. address high\n"
"#  x[0]  x[1]   x[2] | y[0]   y[1]   y[2]"
msgstr ""

#: ../../taichi/docs/layout.rst:130
msgid ""
"Normally, you don't have to worry about the performance nuances between "
"different layouts, and should just define the simplest layout as a start."
" However, locality sometimes have a significant impact on the "
"performance, especially when the field is huge."
msgstr ""

#: ../../taichi/docs/layout.rst:133
msgid ""
"**To improve spatial locality of memory accesses (i.e. cache hit rate / "
"cacheline utilization), it's sometimes helpful to place the data elements"
" within relatively close storage locations if they are often accessed "
"together.** Take a simple 1D wave equation solver for example:"
msgstr ""

#: ../../taichi/docs/layout.rst:136
msgid ""
"N = 200000\n"
"pos = ti.field(ti.f32)\n"
"vel = ti.field(ti.f32)\n"
"ti.root.dense(ti.i, N).place(pos)\n"
"ti.root.dense(ti.i, N).place(vel)\n"
"\n"
"@ti.kernel\n"
"def step():\n"
"    pos[i] += vel[i] * dt\n"
"    vel[i] += -k * pos[i] * dt"
msgstr ""

#: ../../taichi/docs/layout.rst:150
msgid ""
"Here, we placed ``pos`` and ``vel`` seperately. So the distance in "
"address space between ``pos[i]`` and ``vel[i]`` is ``200000``. This will "
"result in a poor spatial locality and lots of cache-misses, which damages"
" the performance. A better placement is to place them together:"
msgstr ""

#: ../../taichi/docs/layout.rst:153
msgid "ti.root.dense(ti.i, N).place(pos, vel)"
msgstr ""

#: ../../taichi/docs/layout.rst:157
msgid ""
"Then ``vel[i]`` is placed right next to ``pos[i]``, this can increase the"
" cache-hit rate and therefore increase the performance."
msgstr ""

#: ../../taichi/docs/layout.rst:161
msgid "Flat layouts versus hierarchical layouts"
msgstr ""

#: ../../taichi/docs/layout.rst:163
msgid ""
"By default, when allocating a ``ti.field``, it follows the simplest data "
"layout."
msgstr ""

#: ../../taichi/docs/layout.rst:165
msgid ""
"val = ti.field(ti.f32, shape=(32, 64, 128))\n"
"# C++ equivalent: float val[32][64][128]"
msgstr ""

#: ../../taichi/docs/layout.rst:170
msgid ""
"However, at times this data layout can be suboptimal for certain types of"
" computer graphics tasks. For example, ``val[i, j, k]`` and ``val[i + 1, "
"j, k]`` are very far away (``32 KB``) from each other, and leads to poor "
"access locality under certain computation tasks. Specifically, in tasks "
"such as texture trilinear interpolation, the two elements are not even "
"within the same ``4KB`` pages, creating a huge cache/TLB pressure."
msgstr ""

#: ../../taichi/docs/layout.rst:173
msgid "A better layout might be"
msgstr ""

#: ../../taichi/docs/layout.rst:175
msgid ""
"val = ti.field(ti.f32)\n"
"ti.root.dense(ti.ijk, (8, 16, 32)).dense(ti.ijk, (4, 4, 4)).place(val)"
msgstr ""

#: ../../taichi/docs/layout.rst:180
msgid ""
"This organizes ``val`` in ``4x4x4`` blocks, so that with high probability"
" ``val[i, j, k]`` and its neighbours are close to each other (i.e., in "
"the same cacheline or memory page)."
msgstr ""

#: ../../taichi/docs/layout.rst:184
msgid "Struct-fors on advanced dense data layouts"
msgstr ""

#: ../../taichi/docs/layout.rst:186
msgid ""
"Struct-fors on nested dense data structures will automatically follow "
"their data order in memory. For example, if 2D scalar field ``A`` is "
"stored in row-major order,"
msgstr ""

#: ../../taichi/docs/layout.rst:188
msgid ""
"for i, j in A:\n"
"  A[i, j] += 1"
msgstr ""

#: ../../taichi/docs/layout.rst:193
msgid ""
"will iterate over elements of ``A`` following row-major order. If ``A`` "
"is column-major, then the iteration follows the column-major order."
msgstr ""

#: ../../taichi/docs/layout.rst:195
msgid ""
"If ``A`` is hierarchical, it will be iterated level by level. This "
"maximizes the memory bandwidth utilization in most cases."
msgstr ""

#: ../../taichi/docs/layout.rst:197
msgid ""
"Struct-for loops on sparse fields follow the same philosophy, and will be"
" discussed further in :ref:`sparse`."
msgstr ""

#: ../../taichi/docs/layout.rst:203
msgid "2D matrix, row-major"
msgstr ""

#: ../../taichi/docs/layout.rst:205
msgid ""
"A = ti.field(ti.f32)\n"
"ti.root.dense(ti.ij, (256, 256)).place(A)"
msgstr ""

#: ../../taichi/docs/layout.rst:210
msgid "2D matrix, column-major"
msgstr ""

#: ../../taichi/docs/layout.rst:212
msgid ""
"A = ti.field(ti.f32)\n"
"ti.root.dense(ti.ji, (256, 256)).place(A) # Note ti.ji instead of ti.ij"
msgstr ""

#: ../../taichi/docs/layout.rst:217
msgid "`8x8` blocked 2D array of size `1024x1024`"
msgstr ""

#: ../../taichi/docs/layout.rst:219
msgid ""
"density = ti.field(ti.f32)\n"
"ti.root.dense(ti.ij, (128, 128)).dense(ti.ij, (8, 8)).place(density)"
msgstr ""

#: ../../taichi/docs/layout.rst:225
msgid "3D Particle positions and velocities, AoS"
msgstr ""

#: ../../taichi/docs/layout.rst:227
msgid ""
"pos = ti.Vector.field(3, dtype=ti.f32)\n"
"vel = ti.Vector.field(3, dtype=ti.f32)\n"
"ti.root.dense(ti.i, 1024).place(pos, vel)\n"
"# equivalent to\n"
"ti.root.dense(ti.i, 1024).place(pos(0), pos(1), pos(2), vel(0), vel(1), "
"vel(2))"
msgstr ""

#: ../../taichi/docs/layout.rst:235
msgid "3D Particle positions and velocities, SoA"
msgstr ""

#: ../../taichi/docs/layout.rst:237
msgid ""
"pos = ti.Vector.field(3, dtype=ti.f32)\n"
"vel = ti.Vector.field(3, dtype=ti.f32)\n"
"for i in range(3):\n"
"  ti.root.dense(ti.i, 1024).place(pos(i))\n"
"for i in range(3):\n"
"  ti.root.dense(ti.i, 1024).place(vel(i))"
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:2
msgid "Installing the legacy Taichi Library"
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:5
msgid ""
"This is NOT for installing the Taichi programming language. Unless you "
"are building a legacy project based on the `legacy Taichi library "
"<https://github.com/yuanming-hu/taichi/tree/legacy>`_ (e.g. `taichi_mpm "
"<https://github.com/yuanming-hu/taichi_mpm>`_ and `spgrid_topo_opt "
"<https://github.com/yuanming-hu/spgrid_topo_opt>`_) you should always "
"install Taichi using ``pip``."
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:11
msgid ""
"If you are working on the Taichi compiler and need to build from source, "
"see :ref:`dev_install`."
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:13
msgid "Supported platforms:"
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:15
msgid "Ubuntu (gcc 5+)"
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:16
msgid "Mac OS X (gcc 5+, clang 4.0+)"
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:17
msgid "Windows (Microsoft Visual Studio 2017)"
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:19
msgid "Make sure you have ``python 3.5`` +."
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:23
msgid "Ubuntu, Arch Linux, and Mac OS X"
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:25
msgid ""
"wget https://raw.githubusercontent.com/yuanming-"
"hu/taichi/legacy/install.py\n"
"python3 install.py"
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:31
msgid ""
"Note, if python complains that a package is missing, simply rerun "
"install.py and the package should be loaded."
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:35
msgid ""
"Download and execute `this script <https://raw.githubusercontent.com"
"/yuanming-hu/taichi/legacy/install.py>`_ with python3."
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:37
msgid ""
"Additional environment variables: (assuming taichi is installed in "
"``DIR/taichi``) Set ``TAICHI_REPO_DIR`` as  ``DIR/taichi`` (e.g. "
"``E:/repos/taichi``). Add ``%TAICHI_REPO_DIR%/python`` to ``PYTHONPATH``,"
" ``DIR/taichi/bin`` (e.g. ``E:/repos/taichi/bin``) to ``PATH``. Restart "
"cmd or PowerShell, and you should be able to run command ``ti``."
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:43
msgid "Build with Double Precision (64 bit) Float Point"
msgstr ""

#: ../../taichi/docs/legacy_installation.rst:44
msgid ""
"export TC_USE_DOUBLE=1\n"
"ti build"
msgstr ""

#: ../../taichi/docs/matrix.rst:4
msgid "Matrices"
msgstr ""

#: ../../taichi/docs/matrix.rst:6
msgid ""
"``ti.Matrix`` is for small matrices (e.g. `3x3`) only. If you have "
"`64x64` matrices, you should consider using a 2D scalar field."
msgstr ""

#: ../../taichi/docs/matrix.rst:7
msgid ""
"``ti.Vector`` is the same as ``ti.Matrix``, except that it has only one "
"column."
msgstr ""

#: ../../taichi/docs/matrix.rst:8
msgid "Differentiate element-wise product ``*`` and matrix product ``@``."
msgstr ""

#: ../../taichi/docs/matrix.rst:9
msgid ""
"``ti.Vector.field(n, dtype=ti.f32)`` or ``ti.Matrix.field(n, m, "
"dtype=ti.f32)`` to create vector/matrix fields."
msgstr ""

#: ../../taichi/docs/matrix.rst:10
msgid "``A.transpose()``"
msgstr ""

#: ../../taichi/docs/matrix.rst:11
msgid "``R, S = ti.polar_decompose(A, ti.f32)``"
msgstr ""

#: ../../taichi/docs/matrix.rst:12
msgid ""
"``U, sigma, V = ti.svd(A, ti.f32)`` (Note that ``sigma`` is a ``3x3`` "
"diagonal matrix)"
msgstr ""

#: ../../taichi/docs/matrix.rst:13
msgid "``any(A)`` (Taichi-scope only)"
msgstr ""

#: ../../taichi/docs/matrix.rst:14
msgid "``all(A)`` (Taichi-scope only)"
msgstr ""

#: ../../taichi/docs/matrix.rst:16
msgid "TODO: doc here better like Vector. WIP"
msgstr ""

#: ../../taichi/docs/matrix.rst:18
msgid "A matrix in Taichi can have two forms:"
msgstr ""

#: ../../taichi/docs/matrix.rst:20
msgid ""
"as a temporary local variable. An ``n by m`` matrix consists of ``n * m``"
" scalar values."
msgstr ""

#: ../../taichi/docs/matrix.rst:21
msgid ""
"as a an element of a global field. In this case, the field is an "
"N-dimensional array of ``n by m`` matrices."
msgstr ""

#: ../../taichi/docs/matrix.rst:24 ../../taichi/docs/scalar_tensor.rst:27
#: ../../taichi/docs/vector.rst:14
msgid "Declaration"
msgstr ""

#: ../../taichi/docs/matrix.rst:27 ../../taichi/docs/matrix.rst:94
msgid "As global matrix fields"
msgstr ""

#: ../../taichi/docs/matrix.rst:31
msgid "(scalar) the number of rows in the matrix"
msgstr ""

#: ../../taichi/docs/matrix.rst:32
msgid "(scalar) the number of columns in the matrix"
msgstr ""

#: ../../taichi/docs/matrix.rst:33 ../../taichi/docs/vector.rst:22
msgid "(DataType) data type of the components"
msgstr ""

#: ../../taichi/docs/matrix.rst:34
msgid "(optional, scalar or tuple) shape of the matrix field, see :ref:`tensor`"
msgstr ""

#: ../../taichi/docs/matrix.rst:35 ../../taichi/docs/scalar_tensor.rst:33
#: ../../taichi/docs/vector.rst:24
msgid "(optional, scalar or tuple) see :ref:`offset`"
msgstr ""

#: ../../taichi/docs/matrix.rst:37
msgid ""
"For example, this creates a 5x4 matrix field with each entry being a 3x3 "
"matrix: ::"
msgstr ""

#: ../../taichi/docs/matrix.rst:40
msgid ""
"# Python-scope\n"
"a = ti.Matrix.field(3, 3, dtype=ti.f32, shape=(5, 4))"
msgstr ""

#: ../../taichi/docs/matrix.rst:45
msgid ""
"In Python-scope, ``ti.field`` declares a :ref:`scalar_tensor`, while "
"``ti.Matrix.field`` declares a matrix field."
msgstr ""

#: ../../taichi/docs/matrix.rst:49 ../../taichi/docs/matrix.rst:124
#: ../../taichi/docs/vector.rst:38 ../../taichi/docs/vector.rst:85
msgid "As a temporary local variable"
msgstr ""

#: ../../taichi/docs/matrix.rst:53
msgid "(scalar) the first component of the first row"
msgstr ""

#: ../../taichi/docs/matrix.rst:54
msgid "(scalar) the second component of the first row"
msgstr ""

#: ../../taichi/docs/matrix.rst:55
msgid "(scalar) the first component of the second row"
msgstr ""

#: ../../taichi/docs/matrix.rst:56
msgid "(scalar) the second component of the second row"
msgstr ""

#: ../../taichi/docs/matrix.rst:58
msgid ""
"For example, this creates a 2x3 matrix with components (2, 3, 4) in the "
"first row and (5, 6, 7) in the second row: ::"
msgstr ""

#: ../../taichi/docs/matrix.rst:61
msgid ""
"# Taichi-scope\n"
"a = ti.Matrix([[2, 3, 4], [5, 6, 7]])"
msgstr ""

#: ../../taichi/docs/matrix.rst:68
msgid "(vector) vector of elements forming first row (or column)"
msgstr ""

#: ../../taichi/docs/matrix.rst:69
msgid "(vector) vector of elements forming second row (or column)"
msgstr ""

#: ../../taichi/docs/matrix.rst:70
msgid "(vector) vector of elements forming third row (or column)"
msgstr ""

#: ../../taichi/docs/matrix.rst:72
msgid ""
"For example, this creates a 3x3 matrix by concactinating vectors into "
"rows (or columns): ::"
msgstr ""

#: ../../taichi/docs/matrix.rst:75
msgid ""
"# Taichi-scope\n"
"v0 = ti.Vector([1.0, 2.0, 3.0])\n"
"v1 = ti.Vector([4.0, 5.0, 6.0])\n"
"v2 = ti.Vector([7.0, 8.0, 9.0])\n"
"\n"
"# to specify data in rows\n"
"a = ti.Matrix.rows([v0, v1, v2])\n"
"\n"
"# to specify data in columns instead\n"
"a = ti.Matrix.cols([v0, v1, v2])\n"
"\n"
"# lists can be used instead of vectors\n"
"a = ti.Matrix.rows([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])"
msgstr ""

#: ../../taichi/docs/matrix.rst:91 ../../taichi/docs/scalar_tensor.rst:96
#: ../../taichi/docs/vector.rst:53
msgid "Accessing components"
msgstr ""

#: ../../taichi/docs/matrix.rst:97
msgid "(ti.Matrix.field) the matrix field"
msgstr ""

#: ../../taichi/docs/matrix.rst:98 ../../taichi/docs/scalar_tensor.rst:103
#: ../../taichi/docs/vector.rst:60
msgid "(scalar) index of the first field dimension"
msgstr ""

#: ../../taichi/docs/matrix.rst:99 ../../taichi/docs/scalar_tensor.rst:104
#: ../../taichi/docs/vector.rst:61
msgid "(scalar) index of the second field dimension"
msgstr ""

#: ../../taichi/docs/matrix.rst:100 ../../taichi/docs/matrix.rst:129
msgid "(scalar) row index of the matrix"
msgstr ""

#: ../../taichi/docs/matrix.rst:101 ../../taichi/docs/matrix.rst:130
msgid "(scalar) column index of the matrix"
msgstr ""

#: ../../taichi/docs/matrix.rst:103
msgid "This extracts the first element in matrix ``a[6, 3]``: ::"
msgstr ""

#: ../../taichi/docs/matrix.rst:106
msgid ""
"x = a[6, 3][0, 0]\n"
"\n"
"# or\n"
"mat = a[6, 3]\n"
"x = mat[0, 0]"
msgstr ""

#: ../../taichi/docs/matrix.rst:114
msgid ""
"**Always** use two pair of square brackets to access scalar elements from"
" matrix fields."
msgstr ""

#: ../../taichi/docs/matrix.rst:116
msgid ""
"The indices in the first pair of brackets locate the matrix inside the "
"matrix fields;"
msgstr ""

#: ../../taichi/docs/matrix.rst:117
msgid ""
"The indices in the second pair of brackets locate the scalar element "
"inside the matrix."
msgstr ""

#: ../../taichi/docs/matrix.rst:119
msgid ""
"For 0-D matrix fields, indices in the first pair of brackets should be "
"``[None]``."
msgstr ""

#: ../../taichi/docs/matrix.rst:128
msgid "(Matrix) the matrix"
msgstr ""

#: ../../taichi/docs/matrix.rst:132
msgid ""
"For example, this extracts the element in row 0 column 1 of matrix ``a``:"
" ::"
msgstr ""

#: ../../taichi/docs/matrix.rst:135
msgid "x = a[0, 1]"
msgstr ""

#: ../../taichi/docs/matrix.rst:137
msgid "This sets the element in row 1 column 3 of ``a`` to 4: ::"
msgstr ""

#: ../../taichi/docs/matrix.rst:140
msgid "a[1, 3] = 4"
msgstr ""

#: ../../taichi/docs/matrix.rst:143 ../../taichi/docs/vector.rst:105
msgid "Methods"
msgstr ""

#: ../../taichi/docs/matrix.rst:147 ../../taichi/docs/matrix.rst:163
#: ../../taichi/docs/matrix.rst:171 ../../taichi/docs/matrix.rst:183
msgid "(ti.Matrix) the matrix"
msgstr ""

#: ../../taichi/docs/matrix.rst:148
msgid "(ti.Matrix) the transposed matrix of ``a``."
msgstr ""

#: ../../taichi/docs/matrix.rst:152
msgid ""
"a = ti.Matrix([[2, 3], [4, 5]])\n"
"b = a.transpose()\n"
"# Now b = ti.Matrix([[2, 4], [3, 5]])"
msgstr ""

#: ../../taichi/docs/matrix.rst:158
msgid ""
"``a.transpose()`` will not effect the data in ``a``, it just return the "
"result."
msgstr ""

#: ../../taichi/docs/matrix.rst:164
msgid "(scalar) the trace of matrix ``a``."
msgstr ""

#: ../../taichi/docs/matrix.rst:166
msgid "The return value can be computed as ``a[0, 0] + a[1, 1] + ...``."
msgstr ""

#: ../../taichi/docs/matrix.rst:172
msgid "(scalar) the determinant of matrix ``a``."
msgstr ""

#: ../../taichi/docs/matrix.rst:176 ../../taichi/docs/matrix.rst:188
msgid "The matrix size of matrix must be 1x1, 2x2, 3x3 or 4x4 for now."
msgstr ""

#: ../../taichi/docs/matrix.rst:178 ../../taichi/docs/matrix.rst:190
msgid "This function only works in Taichi-scope for now."
msgstr ""

#: ../../taichi/docs/matrix.rst:184
msgid "(ti.Matrix) the inverse of matrix ``a``."
msgstr ""

#: ../../taichi/docs/meta.rst:4 ../../taichi/docs/overview.rst:11
msgid "Metaprogramming"
msgstr ""

#: ../../taichi/docs/meta.rst:6
msgid "Taichi provides metaprogramming infrastructures. Metaprogramming can"
msgstr ""

#: ../../taichi/docs/meta.rst:8
msgid ""
"Unify the development of dimensionality-dependent code, such as 2D/3D "
"physical simulations"
msgstr ""

#: ../../taichi/docs/meta.rst:9
msgid "Improve run-time performance by from run-time costs to compile time"
msgstr ""

#: ../../taichi/docs/meta.rst:10
msgid "Simplify the development of Taichi standard library"
msgstr ""

#: ../../taichi/docs/meta.rst:12
msgid ""
"Taichi kernels are *lazily instantiated* and a lot of computation can "
"happen at *compile-time*. Every kernel in Taichi is a template kernel, "
"even if it has no template arguments."
msgstr ""

#: ../../taichi/docs/meta.rst:18
msgid "Template metaprogramming"
msgstr ""

#: ../../taichi/docs/meta.rst:20
msgid ""
"You may use ``ti.template()`` as a type hint to pass a field as an "
"argument. For example:"
msgstr ""

#: ../../taichi/docs/meta.rst:23
msgid ""
"@ti.kernel\n"
"def copy(x: ti.template(), y: ti.template()):\n"
"    for i in x:\n"
"        y[i] = x[i]\n"
"\n"
"a = ti.field(ti.f32, 4)\n"
"b = ti.field(ti.f32, 4)\n"
"c = ti.field(ti.f32, 12)\n"
"d = ti.field(ti.f32, 12)\n"
"copy(a, b)\n"
"copy(c, d)"
msgstr ""

#: ../../taichi/docs/meta.rst:38
msgid ""
"As shown in the example above, template programming may enable us to "
"reuse our code and provide more flexibility."
msgstr ""

#: ../../taichi/docs/meta.rst:43
msgid "Dimensionality-independent programming using grouped indices"
msgstr ""

#: ../../taichi/docs/meta.rst:45
msgid ""
"However, the ``copy`` template shown above is not perfect. For example, "
"it can only be used to copy 1D fields. What if we want to copy 2D fields?"
" Do we have to write another kernel?"
msgstr ""

#: ../../taichi/docs/meta.rst:49
msgid ""
"@ti.kernel\n"
"def copy2d(x: ti.template(), y: ti.template()):\n"
"    for i, j in x:\n"
"        y[i, j] = x[i, j]"
msgstr ""

#: ../../taichi/docs/meta.rst:56
msgid ""
"Not necessary! Taichi provides ``ti.grouped`` syntax which enables you to"
" pack loop indices into a grouped vector to unify kernels of different "
"dimensionalities. For example:"
msgstr ""

#: ../../taichi/docs/meta.rst:60
msgid ""
"@ti.kernel\n"
"def copy(x: ti.template(), y: ti.template()):\n"
"    for I in ti.grouped(y):\n"
"        # I is a vector with same dimensionality with x and data type i32"
"\n"
"        # If y is 0D, then I = ti.Vector([]), which is equivalent to "
"`None` when used in x[I]\n"
"        # If y is 1D, then I = ti.Vector([i])\n"
"        # If y is 2D, then I = ti.Vector([i, j])\n"
"        # If y is 3D, then I = ti.Vector([i, j, k])\n"
"        # ...\n"
"        x[I] = y[I]\n"
"\n"
"@ti.kernel\n"
"def array_op(x: ti.template(), y: ti.template()):\n"
"    # if field x is 2D:\n"
"    for I in ti.grouped(x): # I is simply a 2D vector with data type i32\n"
"        y[I + ti.Vector([0, 1])] = I[0] + I[1]\n"
"\n"
"    # then it is equivalent to:\n"
"    for i, j in x:\n"
"        y[i, j + 1] = i + j"
msgstr ""

#: ../../taichi/docs/meta.rst:85
msgid "Field metadata"
msgstr ""

#: ../../taichi/docs/meta.rst:87
msgid ""
"Sometimes it is useful to get the data type (``field.dtype``) and shape "
"(``field.shape``) of fields. These attributes can be accessed in both "
"Taichi- and Python-scopes."
msgstr ""

#: ../../taichi/docs/meta.rst:90
msgid ""
"@ti.func\n"
"def print_field_info(x: ti.template()):\n"
"  print('Field dimensionality is', len(x.shape))\n"
"  for i in ti.static(range(len(x.shape))):\n"
"    print('Size alone dimension', i, 'is', x.shape[i])\n"
"  ti.static_print('Field data type is', x.dtype)"
msgstr ""

#: ../../taichi/docs/meta.rst:99 ../../taichi/docs/tensor_matrix.rst:26
msgid "See :ref:`scalar_tensor` for more details."
msgstr ""

#: ../../taichi/docs/meta.rst:103
msgid "For sparse fields, the full domain shape will be returned."
msgstr ""

#: ../../taichi/docs/meta.rst:107
msgid "Matrix & vector metadata"
msgstr ""

#: ../../taichi/docs/meta.rst:109
msgid ""
"Getting the number of matrix columns and rows will allow you to write "
"dimensionality-independent code. For example, this can be used to unify "
"2D and 3D physical simulators."
msgstr ""

#: ../../taichi/docs/meta.rst:113
msgid ""
"``matrix.m`` equals to the number of columns of a matrix, while "
"``matrix.n`` equals to the number of rows of a matrix. Since vectors are "
"considered as matrices with one column, ``vector.n`` is simply the "
"dimensionality of the vector."
msgstr ""

#: ../../taichi/docs/meta.rst:118
msgid ""
"@ti.kernel\n"
"def foo():\n"
"  matrix = ti.Matrix([[1, 2], [3, 4], [5, 6]])\n"
"  print(matrix.n)  # 2\n"
"  print(matrix.m)  # 3\n"
"  vector = ti.Vector([7, 8, 9])\n"
"  print(vector.n)  # 3\n"
"  print(vector.m)  # 1"
msgstr ""

#: ../../taichi/docs/meta.rst:132
msgid "Compile-time evaluations"
msgstr ""

#: ../../taichi/docs/meta.rst:134
msgid ""
"Using compile-time evaluation will allow certain computations to happen "
"when kernels are being instantiated. This saves the overhead of those "
"computations at runtime."
msgstr ""

#: ../../taichi/docs/meta.rst:137
msgid ""
"Use ``ti.static`` for compile-time branching (for those who come from "
"C++17, this is `if constexpr "
"<https://en.cppreference.com/w/cpp/language/if>`_.):"
msgstr ""

#: ../../taichi/docs/meta.rst:139
msgid ""
"enable_projection = True\n"
"\n"
"@ti.kernel\n"
"def static():\n"
"  if ti.static(enable_projection): # No runtime overhead\n"
"    x[0] = 1"
msgstr ""

#: ../../taichi/docs/meta.rst:149
msgid "Use ``ti.static`` for forced loop unrolling:"
msgstr ""

#: ../../taichi/docs/meta.rst:151
msgid ""
"@ti.kernel\n"
"def func():\n"
"  for i in ti.static(range(4)):\n"
"      print(i)\n"
"\n"
"  # is equivalent to:\n"
"  print(0)\n"
"  print(1)\n"
"  print(2)\n"
"  print(3)"
msgstr ""

#: ../../taichi/docs/meta.rst:166
msgid "When to use for loops with ``ti.static``"
msgstr ""

#: ../../taichi/docs/meta.rst:168
msgid "There are several reasons why ``ti.static`` for loops should be used."
msgstr ""

#: ../../taichi/docs/meta.rst:170
msgid "Loop unrolling for performance."
msgstr ""

#: ../../taichi/docs/meta.rst:171
msgid ""
"Loop over vector/matrix elements. Indices into Taichi matrices must be a "
"compile-time constant. Indexing into taichi fields can be run-time "
"variables. For example, if you want to access a vector field ``x``, "
"accessed as ``x[field_index][vector_component_index]``. The first index "
"can be variable, yet the second must be a constant."
msgstr ""

#: ../../taichi/docs/meta.rst:173
msgid "For example, code for resetting this vector fields should be"
msgstr ""

#: ../../taichi/docs/meta.rst:175
msgid ""
"@ti.kernel\n"
"def reset():\n"
"  for i in x:\n"
"    for j in ti.static(range(x.n)):\n"
"      # The inner loop must be unrolled since j is a vector index instead"
"\n"
"      # of a global field index.\n"
"      x[i][j] = 0"
msgstr ""

#: ../../taichi/docs/odop.rst:2
msgid "Objective data-oriented programming"
msgstr ""

#: ../../taichi/docs/odop.rst:4
msgid ""
"Taichi is a `data-oriented <https://en.wikipedia.org/wiki/Data-"
"oriented_design>`_ programming (DOP) language. However, simple DOP makes "
"modularization hard."
msgstr ""

#: ../../taichi/docs/odop.rst:6
msgid ""
"To allow modularized code, Taichi borrow some concepts from object-"
"oriented programming (OOP)."
msgstr ""

#: ../../taichi/docs/odop.rst:8
msgid ""
"For convenience, let's call the hybrid scheme **objective data-oriented "
"programming** (ODOP)."
msgstr ""

#: ../../taichi/docs/odop.rst:10
msgid "TODO: More documentation here."
msgstr ""

#: ../../taichi/docs/odop.rst:12
msgid "A brief example:"
msgstr ""

#: ../../taichi/docs/odop.rst:14
msgid ""
"import taichi as ti\n"
"\n"
"ti.init()\n"
"\n"
"@ti.data_oriented\n"
"class Array2D:\n"
"  def __init__(self, n, m, increment):\n"
"    self.n = n\n"
"    self.m = m\n"
"    self.val = ti.field(ti.f32)\n"
"    self.total = ti.field(ti.f32)\n"
"    self.increment = increment\n"
"    ti.root.dense(ti.ij, (self.n, self.m)).place(self.val)\n"
"    ti.root.place(self.total)\n"
"\n"
"  @staticmethod\n"
"  @ti.func\n"
"  def clamp(x):  # Clamp to [0, 1)\n"
"      return max(0, min(1 - 1e-6, x))\n"
"\n"
"  @ti.kernel\n"
"  def inc(self):\n"
"    for i, j in self.val:\n"
"      ti.atomic_add(self.val[i, j], self.increment)\n"
"\n"
"  @ti.kernel\n"
"  def inc2(self, increment: ti.i32):\n"
"    for i, j in self.val:\n"
"      ti.atomic_add(self.val[i, j], increment)\n"
"\n"
"  @ti.kernel\n"
"  def reduce(self):\n"
"    for i, j in self.val:\n"
"      ti.atomic_add(self.total, self.val[i, j] * 4)\n"
"\n"
"arr = Array2D(128, 128, 3)\n"
"\n"
"double_total = ti.field(ti.f32, shape=())\n"
"\n"
"ti.root.lazy_grad()\n"
"\n"
"arr.inc()\n"
"arr.inc.grad()\n"
"assert arr.val[3, 4] == 3\n"
"arr.inc2(4)\n"
"assert arr.val[3, 4] == 7\n"
"\n"
"with ti.Tape(loss=arr.total):\n"
"  arr.reduce()\n"
"\n"
"for i in range(arr.n):\n"
"  for j in range(arr.m):\n"
"    assert arr.val.grad[i, j] == 4\n"
"\n"
"@ti.kernel\n"
"def double():\n"
"  double_total[None] = 2 * arr.total\n"
"\n"
"with ti.Tape(loss=double_total):\n"
"  arr.reduce()\n"
"  double()\n"
"\n"
"for i in range(arr.n):\n"
"  for j in range(arr.m):\n"
"    assert arr.val.grad[i, j] == 8"
msgstr ""

#: ../../taichi/docs/offset.rst:4
msgid "Coordinate offsets"
msgstr ""

#: ../../taichi/docs/offset.rst:6
msgid ""
"A Taichi field can be defined with **coordinate offsets**. The offsets "
"will move field bounds so that field origins are no longer zero vectors. "
"A typical use case is to support voxels with negative coordinates in "
"physical simulations."
msgstr ""

#: ../../taichi/docs/offset.rst:7
msgid ""
"For example, a matrix of ``32x64`` elements with coordinate offset "
"``(-16, 8)`` can be defined as the following:"
msgstr ""

#: ../../taichi/docs/offset.rst:9
msgid "a = ti.Matrix(2, 2, dtype=ti.f32, shape=(32, 64), offset=(-16, 8))"
msgstr ""

#: ../../taichi/docs/offset.rst:13
msgid ""
"In this way, the field's indices are from ``(-16, 8)`` to ``(16, 72)`` "
"(exclusive)."
msgstr ""

#: ../../taichi/docs/offset.rst:15
msgid ""
"a[-16, 32]  # lower left corner\n"
"a[16, 32]   # lower right corner\n"
"a[-16, 64]  # upper left corner\n"
"a[16, 64]   # upper right corner"
msgstr ""

#: ../../taichi/docs/offset.rst:22
msgid ""
"The dimensionality of field shapes should **be consistent** with that of "
"the offset. Otherwise, a ``AssertionError`` will be raised."
msgstr ""

#: ../../taichi/docs/offset.rst:24
msgid ""
"a = ti.Matrix.field(2, 3, dtype=ti.f32, shape=(32,), offset=(-16, ))"
"          # Works!\n"
"b = ti.Vector.field(3, dtype=ti.f32, shape=(16, 32, 64), offset=(7, 3, "
"-4))   # Works!\n"
"c = ti.Matrix.field(2, 1, dtype=ti.f32, shape=None, offset=(32,))"
"             # AssertionError\n"
"d = ti.Matrix.field(3, 2, dtype=ti.f32, shape=(32, 32), offset=(-16, ))"
"       # AssertionError\n"
"e = ti.field(dtype=ti.i32, shape=16, offset=-16)"
"                          # Works!\n"
"f = ti.field(dtype=ti.i32, shape=None, offset=-16)"
"                        # AssertionError\n"
"g = ti.field(dtype=ti.i32, shape=(16, 32), offset=-16)"
"                    # AssertionError"
msgstr ""

#: ../../taichi/docs/overview.rst:2
msgid "Why new programming language"
msgstr ""

#: ../../taichi/docs/overview.rst:4
msgid ""
"Taichi is a high-performance programming language for computer graphics "
"applications. The design goals are"
msgstr ""

#: ../../taichi/docs/overview.rst:6
msgid "Productivity"
msgstr ""

#: ../../taichi/docs/overview.rst:7
msgid "Performance"
msgstr ""

#: ../../taichi/docs/overview.rst:9
msgid "Spatially sparse computation"
msgstr ""

#: ../../taichi/docs/overview.rst:14
msgid "Design decisions"
msgstr ""

#: ../../taichi/docs/overview.rst:16
msgid "Decouple computation from data structures"
msgstr ""

#: ../../taichi/docs/overview.rst:17
msgid "Domain-specific compiler optimizations"
msgstr ""

#: ../../taichi/docs/overview.rst:18
msgid "Megakernels"
msgstr ""

#: ../../taichi/docs/overview.rst:19
msgid "Two-scale automatic differentiation"
msgstr ""

#: ../../taichi/docs/overview.rst:20
msgid "Embedding in Python"
msgstr ""

#: ../../taichi/docs/profiler.rst:3
msgid "Profiler"
msgstr ""

#: ../../taichi/docs/profiler.rst:5
msgid ""
"Taichi's profiler can help you analyze the run-time cost of your program."
" There are two profiling systems in Taichi: ``ScopedProfiler`` and "
"``KernelProfiler``."
msgstr ""

#: ../../taichi/docs/profiler.rst:8
msgid "ScopedProfiler"
msgstr ""

#: ../../taichi/docs/profiler.rst:10
msgid ""
"``ScopedProfiler`` measures time spent on the **host tasks** "
"hierarchically."
msgstr ""

#: ../../taichi/docs/profiler.rst:12
msgid ""
"This profiler is automatically on. To show its results, call "
"``ti.print_profile_info()``. For example:"
msgstr ""

#: ../../taichi/docs/profiler.rst:14
msgid ""
"import taichi as ti\n"
"\n"
"ti.init(arch=ti.cpu)\n"
"var = ti.field(ti.f32, shape=1)\n"
"\n"
"\n"
"@ti.kernel\n"
"def compute():\n"
"    var[0] = 1.0\n"
"    print(\"Setting var[0] =\", var[0])\n"
"\n"
"\n"
"compute()\n"
"ti.print_profile_info()"
msgstr ""

#: ../../taichi/docs/profiler.rst:32
msgid ""
"``ti.print_profile_info()`` prints profiling results in a hierarchical "
"format."
msgstr ""

#: ../../taichi/docs/profiler.rst:36
msgid ""
"``ScopedProfiler`` is a C++ class in the core of Taichi. It is not "
"exposed to Python users."
msgstr ""

#: ../../taichi/docs/profiler.rst:39
msgid "KernelProfiler"
msgstr ""

#: ../../taichi/docs/profiler.rst:41
msgid ""
"``KernelProfiler`` records the costs of Taichi kernels on devices. To "
"enable this profiler, set ``kernel_profiler=True`` in ``ti.init``."
msgstr ""

#: ../../taichi/docs/profiler.rst:43
msgid ""
"Call ``ti.kernel_profiler_print()`` to show the kernel profiling result. "
"For example:"
msgstr ""

#: ../../taichi/docs/profiler.rst:45
msgid ""
"import taichi as ti\n"
"\n"
"ti.init(ti.cpu, kernel_profiler=True)\n"
"var = ti.field(ti.f32, shape=1)\n"
"\n"
"\n"
"@ti.kernel\n"
"def compute():\n"
"    var[0] = 1.0\n"
"\n"
"\n"
"compute()\n"
"ti.kernel_profiler_print()"
msgstr ""

#: ../../taichi/docs/profiler.rst:63
msgid "The outputs would be:"
msgstr ""

#: ../../taichi/docs/profiler.rst:67
msgid ""
"[ 22.73%] jit_evaluator_0_kernel_0_serial             min   0.001 ms   "
"avg   0.001 ms   max   0.001 ms   total   0.000 s [      1x]\n"
"[  0.00%] jit_evaluator_1_kernel_1_serial             min   0.000 ms   "
"avg   0.000 ms   max   0.000 ms   total   0.000 s [      1x]\n"
"[ 77.27%] compute_c4_0_kernel_2_serial                min   0.004 ms   "
"avg   0.004 ms   max   0.004 ms   total   0.000 s [      1x]"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:4 ../../taichi/docs/tensor_matrix.rst:14
msgid "Scalar fields"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:6
msgid "**Taichi fields** are used to store data."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:8
msgid ""
"Field **elements** could be either a scalar, a vector, or a matrix (see "
":ref:`matrix`). In this paragraph, we will only talk about **scalar "
"fields**, whose elements are simply scalars."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:11
msgid "Fields can have up to eight **dimensions**."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:13
msgid "A 0D scalar field is simply a single scalar."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:14
msgid "A 1D scalar field is a 1D linear array."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:15
msgid ""
"A 2D scalar field can be used to represent a 2D regular grid of values. "
"For example, a gray-scale image."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:16
msgid "A 3D scalar field can be used for volumetric data."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:18
msgid ""
"Fields could be either dense or sparse, see ref:`sparse` for details on "
"sparse fields. We will only talk about **dense fields** in this "
"paragraph."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:23
msgid ""
"We once used the term **tensor** instead of **field**. **Tensor** will no"
" longer be used."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:31
msgid "(DataType) type of the field element"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:32
msgid "(optional, scalar or tuple) the shape of field"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:35
msgid ""
"For example, this creates a *dense* field with four ``int32`` as "
"elements: ::"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:38
msgid "x = ti.field(ti.i32, shape=4)"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:40
msgid "This creates a 4x3 *dense* field with ``float32`` elements: ::"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:43
msgid "x = ti.field(ti.f32, shape=(4, 3))"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:45
msgid "If shape is ``()`` (empty tuple), then a 0-D field (scalar) is created: ::"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:48
msgid "x = ti.field(ti.f32, shape=())"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:50
msgid "Then access it by passing ``None`` as index: ::"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:53
msgid "x[None] = 2"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:55
msgid ""
"If shape is **not provided** or ``None``, the user must manually "
"``place`` it afterwards: ::"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:58
msgid ""
"x = ti.field(ti.f32)\n"
"ti.root.dense(ti.ij, (4, 3)).place(x)\n"
"# equivalent to: x = ti.field(ti.f32, shape=(4, 3))"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:64
msgid ""
"Not providing ``shape`` allows you to *place* the field in a layout other"
" than the default *dense*, see :ref:`layout` for more details."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:69
msgid ""
"All variables should be created and placed before any kernel invocation "
"or any of them accessed from python-scope. For example:"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:71
msgid ""
"x = ti.field(ti.f32)\n"
"x[None] = 1 # ERROR: x not placed!"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:76
msgid ""
"x = ti.field(ti.f32, shape=())\n"
"@ti.kernel\n"
"def func():\n"
"    x[None] = 1\n"
"\n"
"func()\n"
"y = ti.field(ti.f32, shape=())\n"
"# ERROR: cannot create fields after kernel invocation!"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:87
msgid ""
"x = ti.field(ti.f32, shape=())\n"
"x[None] = 1\n"
"y = ti.field(ti.f32, shape=())\n"
"# ERROR: cannot create fields after any field accesses from the Python-"
"scope!"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:98
msgid "You can access an element of the Taichi field by an index or indices."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:102
msgid "(ti.field) the sclar field"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:105
msgid "(scalar) the element at ``[p, q, ...]``"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:107
msgid "This extracts the element value at index ``[3, 4]`` of field ``a``: ::"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:110
msgid "x = a[3, 4]"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:112
msgid "This sets the element value at index ``2`` of 1D field ``b`` to ``5``: ::"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:115
msgid "b[2] = 5"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:119
msgid ""
"In Python, x[(exp1, exp2, ..., expN)] is equivalent to x[exp1, exp2, ...,"
" expN]; the latter is just syntactic sugar for the former."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:123
msgid ""
"The returned value can also be ``Vector`` / ``Matrix`` if ``a`` is a "
"vector/matrix field, see :ref:`vector` for more details."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:127
msgid "Meta data"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:132
#: ../../taichi/docs/scalar_tensor.rst:149
#: ../../taichi/docs/scalar_tensor.rst:160
msgid "(ti.field) the field"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:133
msgid "(tuple) the shape of field ``a``"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:137
msgid ""
"x = ti.field(ti.i32, (6, 5))\n"
"x.shape  # (6, 5)\n"
"\n"
"y = ti.field(ti.i32, 6)\n"
"y.shape  # (6,)\n"
"\n"
"z = ti.field(ti.i32, ())\n"
"z.shape  # ()"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:150
msgid "(DataType) the data type of ``a``"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:154
msgid ""
"x = ti.field(ti.i32, (2, 3))\n"
"x.dtype  # ti.i32"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:161
msgid ""
"(optional, scalar) the number of parent steps, i.e. ``n=1`` for parent, "
"``n=2`` grandparent, etc."
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:162
msgid "(SNode) the parent of ``a``'s containing SNode"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:166
msgid ""
"x = ti.field(ti.i32)\n"
"y = ti.field(ti.i32)\n"
"blk1 = ti.root.dense(ti.ij, (6, 5))\n"
"blk2 = blk1.dense(ti.ij, (3, 2))\n"
"blk1.place(x)\n"
"blk2.place(y)\n"
"\n"
"x.parent()   # blk1\n"
"y.parent()   # blk2\n"
"y.parent(2)  # blk1"
msgstr ""

#: ../../taichi/docs/scalar_tensor.rst:177
msgid "See :ref:`snode` for more details."
msgstr ""

#: ../../taichi/docs/snode.rst:4
msgid "Structural nodes (SNodes)"
msgstr ""

#: ../../taichi/docs/snode.rst:6
msgid ""
"After writing the computation code, the user needs to specify the "
"internal data structure hierarchy. Specifying a data structure includes "
"choices at both the macro level, dictating how the data structure "
"components nest with each other and the way they represent sparsity, and "
"the micro level, dictating how data are grouped together (e.g. structure "
"of arrays vs. array of structures). Taichi provides *Structural Nodes "
"(SNodes)* to compose the hierarchy and particular properties. These "
"constructs and their semantics are listed below:"
msgstr ""

#: ../../taichi/docs/snode.rst:9
msgid "dense: A fixed-length contiguous array."
msgstr ""

#: ../../taichi/docs/snode.rst:11
msgid ""
"bitmasked: This is similar to dense, but it also uses a mask to maintain "
"sparsity information, one bit per child."
msgstr ""

#: ../../taichi/docs/snode.rst:13
msgid ""
"pointer: Store pointers instead of the whole structure to save memory and"
" maintain sparsity."
msgstr ""

#: ../../taichi/docs/snode.rst:15
msgid ""
"dynamic: Variable-length array, with a predefined maximum length. It "
"serves the role of ``std::vector`` in C++ or ``list`` in Python, and can "
"be used to maintain objects (e.g. particles) contained in a block."
msgstr ""

#: ../../taichi/docs/snode.rst:18
msgid ""
"See :ref:`layout` for more details. ``ti.root`` is the root node of the "
"data structure."
msgstr ""

#: ../../taichi/docs/snode.rst:22
msgid "(SNode) where to place"
msgstr ""

#: ../../taichi/docs/snode.rst:23
msgid "(ti.field) field(s) to be placed"
msgstr ""

#: ../../taichi/docs/snode.rst:24
msgid "(SNode) the ``snode`` itself"
msgstr ""

#: ../../taichi/docs/snode.rst:26
msgid "The following code places two 0-D fields named ``x`` and ``y``:"
msgstr ""

#: ../../taichi/docs/snode.rst:30
msgid ""
"x = ti.field(dtype=ti.i32)\n"
"y = ti.field(dtype=ti.f32)\n"
"ti.root.place(x, y)\n"
"assert x.snode == y.snode"
msgstr ""

#: ../../taichi/docs/snode.rst:38 ../../taichi/docs/snode.rst:53
msgid "(ti.field)"
msgstr ""

#: ../../taichi/docs/snode.rst:39
msgid "(tuple of integers) the shape of field"
msgstr ""

#: ../../taichi/docs/snode.rst:41
msgid "Equivalent to ``field.snode.shape``."
msgstr ""

#: ../../taichi/docs/snode.rst:47
msgid ""
"ti.root.dense(ti.ijk, (3, 5, 4)).place(x)\n"
"x.shape  # returns (3, 5, 4)"
msgstr ""

#: ../../taichi/docs/snode.rst:54
msgid "(SNode) the structual node where ``field`` is placed"
msgstr ""

#: ../../taichi/docs/snode.rst:58
msgid ""
"x = ti.field(dtype=ti.i32)\n"
"y = ti.field(dtype=ti.f32)\n"
"blk1 = ti.root.dense(ti.i, 4)\n"
"blk1.place(x, y)\n"
"assert x.snode == blk1"
msgstr ""

#: ../../taichi/docs/snode.rst:67 ../../taichi/docs/snode.rst:84
msgid "(SNode)"
msgstr ""

#: ../../taichi/docs/snode.rst:68
msgid "(tuple) the size of node along that axis"
msgstr ""

#: ../../taichi/docs/snode.rst:72
msgid ""
"blk1 = ti.root\n"
"blk2 = blk1.dense(ti.i,  3)\n"
"blk3 = blk2.dense(ti.jk, (5, 2))\n"
"blk4 = blk3.dense(ti.k,  2)\n"
"blk1.shape  # ()\n"
"blk2.shape  # (3, )\n"
"blk3.shape  # (3, 5, 2)\n"
"blk4.shape  # (3, 5, 4)"
msgstr ""

#: ../../taichi/docs/snode.rst:85
msgid ""
"(optional, scalar) the number of steps, i.e. ``n=1`` for parent, ``n=2`` "
"grandparent, etc."
msgstr ""

#: ../../taichi/docs/snode.rst:86
msgid "(SNode) the parent node of ``snode``"
msgstr ""

#: ../../taichi/docs/snode.rst:90
msgid ""
"blk1 = ti.root.dense(ti.i, 8)\n"
"blk2 = blk1.dense(ti.j, 4)\n"
"blk3 = blk2.bitmasked(ti.k, 6)\n"
"blk1.parent()  # ti.root\n"
"blk2.parent()  # blk1\n"
"blk3.parent()  # blk2\n"
"blk3.parent(1) # blk2\n"
"blk3.parent(2) # blk1\n"
"blk3.parent(3) # ti.root\n"
"blk3.parent(4) # None"
msgstr ""

#: ../../taichi/docs/snode.rst:103
msgid "Node types"
msgstr ""

#: ../../taichi/docs/snode.rst:108 ../../taichi/docs/snode.rst:145
msgid "(SNode) parent node where the child is derived from"
msgstr ""

#: ../../taichi/docs/snode.rst:109
msgid "(Index or Indices) indices used for this node"
msgstr ""

#: ../../taichi/docs/snode.rst:110
msgid "(scalar or tuple) shape of the field"
msgstr ""

#: ../../taichi/docs/snode.rst:111 ../../taichi/docs/snode.rst:149
msgid "(SNode) the derived child node"
msgstr ""

#: ../../taichi/docs/snode.rst:113
msgid "The following code places a 1-D field of size ``3``:"
msgstr ""

#: ../../taichi/docs/snode.rst:117
msgid ""
"x = ti.field(dtype=ti.i32)\n"
"ti.root.dense(ti.i, 3).place(x)"
msgstr ""

#: ../../taichi/docs/snode.rst:120
msgid "The following code places a 2-D field of shape ``(3, 4)``:"
msgstr ""

#: ../../taichi/docs/snode.rst:124
msgid ""
"x = ti.field(dtype=ti.i32)\n"
"ti.root.dense(ti.ij, (3, 4)).place(x)"
msgstr ""

#: ../../taichi/docs/snode.rst:129
msgid ""
"If ``shape`` is a scalar and there are multiple indices, then ``shape`` "
"will be automatically expanded to fit the number of indices. For example,"
msgstr ""

#: ../../taichi/docs/snode.rst:134
msgid "snode.dense(ti.ijk, 3)"
msgstr ""

#: ../../taichi/docs/snode.rst:136
msgid "is equivalent to"
msgstr ""

#: ../../taichi/docs/snode.rst:140
msgid "snode.dense(ti.ijk, (3, 3, 3))"
msgstr ""

#: ../../taichi/docs/snode.rst:146
msgid "(Index) the ``dynamic`` node indices"
msgstr ""

#: ../../taichi/docs/snode.rst:147
msgid "(scalar) the maximum size of the dynamic node"
msgstr ""

#: ../../taichi/docs/snode.rst:148
msgid ""
"(optional, scalar) the number of elements in each dynamic memory "
"allocation chunk"
msgstr ""

#: ../../taichi/docs/snode.rst:151
msgid ""
"``dynamic`` nodes acts like ``std::vector`` in C++ or ``list`` in Python."
" Taichi's dynamic memory allocation system allocates its memory on the "
"fly."
msgstr ""

#: ../../taichi/docs/snode.rst:154
msgid "The following places a 1-D dynamic field of maximum size ``16``:"
msgstr ""

#: ../../taichi/docs/snode.rst:158
msgid "ti.root.dynamic(ti.i, 16).place(x)"
msgstr ""

#: ../../taichi/docs/snode.rst:166
msgid "TODO: add descriptions here"
msgstr ""

#: ../../taichi/docs/snode.rst:171
msgid "Working with ``dynamic`` SNodes"
msgstr ""

#: ../../taichi/docs/snode.rst:175 ../../taichi/docs/snode.rst:182
msgid "(SNode, dynamic)"
msgstr ""

#: ../../taichi/docs/snode.rst:176 ../../taichi/docs/snode.rst:183
msgid "(scalar or tuple of scalars) the ``dynamic`` node indices"
msgstr ""

#: ../../taichi/docs/snode.rst:177
msgid "(int32) the current size of the dynamic node"
msgstr ""

#: ../../taichi/docs/snode.rst:184
msgid "(depends on SNode data type) value to store"
msgstr ""

#: ../../taichi/docs/snode.rst:185
msgid "(int32) the size of the dynamic node, before appending"
msgstr ""

#: ../../taichi/docs/snode.rst:187
msgid "Inserts ``val`` into the ``dynamic`` node with indices ``indices``."
msgstr ""

#: ../../taichi/docs/snode.rst:191
msgid "Taichi fields like powers of two"
msgstr ""

#: ../../taichi/docs/snode.rst:193
msgid ""
"Non-power-of-two field dimensions are promoted into powers of two and "
"thus these fields will occupy more virtual address space. For example, a "
"(dense) field of size ``(18, 65)`` will be materialized as ``(32, 128)``."
msgstr ""

#: ../../taichi/docs/snode.rst:198
msgid "Indices"
msgstr ""

#: ../../taichi/docs/snode.rst:213
msgid "(TODO)"
msgstr ""

#: ../../taichi/docs/sparse.rst:4
msgid "Sparse computation (WIP)"
msgstr ""

#: ../../taichi/docs/sparse.rst:8
msgid ""
"The Taichi compiler backend is under migration from source-to-source "
"compilation to LLVM for compilation speed and portability. Sparse "
"computation with the new LLVM backend is not yet fully implemented on "
"multithreaded CPUs and GPUs."
msgstr ""

#: ../../taichi/docs/sparse.rst:11
msgid ""
"If you are interested in sparse computation in Taichi, please read our "
"`paper <http://taichi.graphics/wp-"
"content/uploads/2019/09/taichi_lang.pdf>`_, watch the `introduction video"
" <https://www.youtube.com/watch?v=wKw8LMF3Djo>`_, or check out the "
"SIGGRAPH Asia 2019 `slides <http://taichi.graphics/wp-"
"content/uploads/2019/12/taichi_slides.pdf>`_."
msgstr ""

#: ../../taichi/docs/sparse.rst:14
msgid ""
"The legacy source-to-source backend (commit ``dc162e11``) provides full "
"sparse computation functionality. However, since little engineering has "
"been done to make that commit portable (i.e. easy to compile on different"
" platforms), we suggest waiting until the LLVM version of sparse "
"computation is fully implemented."
msgstr ""

#: ../../taichi/docs/sparse.rst:17
msgid ""
"Sparse computation functionalities with the new LLVM backend will be back"
" online by the end of December 2019."
msgstr ""

#: ../../taichi/docs/syntax.rst:2
msgid "Syntax"
msgstr ""

#: ../../taichi/docs/syntax.rst:5
msgid "Taichi-scope vs Python-scope"
msgstr ""

#: ../../taichi/docs/syntax.rst:7
msgid ""
"Code decorated by ``@ti.kernel`` or ``@ti.func`` is in the **Taichi-"
"scope**."
msgstr ""

#: ../../taichi/docs/syntax.rst:9
msgid ""
"They are to be compiled and executed on CPU or GPU devices with high "
"parallelization performance, on the cost of less flexibility."
msgstr ""

#: ../../taichi/docs/syntax.rst:14
msgid "For people from CUDA, Taichi-scope = **device** side."
msgstr ""

#: ../../taichi/docs/syntax.rst:17
msgid "Code outside ``@ti.kernel`` or ``@ti.func`` is in the **Python-scope**."
msgstr ""

#: ../../taichi/docs/syntax.rst:19
msgid ""
"They are not compiled by the Taichi compiler and have lower performance "
"but with a richer type system and better flexibility."
msgstr ""

#: ../../taichi/docs/syntax.rst:24
msgid "For people from CUDA, Python-scope = **host** side."
msgstr ""

#: ../../taichi/docs/syntax.rst:28
msgid "Kernels"
msgstr ""

#: ../../taichi/docs/syntax.rst:30
msgid "A Python function decorated by ``@ti.kernel`` is a **Taichi kernel**:"
msgstr ""

#: ../../taichi/docs/syntax.rst:32
msgid ""
"@ti.kernel\n"
"def my_kernel():\n"
"    ...\n"
"\n"
"my_kernel()"
msgstr ""

#: ../../taichi/docs/syntax.rst:41
msgid "Kernels should be called from **Python-scope**."
msgstr ""

#: ../../taichi/docs/syntax.rst:45
msgid "For people from CUDA, Taichi kernels = ``__global__`` functions."
msgstr ""

#: ../../taichi/docs/syntax.rst:49
msgid "Arguments"
msgstr ""

#: ../../taichi/docs/syntax.rst:51
msgid ""
"Kernels can have at most 8 parameters so that you can pass values from "
"Python-scope to Taichi-scope easily."
msgstr ""

#: ../../taichi/docs/syntax.rst:54
msgid "Kernel arguments must be type-hinted:"
msgstr ""

#: ../../taichi/docs/syntax.rst:56
msgid ""
"@ti.kernel\n"
"def my_kernel(x: ti.i32, y: ti.f32):\n"
"    print(x + y)\n"
"\n"
"my_kernel(2, 3.3)  # prints: 5.3"
msgstr ""

#: ../../taichi/docs/syntax.rst:66
msgid ""
"For now, we only support scalars as arguments. Specifying ``ti.Matrix`` "
"or ``ti.Vector`` as argument is not supported. For example:"
msgstr ""

#: ../../taichi/docs/syntax.rst:68
msgid ""
"@ti.kernel\n"
"def bad_kernel(v: ti.Vector):\n"
"    ...\n"
"\n"
"@ti.kernel\n"
"def good_kernel(vx: ti.f32, vy: ti.f32):\n"
"    v = ti.Vector([vx, vy])\n"
"    ..."
msgstr ""

#: ../../taichi/docs/syntax.rst:81
msgid "Return value"
msgstr ""

#: ../../taichi/docs/syntax.rst:83
msgid ""
"A kernel may or may not have a **scalar** return value. If it does, the "
"type of return value must be hinted:"
msgstr ""

#: ../../taichi/docs/syntax.rst:86
msgid ""
"@ti.kernel\n"
"def my_kernel() -> ti.f32:\n"
"    return 233.33\n"
"\n"
"print(my_kernel())  # 233.33"
msgstr ""

#: ../../taichi/docs/syntax.rst:95
msgid "The return value will be automatically cast into the hinted type. e.g.,"
msgstr ""

#: ../../taichi/docs/syntax.rst:97
msgid ""
"@ti.kernel\n"
"def add_xy() -> ti.i32:  # int32\n"
"    return 233.33\n"
"\n"
"print(my_kernel())  # 233, since return type is ti.i32"
msgstr ""

#: ../../taichi/docs/syntax.rst:108
msgid ""
"For now, a kernel can only have one scalar return value. Returning "
"``ti.Matrix`` or ``ti.Vector`` is not supported. Python-style tuple "
"return is not supported either. For example:"
msgstr ""

#: ../../taichi/docs/syntax.rst:110
msgid ""
"@ti.kernel\n"
"def bad_kernel() -> ti.Matrix:\n"
"    return ti.Matrix([[1, 0], [0, 1]])  # Error\n"
"\n"
"@ti.kernel\n"
"def bad_kernel() -> (ti.i32, ti.f32):\n"
"    x = 1\n"
"    y = 0.5\n"
"    return x, y  # Error"
msgstr ""

#: ../../taichi/docs/syntax.rst:124 ../../taichi/docs/syntax.rst:211
msgid "Advanced arguments"
msgstr ""

#: ../../taichi/docs/syntax.rst:126
msgid ""
"We also support **template arguments** (see "
":ref:`template_metaprogramming`) and **external array arguments** (see "
":ref:`external`) in Taichi kernels.  Use ``ti.template()`` or "
"``ti.ext_arr()`` as their type-hints respectively."
msgstr ""

#: ../../taichi/docs/syntax.rst:130
msgid ""
"When using differentiable programming, there are a few more constraints "
"on kernel structures. See the **Kernel Simplicity Rule** in "
":ref:`differentiable`."
msgstr ""

#: ../../taichi/docs/syntax.rst:132
msgid ""
"Also, please do not use kernel return values in differentiable "
"programming, since the return value will not be tracked by automatic "
"differentiation. Instead, store the result into a global variable (e.g. "
"``loss[None]``)."
msgstr ""

#: ../../taichi/docs/syntax.rst:136
msgid "Functions"
msgstr ""

#: ../../taichi/docs/syntax.rst:138
msgid "A Python function decorated by ``@ti.func`` is a **Taichi function**:"
msgstr ""

#: ../../taichi/docs/syntax.rst:140
msgid ""
"@ti.func\n"
"def my_func():\n"
"    ...\n"
"\n"
"@ti.kernel\n"
"def my_kernel():\n"
"    ...\n"
"    my_func()  # call functions from Taichi-scope\n"
"    ...\n"
"\n"
"my_kernel()    # call kernels from Python-scope"
msgstr ""

#: ../../taichi/docs/syntax.rst:155
msgid "Taichi functions should be called from **Taichi-scope**."
msgstr ""

#: ../../taichi/docs/syntax.rst:159
msgid "For people from CUDA, Taichi functions = ``__device__`` functions."
msgstr ""

#: ../../taichi/docs/syntax.rst:163
msgid "Taichi functions can be nested."
msgstr ""

#: ../../taichi/docs/syntax.rst:167
msgid ""
"Currently, all functions are force-inlined. Therefore, no recursion is "
"allowed."
msgstr ""

#: ../../taichi/docs/syntax.rst:171
msgid "Arguments and return values"
msgstr ""

#: ../../taichi/docs/syntax.rst:173
msgid ""
"Functions can have multiple arguments and return values. Unlike kernels, "
"arguments in functions don't need to be type-hinted:"
msgstr ""

#: ../../taichi/docs/syntax.rst:176
msgid ""
"@ti.func\n"
"def my_add(x, y):\n"
"    return x + y\n"
"\n"
"\n"
"@ti.kernel\n"
"def my_kernel():\n"
"    ...\n"
"    ret = my_add(2, 3.3)\n"
"    print(ret)  # 5.3\n"
"    ..."
msgstr ""

#: ../../taichi/docs/syntax.rst:191
msgid ""
"Function arguments are passed by value. So changes made inside function "
"scope won't affect the outside value in the caller:"
msgstr ""

#: ../../taichi/docs/syntax.rst:194
msgid ""
"@ti.func\n"
"def my_func(x):\n"
"    x = x + 1  # won't change the original value of x\n"
"\n"
"\n"
"@ti.kernel\n"
"def my_kernel():\n"
"    ...\n"
"    x = 233\n"
"    my_func(x)\n"
"    print(x)  # 233\n"
"    ..."
msgstr ""

#: ../../taichi/docs/syntax.rst:213
msgid ""
"You may use ``ti.template()`` as type-hint to force arguments to be "
"passed by reference:"
msgstr ""

#: ../../taichi/docs/syntax.rst:216
msgid ""
"@ti.func\n"
"def my_func(x: ti.template()):\n"
"    x = x + 1  # will change the original value of x\n"
"\n"
"\n"
"@ti.kernel\n"
"def my_kernel():\n"
"    ...\n"
"    x = 233\n"
"    my_func(x)\n"
"    print(x)  # 234\n"
"    ..."
msgstr ""

#: ../../taichi/docs/syntax.rst:234
msgid ""
"Unlike kernels, functions **do support vectors or matrices as arguments "
"and return values**:"
msgstr ""

#: ../../taichi/docs/syntax.rst:236
msgid ""
"@ti.func\n"
"def sdf(u):  # functions support matrices and vectors as arguments. No "
"type-hints needed.\n"
"    return u.norm() - 1\n"
"\n"
"@ti.kernel\n"
"def render(d_x: ti.f32, d_y: ti.f32):  # kernels do not support "
"vector/matrix arguments yet. We have to use a workaround.\n"
"    d = ti.Vector([d_x, d_y])\n"
"    p = ti.Vector([0.0, 0.0])\n"
"    t = sdf(p)\n"
"    p += d * t\n"
"    ..."
msgstr ""

#: ../../taichi/docs/syntax.rst:252
msgid ""
"Functions with multiple ``return`` statements are not supported for now. "
"Use a **local** variable to store the results, so that you end up with "
"only one ``return`` statement:"
msgstr ""

#: ../../taichi/docs/syntax.rst:254
msgid ""
"# Bad function - two return statements\n"
"@ti.func\n"
"def safe_sqrt(x):\n"
"  if x >= 0:\n"
"    return ti.sqrt(x)\n"
"  else:\n"
"    return 0.0\n"
"\n"
"# Good function - single return statement\n"
"@ti.func\n"
"def safe_sqrt(x):\n"
"  ret = 0.0\n"
"  if x >= 0:\n"
"    ret = ti.sqrt(x)\n"
"  else:\n"
"    ret = 0.0\n"
"  return ret"
msgstr ""

#: ../../taichi/docs/syntax.rst:276
msgid "Scalar arithmetics"
msgstr ""

#: ../../taichi/docs/syntax.rst:278
msgid "Supported scalar functions:"
msgstr ""

#: ../../taichi/docs/syntax.rst:304
msgid ""
"Python 3 distinguishes ``/`` (true division) and ``//`` (floor division)."
" For example, ``1.0 / 2.0 = 0.5``, ``1 / 2 = 0.5``, ``1 // 2 = 0``, ``4.2"
" // 2 = 2``. Taichi follows this design:"
msgstr ""

#: ../../taichi/docs/syntax.rst:307
msgid ""
"**true divisions** on integral types will first cast their operands to "
"the default float point type."
msgstr ""

#: ../../taichi/docs/syntax.rst:308
msgid ""
"**floor divisions** on float-point types will first cast their operands "
"to the default integer type."
msgstr ""

#: ../../taichi/docs/syntax.rst:310
msgid ""
"To avoid such implicit casting, you can manually cast your operands to "
"desired types, using ``ti.cast``. See :ref:`default_precisions` for more "
"details on default numerical types."
msgstr ""

#: ../../taichi/docs/syntax.rst:315
msgid ""
"When these scalar functions are applied on :ref:`matrix` and "
":ref:`vector`, they are applied in an element-wise manner. For example:"
msgstr ""

#: ../../taichi/docs/syntax.rst:318
msgid ""
"B = ti.Matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n"
"C = ti.Matrix([[3.0, 4.0, 5.0], [6.0, 7.0, 8.0]])\n"
"\n"
"A = ti.sin(B)\n"
"# is equivalent to\n"
"for i in ti.static(range(2)):\n"
"    for j in ti.static(range(3)):\n"
"        A[i, j] = ti.sin(B[i, j])\n"
"\n"
"A = ti.pow(B, 2)\n"
"# is equivalent to\n"
"for i in ti.static(range(2)):\n"
"    for j in ti.static(range(3)):\n"
"        A[i, j] = ti.pow(B[i, j], 2)\n"
"\n"
"A = ti.pow(B, C)\n"
"# is equivalent to\n"
"for i in ti.static(range(2)):\n"
"    for j in ti.static(range(3)):\n"
"        A[i, j] = ti.pow(B[i, j], C[i, j])\n"
"\n"
"A += 2\n"
"# is equivalent to\n"
"for i in ti.static(range(2)):\n"
"    for j in ti.static(range(3)):\n"
"        A[i, j] += 2\n"
"\n"
"A += B\n"
"# is equivalent to\n"
"for i in ti.static(range(2)):\n"
"    for j in ti.static(range(3)):\n"
"        A[i, j] += B[i, j]"
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:2
msgid "Syntax sugars"
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:5
msgid "Aliases"
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:7
msgid ""
"Creating aliases for global variables and functions with cumbersome names"
" can sometimes improve readability. In Taichi, this can be done by "
"assigning kernel and function local variables with ``ti.static()``, which"
" forces Taichi to use standard python pointer assignment."
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:9
msgid "For example, consider the simple kernel:"
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:11
msgid ""
"@ti.kernel\n"
"def my_kernel():\n"
"  for i, j in field_a:\n"
"    field_b[i, j] = some_function(field_a[i, j])"
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:18
msgid "The fields and function be aliased to new names with ``ti.static``:"
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:20
msgid ""
"@ti.kernel\n"
"def my_kernel():\n"
"  a, b, fun = ti.static(field_a, field_b, some_function)\n"
"  for i,j in a:\n"
"    b[i,j] = fun(a[i,j])"
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:30
msgid ""
"Aliases can also be created for class members and methods, which can help"
" prevent cluttering objective data-oriented programming code with "
"``self``."
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:32
msgid ""
"For example, consider class kernel to compute the 2-D laplacian of some "
"field:"
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:34
msgid ""
"@ti.kernel\n"
"def compute_laplacian(self):\n"
"  for i, j in a:\n"
"    self.b[i, j] = (self.a[i + 1,j] - 2.0*self.a[i, j] + self.a[i-1, "
"j])/(self.dx**2) \\\n"
"                + (self.a[i,j + 1] - 2.0*self.a[i, j] + self.a[i, "
"j-1])/(self.dy**2)"
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:42
msgid "Using ``ti.static()``, it can be simplified to:"
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:44
msgid ""
"@ti.kernel\n"
"def compute_laplacian(self):\n"
"  a,b,dx,dy = ti.static(self.a,self.b,self.dx,self.dy)\n"
"  for i,j in a:\n"
"    b[i,j] = (a[i+1, j] - 2.0*a[i, j] + a[i-1, j])/(dx**2) \\\n"
"           + (a[i, j+1] - 2.0*a[i, j] + a[i, j-1])/(dy**2)"
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:55
msgid ""
"``ti.static`` can also be used in combination with ``if`` (compile-time "
"branching) and ``for`` (compile-time unrolling). See :ref:`meta` for more"
" details."
msgstr ""

#: ../../taichi/docs/syntax_sugars.rst:57
msgid ""
"Here, we are using it for *compile-time const values*, i.e. the "
"**field/function handles** are constants at compile time."
msgstr ""

#: ../../taichi/docs/taichicon.rst:2
msgid "TaichiCon"
msgstr ""

#: ../../taichi/docs/taichicon.rst:4
msgid ""
"We are hosting a series of online **TaichiCon** events for developers to "
"gather and share their Taichi experiences."
msgstr ""

#: ../../taichi/docs/taichicon.rst:7
msgid "Past Conferences"
msgstr ""

#: ../../taichi/docs/taichicon.rst:9
msgid ""
"Everything on previous TaichiCons is available in the `TaichiCon "
"<https://github.com/taichi-dev/taichicon>`_ repository."
msgstr ""

#: ../../taichi/docs/taichicon.rst:12
msgid "Format"
msgstr ""

#: ../../taichi/docs/taichicon.rst:14
msgid "Each TaichiCon consists of two parts: **talks** and **free discussions**."
msgstr ""

#: ../../taichi/docs/taichicon.rst:16
msgid "The first 1-hour consists of four 10-minute talks, each with 5-minute Q&A;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:18
msgid ""
"After the formal talks, attendees are free to chat about Taichi in any "
"aspects."
msgstr ""

#: ../../taichi/docs/taichicon.rst:20
msgid "The conference format may evolve in the future."
msgstr ""

#: ../../taichi/docs/taichicon.rst:23
msgid "Language"
msgstr ""

#: ../../taichi/docs/taichicon.rst:25
msgid "The ``i``-th TaichiCon will be hosted in"
msgstr ""

#: ../../taichi/docs/taichicon.rst:27
msgid "English ``(if i % 2 == 1)``;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:28
msgid "Chinese (Mandarin) ``(if i % 2 == 0)``."
msgstr ""

#: ../../taichi/docs/taichicon.rst:31
msgid "Time and frequency"
msgstr ""

#: ../../taichi/docs/taichicon.rst:33
msgid ""
"Taichi developers are scattered around the world, so it's important to "
"pick a good time so that people in different time zones can attend."
msgstr ""

#: ../../taichi/docs/taichicon.rst:36
msgid "A good time for people in Asia and the U.S.:"
msgstr ""

#: ../../taichi/docs/taichicon.rst:38
msgid "(China, Beijing) Sunday 10:00 - 11:00"
msgstr ""

#: ../../taichi/docs/taichicon.rst:39
msgid "(Japan, Tokyo) Sunday 11:00 - 12:00"
msgstr ""

#: ../../taichi/docs/taichicon.rst:40
msgid "(New Zealand, Wellington) Sunday 14:00 - 15:00"
msgstr ""

#: ../../taichi/docs/taichicon.rst:41
msgid "(U.S., East coast) Saturday 22:00 - 23:00"
msgstr ""

#: ../../taichi/docs/taichicon.rst:42
msgid "(U.S., West coast) Saturday 19:00 - 20:00"
msgstr ""

#: ../../taichi/docs/taichicon.rst:44
msgid ""
"For people in Europe, we may need to find a better time. There is "
"probably no perfect solution, so it may make sense to pick different "
"times for TaichiCons to provide equal opportunities to people around the "
"world."
msgstr ""

#: ../../taichi/docs/taichicon.rst:47
msgid "TaichiCon will be hosted roughly once per month."
msgstr ""

#: ../../taichi/docs/taichicon.rst:50
msgid "Attending TaichiCon"
msgstr ""

#: ../../taichi/docs/taichicon.rst:52
msgid ""
"Everyone interested in Taichi or related topics (computer graphics, "
"compilers, high-performance computing, computational fluid dynamics, "
"etc.) is welcome to participate!"
msgstr ""

#: ../../taichi/docs/taichicon.rst:55
msgid "The Zoom meeting room has a capacity of 300 participants. A few tips:"
msgstr ""

#: ../../taichi/docs/taichicon.rst:57
msgid ""
"It's recommended to change your Zoom display name to a uniform ``name "
"(company)`` format. For example, ``Yuanming Hu (MIT CSAIL)``;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:58
msgid "Please keep muted during the talks to avoid background noises;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:59
msgid "If you have questions, feel free to raise them in the chat window;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:60
msgid "Video recordings and slides will be uploaded after the conference;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:61
msgid ""
"Usually people do not open their cameras during TaichiCon to save network"
" bandwidth for people in unsatisfactory network conditions."
msgstr ""

#: ../../taichi/docs/taichicon.rst:65
msgid "Preparing for a talk at TaichiCon"
msgstr ""

#: ../../taichi/docs/taichicon.rst:67
msgid "We welcome any topics about Taichi, including but not limited to"
msgstr ""

#: ../../taichi/docs/taichicon.rst:69
msgid ""
"API proposals (e.g., \"I think the ``Matrix`` class needs to be "
"refactored. Here are my thoughts ...\")"
msgstr ""

#: ../../taichi/docs/taichicon.rst:70
msgid ""
"Applications (e.g., \"I wrote a new fluid solver using Taichi and would "
"like to share ...\")"
msgstr ""

#: ../../taichi/docs/taichicon.rst:71
msgid "Integrations (e.g., \"Here's how I integrated Taichi into Blender ...\")"
msgstr ""

#: ../../taichi/docs/taichicon.rst:72
msgid "Internal designs (e.g., \"How a new backend is implemented\")"
msgstr ""

#: ../../taichi/docs/taichicon.rst:75
msgid ""
"The body of a TaichiCon talk should be 10 min. After each talk, there are"
" 5 minutes for Q & A. The host may stop the talk if a speaker's talk "
"lasts beyond 15 minutes."
msgstr ""

#: ../../taichi/docs/taichicon.rst:81
msgid "Organizing TaichiCon"
msgstr ""

#: ../../taichi/docs/taichicon.rst:83
msgid "Before the conference:"
msgstr ""

#: ../../taichi/docs/taichicon.rst:85
msgid "Pick a nice time for the event;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:86
msgid ""
"Invite speakers: ask for a talk **title**, **abstract**, and a brief "
"**speaker introduction**;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:87
msgid "Advertise the event on social networks (Facebook, Twitter, Zhihu etc.);"
msgstr ""

#: ../../taichi/docs/taichicon.rst:88
msgid ""
"Make sure all speakers are already in the (virtual) conference room 10 "
"minutes before the conference begins;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:90
msgid "If a speaker does not show up, try to remind him to attend via email."
msgstr ""

#: ../../taichi/docs/taichicon.rst:92
msgid "Hosting the conference:"
msgstr ""

#: ../../taichi/docs/taichicon.rst:94
msgid "Make sure the Zoom session is being recorded;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:95
msgid "Remember to welcome everyone to attend :-)"
msgstr ""

#: ../../taichi/docs/taichicon.rst:96
msgid "Before each talk, introduce the speaker;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:97
msgid "In the end, thank all the speakers and attendees."
msgstr ""

#: ../../taichi/docs/taichicon.rst:99
msgid "After the conference:"
msgstr ""

#: ../../taichi/docs/taichicon.rst:101
msgid "Upload the video to Youtube and Bilibili;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:102
msgid "Collect speakers' slides in PDF format;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:104
msgid ""
"Make a representative image with screenshots of the first slides of all "
"the talks;"
msgstr ""

#: ../../taichi/docs/taichicon.rst:107
msgid ""
"Update the `TaichiCon <https://github.com/taichi-dev/taichicon>`_ "
"repository following the format of TaichiCon 0."
msgstr ""

#: ../../taichi/docs/taichicon.rst:108
msgid ""
"Update this documentation page if you find any opportunities to improve "
"the workflow of TaichiCon."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:4
msgid "Fields and matrices"
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:6
msgid ""
"Fields are global variables provided by Taichi. Fields can be either "
"sparse or dense. An element of a field can be either a scalar or a "
"vector/matrix."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:11
msgid ""
"Matrices can be used as field elements, so you can have fields with each "
"element being a matrix."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:15
msgid "Every global variable is an N-dimensional field."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:17
msgid "Global ``scalars`` are treated as 0-D scalar fields."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:19
msgid "Fields are always accessed using indices"
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:21
msgid "E.g. ``x[i, j, k]`` if ``x`` is a 3D scalar field."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:22
msgid ""
"Even when accessing 0-D field ``x``, use ``x[None] = 0`` instead of ``x ="
" 0``. Please **always** use indexing to access entries in fields."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:24
msgid "Field values are initially zero."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:25
msgid "Sparse fields are initially inactive."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:30
msgid "Matrix fields"
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:31
msgid "Field elements can also be matrices."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:33
msgid ""
"Suppose you have a ``128 x 64`` field called ``A``, each element "
"containing a ``3 x 2`` matrix. To allocate a ``128 x 64`` matrix field "
"which has a ``3 x 2`` matrix for each of its entry, use the statement ``A"
" = ti.Matrix.field(3, 2, dtype=ti.f32, shape=(128, 64))``."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:35
msgid ""
"If you want to get the matrix of grid node ``i, j``, please use ``mat = "
"A[i, j]``. ``mat`` is simply a ``3 x 2`` matrix"
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:36
msgid ""
"To get the element on the first row and second column of that matrix, use"
" ``mat[0, 1]`` or ``A[i, j][0, 1]``."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:37
msgid ""
"As you may have noticed, there are **two** indexing operators ``[]`` when"
" you load an matrix element from a global matrix field: the first is for "
"field indexing, the second for matrix indexing."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:38
msgid "``ti.Vector`` is simply an alias of ``ti.Matrix``."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:39
msgid "See :ref:`matrix` for more on matrices."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:43
msgid "Matrix size"
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:44
msgid ""
"For performance reasons matrix operations will be unrolled, therefore we "
"suggest using only small matrices. For example, ``2x1``, ``3x3``, ``4x4``"
" matrices are fine, yet ``32x6`` is probably too big as a matrix size."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:49
msgid ""
"Due to the unrolling mechanisms, operating on large matrices (e.g. "
"``32x128``) can lead to very long compilation time and low performance."
msgstr ""

#: ../../taichi/docs/tensor_matrix.rst:51
msgid ""
"If you have a dimension that is too large (e.g. ``64``), it's better to "
"declare a field of size ``64``. E.g., instead of declaring "
"``ti.Matrix.field(64, 32, dtype=ti.f32, shape=(3, 2))``, declare "
"``ti.Matrix.field(3, 2, dtype=ti.f32, shape=(64, 32))``. Try to put large"
" dimensions to fields instead of matrices."
msgstr ""

#: ../../taichi/docs/type.rst:2
msgid "Type system"
msgstr ""

#: ../../taichi/docs/type.rst:4
msgid ""
"Taichi supports common numerical data types. Each type is denoted as a "
"character indicating its *category* and a number of *precision bits*, "
"e.g., ``i32`` and ``f64``."
msgstr ""

#: ../../taichi/docs/type.rst:7
msgid "The *category* can be one of:"
msgstr ""

#: ../../taichi/docs/type.rst:9
msgid "``i`` for signed integers, e.g. 233, -666"
msgstr ""

#: ../../taichi/docs/type.rst:10
msgid "``u`` for unsigned integers, e.g. 233, 666"
msgstr ""

#: ../../taichi/docs/type.rst:11
msgid "``f`` for floating point numbers, e.g. 2.33, 1e-4"
msgstr ""

#: ../../taichi/docs/type.rst:13
msgid "The *digital number* can be one of:"
msgstr ""

#: ../../taichi/docs/type.rst:15
msgid "``8``"
msgstr ""

#: ../../taichi/docs/type.rst:16
msgid "``16``"
msgstr ""

#: ../../taichi/docs/type.rst:17
msgid "``32``"
msgstr ""

#: ../../taichi/docs/type.rst:18
msgid "``64``"
msgstr ""

#: ../../taichi/docs/type.rst:20
msgid ""
"It represents how many **bits** are used in storing the data. The larger "
"the bit number, the higher the precision is."
msgstr ""

#: ../../taichi/docs/type.rst:23
msgid "For example, the two most commonly used types:"
msgstr ""

#: ../../taichi/docs/type.rst:25
msgid "``i32`` represents a 32-bit signed integer."
msgstr ""

#: ../../taichi/docs/type.rst:26
msgid "``f32`` represents a 32-bit floating pointer number."
msgstr ""

#: ../../taichi/docs/type.rst:29
msgid "Supported types"
msgstr ""

#: ../../taichi/docs/type.rst:31
msgid "Currently, supported basic types in Taichi are"
msgstr ""

#: ../../taichi/docs/type.rst:33
msgid "int8 ``ti.i8``"
msgstr ""

#: ../../taichi/docs/type.rst:34
msgid "int16 ``ti.i16``"
msgstr ""

#: ../../taichi/docs/type.rst:35
msgid "int32 ``ti.i32``"
msgstr ""

#: ../../taichi/docs/type.rst:36
msgid "int64 ``ti.i64``"
msgstr ""

#: ../../taichi/docs/type.rst:37
msgid "uint8 ``ti.u8``"
msgstr ""

#: ../../taichi/docs/type.rst:38
msgid "uint16 ``ti.u16``"
msgstr ""

#: ../../taichi/docs/type.rst:39
msgid "uint32 ``ti.u32``"
msgstr ""

#: ../../taichi/docs/type.rst:40
msgid "uint64 ``ti.u64``"
msgstr ""

#: ../../taichi/docs/type.rst:41
msgid "float32 ``ti.f32``"
msgstr ""

#: ../../taichi/docs/type.rst:42
msgid "float64 ``ti.f64``"
msgstr ""

#: ../../taichi/docs/type.rst:45
msgid "Supported types on each backend:"
msgstr ""

#: ../../taichi/docs/type.rst:50
msgid "i8"
msgstr ""

#: ../../taichi/docs/type.rst:52
msgid "i16"
msgstr ""

#: ../../taichi/docs/type.rst:54
msgid "i32"
msgstr ""

#: ../../taichi/docs/type.rst:56
msgid "i64"
msgstr ""

#: ../../taichi/docs/type.rst:58
msgid "u8"
msgstr ""

#: ../../taichi/docs/type.rst:60
msgid "u16"
msgstr ""

#: ../../taichi/docs/type.rst:62
msgid "u32"
msgstr ""

#: ../../taichi/docs/type.rst:64
msgid "u64"
msgstr ""

#: ../../taichi/docs/type.rst:66
msgid "f32"
msgstr ""

#: ../../taichi/docs/type.rst:68
msgid "f64"
msgstr ""

#: ../../taichi/docs/type.rst:71
msgid "(OK: supported, EXT: require extension, N/A: not available)"
msgstr ""

#: ../../taichi/docs/type.rst:76
msgid "Boolean types are represented using ``ti.i32``."
msgstr ""

#: ../../taichi/docs/type.rst:81
msgid "Type promotion"
msgstr ""

#: ../../taichi/docs/type.rst:83
msgid ""
"Binary operations on different types will give you a promoted type, "
"following the C programming language convention, e.g.:"
msgstr ""

#: ../../taichi/docs/type.rst:85
msgid "``i32 + f32 = f32`` (integer + float = float)"
msgstr ""

#: ../../taichi/docs/type.rst:86
msgid "``i32 + i64 = i64`` (less-bits + more-bits = more-bits)"
msgstr ""

#: ../../taichi/docs/type.rst:88
msgid ""
"Basically it will try to choose the more precise type to contain the "
"result value."
msgstr ""

#: ../../taichi/docs/type.rst:94
msgid "Default precisions"
msgstr ""

#: ../../taichi/docs/type.rst:96
msgid ""
"By default, all numerical literals have 32-bit precisions. For example, "
"``42`` has type ``ti.i32`` and ``3.14`` has type ``ti.f32``."
msgstr ""

#: ../../taichi/docs/type.rst:99
msgid ""
"Default integer and float-point precisions (``default_ip`` and "
"``default_fp``) can be specified when initializing Taichi:"
msgstr ""

#: ../../taichi/docs/type.rst:101
msgid ""
"ti.init(default_fp=ti.f32)\n"
"ti.init(default_fp=ti.f64)\n"
"\n"
"ti.init(default_ip=ti.i32)\n"
"ti.init(default_ip=ti.i64)"
msgstr ""

#: ../../taichi/docs/type.rst:110
msgid ""
"Also note that you may use ``float`` or ``int`` in type definitions as "
"aliases for default precisions, e.g.:"
msgstr ""

#: ../../taichi/docs/type.rst:113
msgid ""
"ti.init(default_ip=ti.i64, default_fp=ti.f32)\n"
"\n"
"x = ti.var(float, 5)\n"
"y = ti.var(int, 5)\n"
"# is equivalent to:\n"
"x = ti.var(ti.f32, 5)\n"
"y = ti.var(ti.i64, 5)\n"
"\n"
"def func(a: float) -> int:\n"
"    ...\n"
"\n"
"# is equivalent to:\n"
"def func(a: ti.f32) -> ti.i64:\n"
"    ..."
msgstr ""

#: ../../taichi/docs/type.rst:133
msgid "Type casts"
msgstr ""

#: ../../taichi/docs/type.rst:136
msgid "Implicit casts"
msgstr ""

#: ../../taichi/docs/type.rst:140
msgid "The type of a variable is **determinated on it's initialization**."
msgstr ""

#: ../../taichi/docs/type.rst:142
msgid ""
"When a *low-precision* variable is assigned to a *high-precision* "
"variable, it will be implicitly promoted to the *wide* type and no "
"warning will be raised:"
msgstr ""

#: ../../taichi/docs/type.rst:145
msgid ""
"a = 1.7\n"
"a = 1\n"
"print(a)  # 1.0"
msgstr ""

#: ../../taichi/docs/type.rst:151
msgid ""
"When a *high-precision* variable is assigned to a *low-precision* type, "
"it will be implicitly down-cast into the *low-precision* type and Taichi "
"will raise a warning:"
msgstr ""

#: ../../taichi/docs/type.rst:154
msgid ""
"a = 1\n"
"a = 1.7\n"
"print(a)  # 1"
msgstr ""

#: ../../taichi/docs/type.rst:161
msgid "Explicit casts"
msgstr ""

#: ../../taichi/docs/type.rst:163
msgid ""
"You may use ``ti.cast`` to explicitly cast scalar values between "
"different types:"
msgstr ""

#: ../../taichi/docs/type.rst:165
msgid ""
"a = 1.7\n"
"b = ti.cast(a, ti.i32)  # 1\n"
"c = ti.cast(b, ti.f32)  # 1.0"
msgstr ""

#: ../../taichi/docs/type.rst:171
msgid ""
"Equivalently, use ``int()`` and ``float()`` to convert values to float-"
"point or integer types of default precisions:"
msgstr ""

#: ../../taichi/docs/type.rst:174
msgid ""
"a = 1.7\n"
"b = int(a)    # 1\n"
"c = float(a)  # 1.0"
msgstr ""

#: ../../taichi/docs/type.rst:181
msgid "Casting vectors and matrices"
msgstr ""

#: ../../taichi/docs/type.rst:183
msgid "Type casts applied to vectors/matrices are element-wise:"
msgstr ""

#: ../../taichi/docs/type.rst:185
msgid ""
"u = ti.Vector([2.3, 4.7])\n"
"v = int(u)              # ti.Vector([2, 4])\n"
"# If you are using ti.i32 as default_ip, this is equivalent to:\n"
"v = ti.cast(u, ti.i32)  # ti.Vector([2, 4])"
msgstr ""

#: ../../taichi/docs/type.rst:193
msgid "Bit casting"
msgstr ""

#: ../../taichi/docs/type.rst:195
msgid ""
"Use ``ti.bit_cast`` to bit-cast a value into another data type. The "
"underlying bits will be preserved in this cast. The new type must have "
"the same width as the the old type. For example, bit-casting ``i32`` to "
"``f64`` is not allowed. Use this operation with caution."
msgstr ""

#: ../../taichi/docs/type.rst:199
msgid ""
"For people from C++, ``ti.bit_cast`` is equivalent to "
"``reinterpret_cast``."
msgstr ""

#: ../../taichi/docs/utilities.rst:2
msgid "Developer utilities"
msgstr ""

#: ../../taichi/docs/utilities.rst:4
msgid ""
"This section provides a detailed description of some commonly used "
"utilities for Taichi developers."
msgstr ""

#: ../../taichi/docs/utilities.rst:9
msgid ""
"Taichi uses `spdlog <https://github.com/gabime/spdlog>`_ as its logging "
"system. Logs can have different levels, from low to high, they are:"
msgstr ""

#: ../../taichi/docs/utilities.rst:12
msgid ""
"trace\n"
"debug\n"
"info\n"
"warn\n"
"error"
msgstr ""

#: ../../taichi/docs/utilities.rst:20
msgid "The higher the level is, the more critical the message is."
msgstr ""

#: ../../taichi/docs/utilities.rst:22
msgid ""
"The default logging level is ``info``. You may override the default "
"logging level by:"
msgstr ""

#: ../../taichi/docs/utilities.rst:24
msgid "Setting the environment variable like ``export TI_LOG_LEVEL=warn``."
msgstr ""

#: ../../taichi/docs/utilities.rst:25
msgid "Setting the log level from Python side: ``ti.set_logging_level(ti.WARN)``."
msgstr ""

#: ../../taichi/docs/utilities.rst:27
msgid "In Python, you may write logs using the ``ti.*`` interface:"
msgstr ""

#: ../../taichi/docs/utilities.rst:29
msgid ""
"# Python\n"
"ti.trace(\"Hello world!\")\n"
"ti.debug(\"Hello world!\")\n"
"ti.info(\"Hello world!\")\n"
"ti.warn(\"Hello world!\")\n"
"ti.error(\"Hello world!\")"
msgstr ""

#: ../../taichi/docs/utilities.rst:38
msgid "In C++, you may write logs using the ``TI_*`` interface:"
msgstr ""

#: ../../taichi/docs/utilities.rst:40
msgid ""
"// C++\n"
"TI_TRACE(\"Hello world!\");\n"
"TI_DEBUG(\"Hello world!\");\n"
"TI_INFO(\"Hello world!\");\n"
"TI_WARN(\"Hello world!\");\n"
"TI_ERROR(\"Hello world!\");"
msgstr ""

#: ../../taichi/docs/utilities.rst:49
msgid ""
"If one raises a message of the level ``error``, Taichi will be "
"**terminated** immediately and result in a ``RuntimeError`` on Python "
"side."
msgstr ""

#: ../../taichi/docs/utilities.rst:52
msgid ""
"int func(void *p) {\n"
"  if (p == nullptr)\n"
"    TI_ERROR(\"The pointer cannot be null!\");\n"
"\n"
"  // will not reach here if p == nullptr\n"
"  do_something(p);\n"
"}"
msgstr ""

#: ../../taichi/docs/utilities.rst:64
msgid "For people from Linux kernels, ``TI_ERROR`` is just ``panic``."
msgstr ""

#: ../../taichi/docs/utilities.rst:67
msgid "You may also simplify the above code by using ``TI_ASSERT``:"
msgstr ""

#: ../../taichi/docs/utilities.rst:69
msgid ""
"int func(void *p) {\n"
"  TI_ASSERT_INFO(p != nullptr, \"The pointer cannot be null!\");\n"
"  // or\n"
"  // TI_ASSERT(p != nullptr);\n"
"\n"
"  // will not reach here if p == nullptr\n"
"  do_something(p);\n"
"}"
msgstr ""

#: ../../taichi/docs/utilities.rst:83
msgid "Benchmarking and regression tests"
msgstr ""

#: ../../taichi/docs/utilities.rst:85
msgid ""
"Run ``ti benchmark`` to run tests in benchmark mode. This will record the"
" performance of ``ti test``, and save it in ``benchmarks/output``."
msgstr ""

#: ../../taichi/docs/utilities.rst:87
msgid ""
"Run ``ti regression`` to show the difference between the previous result "
"in ``benchmarks/baseline``. And you can see if the performance is "
"increasing or decreasing after your commits. This is really helpful when "
"your work is related to IR optimizations."
msgstr ""

#: ../../taichi/docs/utilities.rst:89
msgid ""
"Run ``ti baseline`` to save the benchmark result to "
"``benchmarks/baseline`` for future comparison, this may be executed on "
"performance-related PRs, before they are merged into master."
msgstr ""

#: ../../taichi/docs/utilities.rst:91
msgid ""
"For example, this is part of the output by ``ti regression`` after "
"enabling constant folding optimization pass:"
msgstr ""

#: ../../taichi/docs/utilities.rst:93
msgid ""
"linalg__________________polar_decomp______________________________\n"
"codegen_offloaded_tasks                       37 ->    39    +5.4%\n"
"codegen_statements                          3179 ->  3162    -0.5%\n"
"codegen_kernel_statements                   2819 ->  2788    -1.1%\n"
"codegen_evaluator_statements                   0 ->    14    +inf%\n"
"\n"
"linalg__________________init_matrix_from_vectors__________________\n"
"codegen_offloaded_tasks                       37 ->    39    +5.4%\n"
"codegen_statements                          3180 ->  3163    -0.5%\n"
"codegen_kernel_statements                   2820 ->  2789    -1.1%\n"
"codegen_evaluator_statements                   0 ->    14    +inf%"
msgstr ""

#: ../../taichi/docs/utilities.rst:109
msgid ""
"Currently ``ti benchmark`` only supports benchmarking number-of-"
"statements, no time benchmarking is included since it depends on hardware"
" performance and therefore hard to compare if the baseline is from "
"another machine. We are to purchase a fixed-performance machine as a time"
" benchmark server at some point. Discussion at: https://github.com"
"/taichi-dev/taichi/issue/948"
msgstr ""

#: ../../taichi/docs/utilities.rst:114
msgid ""
"The suggested workflow for the performance-related PR author to run the "
"regression tests is:"
msgstr ""

#: ../../taichi/docs/utilities.rst:116
msgid ""
"Run ``ti benchmark && ti baseline`` in ``master`` to save the current "
"performance as a baseline."
msgstr ""

#: ../../taichi/docs/utilities.rst:118
msgid "Run ``git checkout -b your-branch-name``."
msgstr ""

#: ../../taichi/docs/utilities.rst:120
msgid "Do works on the issue, stage 1."
msgstr ""

#: ../../taichi/docs/utilities.rst:122
msgid "Run ``ti benchmark && ti regression`` to obtain the result."
msgstr ""

#: ../../taichi/docs/utilities.rst:124
msgid "(If result BAD) Do further improvements, until the result is satisfying."
msgstr ""

#: ../../taichi/docs/utilities.rst:126
msgid ""
"(If result OK) Run ``ti baseline`` to save stage 1 performance as a "
"baseline."
msgstr ""

#: ../../taichi/docs/utilities.rst:128
msgid "Go forward to stage 2, 3, ..., and the same workflow is applied."
msgstr ""

#: ../../taichi/docs/utilities.rst:132
msgid "(Linux only) Trigger ``gdb`` when programs crash"
msgstr ""

#: ../../taichi/docs/utilities.rst:134
msgid ""
"# Python\n"
"ti.set_gdb_trigger(True)\n"
"\n"
"// C++\n"
"CoreState::set_trigger_gdb_when_crash(true);\n"
"\n"
"# Shell\n"
"export TI_GDB_TRIGGER=1"
msgstr ""

#: ../../taichi/docs/utilities.rst:148
msgid ""
"**Quickly pinpointing segmentation faults/assertion failures using** "
"``gdb``: When Taichi crashes, ``gdb`` will be triggered and attach to the"
" current thread. You might be prompt to enter sudo password required for "
"gdb thread attaching. After entering ``gdb``, check the stack backtrace "
"with command ``bt`` (``backtrace``), then find the line of code "
"triggering the error."
msgstr ""

#: ../../taichi/docs/utilities.rst:158
msgid "Code coverage"
msgstr ""

#: ../../taichi/docs/utilities.rst:160
msgid ""
"To ensure that our tests covered every situation, we need to have "
"**coverage report**. That is, to detect how many percents of code lines "
"in is executed in test."
msgstr ""

#: ../../taichi/docs/utilities.rst:163
msgid ""
"Generally, the higher the coverage percentage is, the stronger our tests "
"are."
msgstr ""

#: ../../taichi/docs/utilities.rst:164
msgid ""
"When making a PR, we want to **ensure that it comes with corresponding "
"tests**. Or code coverage will decrease."
msgstr ""

#: ../../taichi/docs/utilities.rst:165
msgid ""
"Code coverage statuses are visible at `Codecov <https://codecov.io/gh"
"/taichi-dev/taichi>`_."
msgstr ""

#: ../../taichi/docs/utilities.rst:166
msgid ""
"Currently, Taichi is only set up for Python code coverage report, not for"
" C++ yet."
msgstr ""

#: ../../taichi/docs/utilities.rst:168
msgid ""
"ti test -C       # run tests and save results to .coverage\n"
"coverage report  # generate a coverage report on terminal output\n"
"coverage html    # generate a HTML form report in htmlcov/index.html"
msgstr ""

#: ../../taichi/docs/utilities.rst:176
msgid "Interface system (legacy)"
msgstr ""

#: ../../taichi/docs/utilities.rst:177
msgid "Print all interfaces and units"
msgstr ""

#: ../../taichi/docs/utilities.rst:179
msgid "ti.core.print_all_units()"
msgstr ""

#: ../../taichi/docs/utilities.rst:184
msgid "Serialization (legacy)"
msgstr ""

#: ../../taichi/docs/utilities.rst:186
msgid ""
"The serialization module of taichi allows you to serialize/deserialize "
"objects into/from binary strings."
msgstr ""

#: ../../taichi/docs/utilities.rst:188
msgid ""
"You can use ``TI_IO`` macros to explicitly define fields necessary in "
"Taichi."
msgstr ""

#: ../../taichi/docs/utilities.rst:190
msgid ""
"// TI_IO_DEF\n"
"struct Particle {\n"
"    Vector3f position, velocity;\n"
"    real mass;\n"
"    string name;\n"
"\n"
"    TI_IO_DEF(position, velocity, mass, name);\n"
"}\n"
"\n"
"// TI_IO_DECL\n"
"struct Particle {\n"
"    Vector3f position, velocity;\n"
"    real mass;\n"
"    bool has_name\n"
"    string name;\n"
"\n"
"    TI_IO_DECL() {\n"
"        TI_IO(position);\n"
"        TI_IO(velocity);\n"
"        TI_IO(mass);\n"
"        TI_IO(has_name);\n"
"        // More flexibility:\n"
"        if (has_name) {\n"
"            TI_IO(name);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// TI_IO_DEF_VIRT();"
msgstr ""

#: ../../taichi/docs/utilities.rst:224
msgid "Progress notification (legacy)"
msgstr ""

#: ../../taichi/docs/utilities.rst:226
msgid ""
"The Taichi messenger can send an email to ``$TI_MONITOR_EMAIL`` when the "
"task finishes or crashes. To enable:"
msgstr ""

#: ../../taichi/docs/utilities.rst:229
msgid ""
"from taichi.tools import messenger\n"
"messenger.enable(task_id='test')"
msgstr ""

#: ../../taichi/docs/vector.rst:4
msgid "Vectors"
msgstr ""

#: ../../taichi/docs/vector.rst:6
msgid "A vector in Taichi can have two forms:"
msgstr ""

#: ../../taichi/docs/vector.rst:8
msgid ""
"as a temporary local variable. An ``n`` component vector consists of "
"``n`` scalar values."
msgstr ""

#: ../../taichi/docs/vector.rst:9
msgid ""
"as an element of a global field. In this case, the field is an "
"N-dimensional array of ``n`` component vectors."
msgstr ""

#: ../../taichi/docs/vector.rst:11
msgid ""
"In fact, ``Vector`` is simply an alias of ``Matrix``, just with ``m = "
"1``. See :ref:`matrix` and :ref:`tensor` for more details."
msgstr ""

#: ../../taichi/docs/vector.rst:17 ../../taichi/docs/vector.rst:56
msgid "As global vector fields"
msgstr ""

#: ../../taichi/docs/vector.rst:21
msgid "(scalar) the number of components in the vector"
msgstr ""

#: ../../taichi/docs/vector.rst:23
msgid "(optional, scalar or tuple) shape of the vector field, see :ref:`tensor`"
msgstr ""

#: ../../taichi/docs/vector.rst:26
msgid "For example, this creates a 3-D vector field of the shape of ``5x4``: ::"
msgstr ""

#: ../../taichi/docs/vector.rst:29
msgid ""
"# Python-scope\n"
"a = ti.Vector.field(3, dtype=ti.f32, shape=(5, 4))"
msgstr ""

#: ../../taichi/docs/vector.rst:34
msgid ""
"In Python-scope, ``ti.field`` declares :ref:`scalar_tensor`, while "
"``ti.Vector.field`` declares vector fields."
msgstr ""

#: ../../taichi/docs/vector.rst:42
msgid "(scalar) the first component of the vector"
msgstr ""

#: ../../taichi/docs/vector.rst:43
msgid "(scalar) the second component of the vector"
msgstr ""

#: ../../taichi/docs/vector.rst:45
msgid "For example, this creates a 3D vector with components (2, 3, 4): ::"
msgstr ""

#: ../../taichi/docs/vector.rst:48
msgid ""
"# Taichi-scope\n"
"a = ti.Vector([2, 3, 4])"
msgstr ""

#: ../../taichi/docs/vector.rst:59
msgid "(ti.Vector.field) the vector"
msgstr ""

#: ../../taichi/docs/vector.rst:62
msgid "(scalar) index of the vector component"
msgstr ""

#: ../../taichi/docs/vector.rst:64
msgid "This extracts the first component of vector ``a[6, 3]``: ::"
msgstr ""

#: ../../taichi/docs/vector.rst:67
msgid ""
"x = a[6, 3][0]\n"
"\n"
"# or\n"
"vec = a[6, 3]\n"
"x = vec[0]"
msgstr ""

#: ../../taichi/docs/vector.rst:75
msgid ""
"**Always** use two pairs of square brackets to access scalar elements "
"from vector fields."
msgstr ""

#: ../../taichi/docs/vector.rst:77
msgid ""
"The indices in the first pair of brackets locate the vector inside the "
"vector fields;"
msgstr ""

#: ../../taichi/docs/vector.rst:78
msgid ""
"The indices in the second pair of brackets locate the scalar element "
"inside the vector."
msgstr ""

#: ../../taichi/docs/vector.rst:80
msgid ""
"For 0-D vector fields, indices in the first pair of brackets should be "
"``[None]``."
msgstr ""

#: ../../taichi/docs/vector.rst:89
msgid "(Vector) the vector"
msgstr ""

#: ../../taichi/docs/vector.rst:90
msgid "(scalar) index of the component"
msgstr ""

#: ../../taichi/docs/vector.rst:92
msgid "For example, this extracts the first component of vector ``a``: ::"
msgstr ""

#: ../../taichi/docs/vector.rst:95
msgid "x = a[0]"
msgstr ""

#: ../../taichi/docs/vector.rst:97
msgid "This sets the second component of ``a`` to 4: ::"
msgstr ""

#: ../../taichi/docs/vector.rst:100
msgid "a[1] = 4"
msgstr ""

#: ../../taichi/docs/vector.rst:102
msgid "TODO: add descriptions about ``a(i, j)``"
msgstr ""

#: ../../taichi/docs/vector.rst:109 ../../taichi/docs/vector.rst:127
#: ../../taichi/docs/vector.rst:141 ../../taichi/docs/vector.rst:155
#: ../../taichi/docs/vector.rst:156 ../../taichi/docs/vector.rst:189
#: ../../taichi/docs/vector.rst:190 ../../taichi/docs/vector.rst:207
msgid "(ti.Vector)"
msgstr ""

#: ../../taichi/docs/vector.rst:110
msgid ""
"(optional, scalar) a safe-guard value for ``sqrt``, usually 0. See the "
"note below."
msgstr ""

#: ../../taichi/docs/vector.rst:111
msgid "(scalar) the magnitude / length / norm of vector"
msgstr ""

#: ../../taichi/docs/vector.rst:116
msgid ""
"a = ti.Vector([3, 4])\n"
"a.norm() # sqrt(3*3 + 4*4 + 0) = 5"
msgstr ""

#: ../../taichi/docs/vector.rst:119
msgid "``a.norm(eps)`` is equivalent to ``ti.sqrt(a.dot(a) + eps)``"
msgstr ""

#: ../../taichi/docs/vector.rst:122
msgid ""
"Set ``eps = 1e-5`` for example, to safe guard the operator's gradient on "
"zero vectors during differentiable programming."
msgstr ""

#: ../../taichi/docs/vector.rst:128
msgid "(scalar) the square of the magnitude / length / norm of vector"
msgstr ""

#: ../../taichi/docs/vector.rst:133
msgid ""
"a = ti.Vector([3, 4])\n"
"a.norm_sqr() # 3*3 + 4*4 = 25"
msgstr ""

#: ../../taichi/docs/vector.rst:136
msgid "``a.norm_sqr()`` is equivalent to ``a.dot(a)``"
msgstr ""

#: ../../taichi/docs/vector.rst:142
msgid "(ti.Vector) the normalized / unit vector of ``a``"
msgstr ""

#: ../../taichi/docs/vector.rst:147
msgid ""
"a = ti.Vector([3, 4])\n"
"a.normalized() # [3 / 5, 4 / 5]"
msgstr ""

#: ../../taichi/docs/vector.rst:150
msgid "``a.normalized()`` is equivalent to ``a / a.norm()``."
msgstr ""

#: ../../taichi/docs/vector.rst:157
msgid "(scalar) the dot (inner) product of ``a`` and ``b``"
msgstr ""

#: ../../taichi/docs/vector.rst:159 ../../taichi/docs/vector.rst:193
#: ../../taichi/docs/vector.rst:211 ../../taichi/docs/vector.rst:230
msgid "E.g., ::"
msgstr ""

#: ../../taichi/docs/vector.rst:162
msgid ""
"a = ti.Vector([1, 3])\n"
"b = ti.Vector([2, 4])\n"
"a.dot(b) # 1*2 + 3*4 = 14"
msgstr ""

#: ../../taichi/docs/vector.rst:169
msgid "(ti.Vector, 2 or 3 components)"
msgstr ""

#: ../../taichi/docs/vector.rst:170
msgid "(ti.Vector of the same size as a)"
msgstr ""

#: ../../taichi/docs/vector.rst:171
msgid ""
"(scalar (for 2D inputs), or 3D Vector (for 3D inputs)) the cross product "
"of ``a`` and ``b``"
msgstr ""

#: ../../taichi/docs/vector.rst:173
msgid "We use a right-handed coordinate system. E.g., ::"
msgstr ""

#: ../../taichi/docs/vector.rst:176
msgid ""
"a = ti.Vector([1, 2, 3])\n"
"b = ti.Vector([4, 5, 6])\n"
"c = ti.cross(a, b)\n"
"# c = [2*6 - 5*3, 4*3 - 1*6, 1*5 - 4*2] = [-3, 6, -3]\n"
"\n"
"p = ti.Vector([1, 2])\n"
"q = ti.Vector([4, 5])\n"
"r = ti.cross(a, b)\n"
"# r = 1*5 - 4*2 = -3"
msgstr ""

#: ../../taichi/docs/vector.rst:191
msgid "(ti.Matrix) the outer product of ``a`` and ``b``"
msgstr ""

#: ../../taichi/docs/vector.rst:196
msgid ""
"a = ti.Vector([1, 2])\n"
"b = ti.Vector([4, 5, 6])\n"
"c = ti.outer_product(a, b) # NOTE: c[i, j] = a[i] * b[j]\n"
"# c = [[1*4, 1*5, 1*6], [2*4, 2*5, 2*6]]"
msgstr ""

#: ../../taichi/docs/vector.rst:202
msgid ""
"This have no common with ``ti.cross``. ``a`` and ``b`` do not have to be "
"3 or 2 component vectors."
msgstr ""

#: ../../taichi/docs/vector.rst:208
msgid "(DataType)"
msgstr ""

#: ../../taichi/docs/vector.rst:209
msgid "(ti.Vector) vector with all components of ``a`` casted into type ``dt``"
msgstr ""

#: ../../taichi/docs/vector.rst:214
msgid ""
"# Taichi-scope\n"
"a = ti.Vector([1.6, 2.3])\n"
"a.cast(ti.i32) # [2, 3]"
msgstr ""

#: ../../taichi/docs/vector.rst:219
msgid ""
"Vectors are special matrices with only 1 column. In fact, ``ti.Vector`` "
"is just an alias of ``ti.Matrix``."
msgstr ""

#: ../../taichi/docs/vector.rst:223
msgid "Metadata"
msgstr ""

#: ../../taichi/docs/vector.rst:227
msgid "(ti.Vector or ti.Vector.field)"
msgstr ""

#: ../../taichi/docs/vector.rst:228
msgid ""
"(scalar) return the dimensionality of vector ``a``  E.g., ::      # "
"Taichi-scope     a = ti.Vector([1, 2, 3])     a.n  # 3  ::      # Python-"
"scope     a = ti.Vector.field(3, dtype=ti.f32, shape=())     a.n  # 3"
msgstr ""

#: ../../taichi/docs/vector.rst:228
msgid "(scalar) return the dimensionality of vector ``a``"
msgstr ""

#: ../../taichi/docs/vector.rst:233
msgid ""
"# Taichi-scope\n"
"a = ti.Vector([1, 2, 3])\n"
"a.n  # 3"
msgstr ""

#: ../../taichi/docs/vector.rst:239
msgid ""
"# Python-scope\n"
"a = ti.Vector.field(3, dtype=ti.f32, shape=())\n"
"a.n  # 3"
msgstr ""

#: ../../taichi/docs/vector.rst:243
msgid "TODO: add element wise operations docs"
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:2
msgid "Versioning and releases"
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:5
msgid "Pre-1.0 versioning"
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:7
msgid "Taichi follows `Semantic Versioning 2.0.0 <https://semver.org/>`_."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:9
msgid ""
"Since Taichi is still under version 1.0.0, we use minor version bumps "
"(e.g., ``0.6.17->0.7.0``) for breaking API changes, and patch version "
"bumps (e.g., ``0.6.9->0.6.10``) for backward-compatible changes."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:14
msgid "Workflow: releasing a new version"
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:16
msgid ""
"Trigger a Linux build on `Jenkins "
"<http://f11.csail.mit.edu:8080/job/taichi/>`_ to see if CUDA passes all "
"tests. Note that Jenkins is the only build bot we have that tests CUDA. "
"(This may take half an hour.)"
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:18
msgid ""
"Create a branch for the release PR, forking from the latest commit of the"
" ``master`` branch."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:20
msgid ""
"Update Taichi version number at the beginning of ``CMakeLists.txt``. For "
"example, change ``SET(TI_VERSION_PATCH 9)`` to ``SET(TI_VERSION_PATCH "
"10)``."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:21
msgid "Rerun cmake so that ``docs/version`` gets updated."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:22
msgid "commit with message \"[release] vX.Y.Z\", e.g. \"[release] v0.6.10\"."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:23
msgid ""
"You should see two changes in this commit: one line in ``CMakeLists.txt``"
" and one line in ``docs/version``."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:24
msgid "Execute ``ti changelog`` and save its outputs. You will need this later."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:26
msgid ""
"Open a PR titled \"[release] vX.Y.Z\" with the branch and commit you just"
" now created."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:28
msgid ""
"Use the ``ti changelog`` output you saved in the previous step as the "
"content of the PR description."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:29
msgid ""
"Wait for all the checks and build bots to complete. (This step may take "
"up to two hours)."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:31
msgid "Squash and merge the PR."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:32
msgid ""
"Trigger the Linux build on Jenkins, again, so that Linux packages are "
"uploaded to PyPI."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:33
msgid ""
"Wait for all build bots to finish. This step uploads PyPI packages for OS"
" X and Windows. You may have to wait for up to two hours."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:34
msgid ""
"Update the ``stable`` branch so that the head of that branch is your "
"release commit on ``master``."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:36
msgid ""
"Draft a new release `(here) <https://github.com/taichi-"
"dev/taichi/releases>`_:"
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:38
msgid "The title should be \"vX.Y.Z\"."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:39
msgid "The tag should be \"vX.Y.Z\"."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:40
msgid "Target should be \"recent commit\" -> the release commit."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:41
msgid ""
"The release description should be copy-pasted from the release PR "
"description."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:42
msgid "Click the \"Publish release\" button."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:45
msgid "Release cycle"
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:47
msgid "Taichi releases new versions twice per week:"
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:49
msgid "The first release happens on Wednesdays."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:50
msgid "The second release happens on Saturdays."
msgstr ""

#: ../../taichi/docs/versioning_releases.rst:52
msgid "Additional releases may happen if anything needs an urgent fix."
msgstr ""

#: ../../taichi/docs/write_test.rst:2
msgid "Workflow for writing a Python test"
msgstr ""

#: ../../taichi/docs/write_test.rst:4
msgid "Normally we write functional tests in Python."
msgstr ""

#: ../../taichi/docs/write_test.rst:6
msgid ""
"We use `pytest <https://github.com/pytest-dev/pytest>`_ for our Python "
"test infrastructure."
msgstr ""

#: ../../taichi/docs/write_test.rst:7
msgid "Python tests should be added to ``tests/python/test_xxx.py``."
msgstr ""

#: ../../taichi/docs/write_test.rst:9
msgid ""
"For example, you've just added a utility function ``ti.log10``. Now you "
"want to write a **test**, to test if it functions properly."
msgstr ""

#: ../../taichi/docs/write_test.rst:13
msgid "Adding a new test case"
msgstr ""

#: ../../taichi/docs/write_test.rst:15
msgid ""
"Look into ``tests/python``, see if there's already a file suit for your "
"test. If not, feel free to create a new file for it :) So in this case "
"let's create a new file ``tests/python/test_logarithm.py`` for "
"simplicity."
msgstr ""

#: ../../taichi/docs/write_test.rst:19
msgid ""
"Add a function, the function name **must** be started with ``test_`` so "
"that ``pytest`` could find it. e.g:"
msgstr ""

#: ../../taichi/docs/write_test.rst:21
msgid ""
"import taichi as ti\n"
"\n"
"def test_log10():\n"
"    pass"
msgstr ""

#: ../../taichi/docs/write_test.rst:28
msgid ""
"Add some simple code make use of our ``ti.log10`` to make sure it works "
"well. Hint: You may pass/return values to/from Taichi-scope using 0-D "
"fields, i.e. ``r[None]``."
msgstr ""

#: ../../taichi/docs/write_test.rst:31
msgid ""
"import taichi as ti\n"
"\n"
"def test_log10():\n"
"    ti.init(arch=ti.cpu)\n"
"\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == 2"
msgstr ""

#: ../../taichi/docs/write_test.rst:48
msgid ""
"Execute ``ti test logarithm``, and the functions starting with ``test_`` "
"in ``tests/python/test_logarithm.py`` will be executed."
msgstr ""

#: ../../taichi/docs/write_test.rst:51
msgid "Testing against multiple backends"
msgstr ""

#: ../../taichi/docs/write_test.rst:53
msgid ""
"The above method is not good enough, for example, "
"``ti.init(arch=ti.cpu)``, means that it will only test on the CPU "
"backend. So do we have to write many tests ``test_log10_cpu``, "
"``test_log10_cuda``, ... with only the first line different? No worries, "
"we provide a useful decorator ``@ti.test``:"
msgstr ""

#: ../../taichi/docs/write_test.rst:57
msgid ""
"import taichi as ti\n"
"\n"
"# will test against both CPU and CUDA backends\n"
"@ti.test(ti.cpu, ti.cuda)\n"
"def test_log10():\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == 2"
msgstr ""

#: ../../taichi/docs/write_test.rst:74
msgid ""
"And you may test against **all backends** by simply not specifying the "
"argument:"
msgstr ""

#: ../../taichi/docs/write_test.rst:76
msgid ""
"import taichi as ti\n"
"\n"
"# will test against all backends available on your end\n"
"@ti.test()\n"
"def test_log10():\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == 2"
msgstr ""

#: ../../taichi/docs/write_test.rst:93
msgid "Cool! Right? But that's still not good enough."
msgstr ""

#: ../../taichi/docs/write_test.rst:96
msgid "Using ``ti.approx`` for comparison with tolerance"
msgstr ""

#: ../../taichi/docs/write_test.rst:98
msgid ""
"Sometimes the math percison could be poor on some backends like OpenGL, "
"e.g. ``ti.log10(100)`` may return ``2.001`` or ``1.999`` in this case."
msgstr ""

#: ../../taichi/docs/write_test.rst:101
msgid ""
"To cope with this behavior, we provide ``ti.approx`` which can tolerate "
"such errors on different backends, for example ``2.001 == ti.approx(2)`` "
"will return ``True`` on the OpenGL backend."
msgstr ""

#: ../../taichi/docs/write_test.rst:104
msgid ""
"import taichi as ti\n"
"\n"
"# will test against all backends available on your end\n"
"@ti.test()\n"
"def test_log10():\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = 100\n"
"    foo()\n"
"    assert r[None] == ti.approx(2)"
msgstr ""

#: ../../taichi/docs/write_test.rst:123
msgid ""
"Simply using ``pytest.approx`` won't work well here, since it's tolerance"
" won't vary among different Taichi backends. It'll be likely to fail on "
"the OpenGL backend."
msgstr ""

#: ../../taichi/docs/write_test.rst:126
msgid ""
"``ti.approx`` also do treatments on boolean types, e.g.: ``2 == "
"ti.approx(True)``."
msgstr ""

#: ../../taichi/docs/write_test.rst:128
msgid "Great on improving stability! But the test is still not good enough, yet."
msgstr ""

#: ../../taichi/docs/write_test.rst:131
msgid "Parametrize test inputs"
msgstr ""

#: ../../taichi/docs/write_test.rst:133
msgid ""
"For example, ``r[None] = 100``, means that it will only test the case of "
"``ti.log10(100)``. What if ``ti.log10(10)``? ``ti.log10(1)``?"
msgstr ""

#: ../../taichi/docs/write_test.rst:136
msgid ""
"We may test against different input values using the "
"``@pytest.mark.parametrize`` decorator:"
msgstr ""

#: ../../taichi/docs/write_test.rst:138
msgid ""
"import taichi as ti\n"
"import pytest\n"
"import math\n"
"\n"
"@pytest.mark.parametrize('x', [1, 10, 100])\n"
"@ti.test()\n"
"def test_log10(x):\n"
"    r = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.log10(r[None])\n"
"\n"
"    r[None] = x\n"
"    foo()\n"
"    assert r[None] == math.log10(x)"
msgstr ""

#: ../../taichi/docs/write_test.rst:157
msgid "Use a comma-separated list for multiple input values:"
msgstr ""

#: ../../taichi/docs/write_test.rst:159
msgid ""
"import taichi as ti\n"
"import pytest\n"
"import math\n"
"\n"
"@pytest.mark.parametrize('x,y', [(1, 2), (1, 3), (2, 1)])\n"
"@ti.test()\n"
"def test_atan2(x, y):\n"
"    r = ti.var(ti.f32, ())\n"
"    s = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.atan2(r[None])\n"
"\n"
"    r[None] = x\n"
"    s[None] = y\n"
"    foo()\n"
"    assert r[None] == math.atan2(x, y)"
msgstr ""

#: ../../taichi/docs/write_test.rst:180
msgid ""
"Use two separate ``parametrize`` to test **all combinations** of input "
"arguments:"
msgstr ""

#: ../../taichi/docs/write_test.rst:182
msgid ""
"import taichi as ti\n"
"import pytest\n"
"import math\n"
"\n"
"@pytest.mark.parametrize('x', [1, 2])\n"
"@pytest.mark.parametrize('y', [1, 2])\n"
"# same as:  .parametrize('x,y', [(1, 1), (1, 2), (2, 1), (2, 2)])\n"
"@ti.test()\n"
"def test_atan2(x, y):\n"
"    r = ti.var(ti.f32, ())\n"
"    s = ti.var(ti.f32, ())\n"
"\n"
"    @ti.kernel\n"
"    def foo():\n"
"        r[None] = ti.atan2(r[None])\n"
"\n"
"    r[None] = x\n"
"    s[None] = y\n"
"    foo()\n"
"    assert r[None] == math.atan2(x, y)"
msgstr ""

#: ../../taichi/docs/write_test.rst:206
msgid "Specifying ``ti.init`` configurations"
msgstr ""

#: ../../taichi/docs/write_test.rst:208
msgid "You may specify keyword arguments to ``ti.init()`` in ``ti.test()``, e.g.:"
msgstr ""

#: ../../taichi/docs/write_test.rst:210
msgid ""
"@ti.test(ti.cpu, debug=True, log_level=ti.TRACE)\n"
"def test_debugging_utils():\n"
"    # ... (some tests have to be done in debug mode)"
msgstr ""

#: ../../taichi/docs/write_test.rst:216
msgid "is the same as:"
msgstr ""

#: ../../taichi/docs/write_test.rst:218
msgid ""
"def test_debugging_utils():\n"
"    ti.init(arch=ti.cpu, debug=True, log_level=ti.TRACE)\n"
"    # ... (some tests have to be done in debug mode)"
msgstr ""

#: ../../taichi/docs/write_test.rst:225
msgid "Exclude some backends from test"
msgstr ""

#: ../../taichi/docs/write_test.rst:227
msgid ""
"Sometimes some backends are not capable of specific tests, we have to "
"exclude them from test:"
msgstr ""

#: ../../taichi/docs/write_test.rst:229
msgid ""
"# Run this test on all backends except for OpenGL\n"
"@ti.test(excludes=[ti.opengl])\n"
"def test_sparse_field():\n"
"    # ... (some tests that requires sparse feature which is not supported"
" by OpenGL)"
msgstr ""

#: ../../taichi/docs/write_test.rst:236
msgid ""
"You may also use the ``extensions`` keyword to exclude backends without "
"specific feature:"
msgstr ""

#: ../../taichi/docs/write_test.rst:238
msgid ""
"# Run this test on all backends except for OpenGL\n"
"@ti.test(extensions=[ti.extension.sparse])\n"
"def test_sparse_field():\n"
"    # ... (some tests that requires sparse feature which is not supported"
" by OpenGL)"
msgstr ""

#~ msgid ""
#~ "Note this is for the compiler "
#~ "developers of the Taichi programming "
#~ "language. End users should use the "
#~ "pip packages instead of building from"
#~ " scratch. To build with NVIDIA GPU"
#~ " support, CUDA 10.0+ is needed. This"
#~ " installation guide works for Ubuntu "
#~ "16.04+ and OS X 10.14+. For "
#~ "precise build instructions on Windows, "
#~ "please check out `appveyor.yml "
#~ "<https://github.com/taichi-"
#~ "dev/taichi/blob/master/appveyor.yml>`_, which does "
#~ "basically the same thing as the "
#~ "following instructions."
#~ msgstr ""

#~ msgid ""
#~ "(If on other Linux distributions) Please"
#~ " build clang 8.0.1 from scratch:"
#~ msgstr ""

#~ msgid "Make sure you have LLVM 8.0.1 built from scratch. To do so:"
#~ msgstr ""

#~ msgid ""
#~ "git clone https://github.com/taichi-dev/taichi "
#~ "--depth=1 --branch=master\n"
#~ "git submodule update --init --recursive --depth=1\n"
#~ "cd taichi\n"
#~ "mkdir build\n"
#~ "cd build\n"
#~ "cmake ..\n"
#~ "# if you are building with CUDA 10.0, use the line below:\n"
#~ "#   cmake .. -DCUDA_VERSION=10.0 -DTI_WITH_CUDA:BOOL=True\n"
#~ "make -j 8"
#~ msgstr ""

#~ msgid ""
#~ "If you are working on the Taichi"
#~ " compiler and need to build from "
#~ "scratch, see :ref:`dev_install`."
#~ msgstr ""

#~ msgid "(scalar) the size of tensor alone that axis"
#~ msgstr ""

#~ msgid "Copyright (c) 2012 - present, Victor Zverovich"
#~ msgstr ""

#~ msgid ""
#~ "Permission is hereby granted, free of"
#~ " charge, to any person obtaining a"
#~ " copy of this software and associated"
#~ " documentation files (the \"Software\"), to"
#~ " deal in the Software without "
#~ "restriction, including without limitation the"
#~ " rights to use, copy, modify, merge,"
#~ " publish, distribute, sublicense, and/or "
#~ "sell copies of the Software, and "
#~ "to permit persons to whom the "
#~ "Software is furnished to do so, "
#~ "subject to the following conditions:"
#~ msgstr ""

#~ msgid ""
#~ "The above copyright notice and this "
#~ "permission notice shall be included in"
#~ " all copies or substantial portions "
#~ "of the Software."
#~ msgstr ""

#~ msgid ""
#~ "THE SOFTWARE IS PROVIDED \"AS IS\", "
#~ "WITHOUT WARRANTY OF ANY KIND, EXPRESS"
#~ " OR IMPLIED, INCLUDING BUT NOT "
#~ "LIMITED TO THE WARRANTIES OF "
#~ "MERCHANTABILITY, FITNESS FOR A PARTICULAR "
#~ "PURPOSE AND NONINFRINGEMENT. IN NO EVENT"
#~ " SHALL THE AUTHORS OR COPYRIGHT "
#~ "HOLDERS BE LIABLE FOR ANY CLAIM, "
#~ "DAMAGES OR OTHER LIABILITY, WHETHER IN"
#~ " AN ACTION OF CONTRACT, TORT OR "
#~ "OTHERWISE, ARISING FROM, OUT OF OR "
#~ "IN CONNECTION WITH THE SOFTWARE OR "
#~ "THE USE OR OTHER DEALINGS IN THE"
#~ " SOFTWARE."
#~ msgstr ""

#~ msgid "--- Optional exception to the license ---"
#~ msgstr ""

#~ msgid ""
#~ "As an exception, if, as a result"
#~ " of your compiling your source code,"
#~ " portions of this Software are "
#~ "embedded into a machine-executable "
#~ "object form of such source code, "
#~ "you may redistribute such embedded "
#~ "portions in such object form without "
#~ "including the above copyright and "
#~ "permission notices."
#~ msgstr ""

#~ msgid ""
#~ "The first letter of the PR title"
#~ " body should be capitalized, unless "
#~ "the title starts with an identifier:"
#~ msgstr ""

#~ msgid ""
#~ "E.g., \"[doc] improve documentation\" should"
#~ " be formatted as \"[doc] Improve "
#~ "documentation\";"
#~ msgstr ""

#~ msgid ""
#~ "\"[Lang] ti.sqr(x) is now deprecated\" "
#~ "is fine because ``ti`` is an "
#~ "identifier."
#~ msgstr ""

#~ msgid ""
#~ "Please always prepend at least one "
#~ "tag such as ``[Metal]`` to PR "
#~ "titles:"
#~ msgstr ""

#~ msgid ""
#~ "E.g., \"[Metal][refactor]\" (no space) should"
#~ " be formatted as \"[Metal] [refactor]\";"
#~ msgstr ""

#~ msgid "Existing tags:"
#~ msgstr ""

#~ msgid "``[Metal], [OpenGL], [CPU], [CUDA], [AMDGPU], [LLVM]``: backends;"
#~ msgstr ""

#~ msgid ""
#~ "``[Sparse]``: sparse computation, dynamic "
#~ "memory allocator, and garbage collection;"
#~ msgstr ""

#~ msgid "``[Async]``: asynchronous execution engine;"
#~ msgstr ""

#~ msgid "``[Type]``: type system;"
#~ msgstr ""

#~ msgid "``[Infra]``: general infrastructure, e.g. logging, image reader;"
#~ msgstr ""

#~ msgid "``[AutoDiff]``: automatic differentiation;"
#~ msgstr ""

#~ msgid "``[Benchmark]``: Benchmarking & regression tests;"
#~ msgstr ""

#~ msgid "``[PyPI]``: PyPI package release;"
#~ msgstr ""

#~ msgid "``[Workflow]``: GitHub Actions/Workflows;"
#~ msgstr ""

#~ msgid ""
#~ "**When introducing a new tag, please "
#~ "update the list here in the first"
#~ " PR with that tag, so that "
#~ "people can follow.**"
#~ msgstr ""

#~ msgid ""
#~ "PRs with visible/notable features to the"
#~ " users should be marked with tags "
#~ "starting with **the first letter "
#~ "capitalized**, e.g. ``[Metal], [OpenGL], [IR],"
#~ " [Lang], [CLI]``. When releasing a "
#~ "new version, a script will generate "
#~ "a changelog with these changes (PR "
#~ "title) highlighted. Therefore it is "
#~ "**important** to make sure the end-"
#~ "users can understand what your PR "
#~ "does, **based on your PR title**."
#~ msgstr ""

#~ msgid ""
#~ ":ref:`regress` may worth checking out "
#~ "when the work involves IR optimization."
#~ msgstr ""

#~ msgid "``print_kernel_llvm_ir = True``: print the emitted LLVM IR by Taichi."
#~ msgstr ""

#~ msgid ""
#~ "``print_kernel_llvm_ir_optimized = True``: print "
#~ "the optimized LLVM IR for each "
#~ "kernel."
#~ msgstr ""

#~ msgid ""
#~ "Note this is for the compiler "
#~ "developers of the Taichi programming "
#~ "language. End users should use the "
#~ "pip packages instead of building from"
#~ " source. To build with NVIDIA GPU "
#~ "support, CUDA 10.0+ is needed. This "
#~ "installation guide works for Ubuntu "
#~ "16.04+ and OS X 10.14+. For "
#~ "precise build instructions on Windows, "
#~ "please check out `appveyor.yml "
#~ "<https://github.com/taichi-"
#~ "dev/taichi/blob/master/appveyor.yml>`_, which does "
#~ "basically the same thing as the "
#~ "following instructions."
#~ msgstr ""

#~ msgid "Installing Depedencies"
#~ msgstr ""

#~ msgid "Execute"
#~ msgstr ""

#~ msgid ""
#~ "python3 -m pip install --user setuptools"
#~ " astpretty astor pytest opencv-python "
#~ "pybind11\n"
#~ "python3 -m pip install --user Pillow "
#~ "numpy scipy GitPython yapf colorama "
#~ "psutil autograd"
#~ msgstr ""

#~ msgid ""
#~ "(If on Ubuntu) Execute ``sudo apt "
#~ "install libtinfo-dev clang-8``. (``clang-7``"
#~ " should work as well)."
#~ msgstr ""

#~ msgid "(If on other Linux distributions) Please build clang 8.0.1 from source:"
#~ msgstr ""

#~ msgid "Make sure you have LLVM 8.0.1 built from source. To do so:"
#~ msgstr ""

#~ msgid ""
#~ "wget https://github.com/llvm/llvm-"
#~ "project/releases/download/llvmorg-8.0.1/llvm-8.0.1.src.tar.xz\n"
#~ "tar xvJf llvm-8.0.1.src.tar.xz\n"
#~ "cd llvm-8.0.1.src\n"
#~ "mkdir build\n"
#~ "cd build\n"
#~ "cmake .. -DLLVM_ENABLE_RTTI:BOOL=ON "
#~ "-DBUILD_SHARED_LIBS:BOOL=OFF -DCMAKE_BUILD_TYPE=Release "
#~ "-DLLVM_TARGETS_TO_BUILD=\"X86;NVPTX\" "
#~ "-DLLVM_ENABLE_ASSERTIONS=ON\n"
#~ "# If you are building on NVIDIA"
#~ " Jetson TX2, use "
#~ "-DLLVM_TARGETS_TO_BUILD=\"ARM;NVPTX\"\n"
#~ "make -j 8\n"
#~ "sudo make install"
#~ msgstr ""

#~ msgid "Prebuilt LLVM for Windows CI"
#~ msgstr ""

#~ msgid ""
#~ "cmake .. -G\"Visual Studio 15 2017 "
#~ "Win64\"  -DLLVM_ENABLE_RTTI:BOOL=ON "
#~ "-DBUILD_SHARED_LIBS:BOOL=OFF -DCMAKE_BUILD_TYPE=Release "
#~ "-DLLVM_TARGETS_TO_BUILD=\"X86;NVPTX\" "
#~ "-DLLVM_ENABLE_ASSERTIONS=ON -Thost=x64 "
#~ "-DLLVM_BUILD_TESTS:BOOL=OFF -DCMAKE_INSTALL_PREFIX=installed"
#~ msgstr ""

#~ msgid ""
#~ "Then use Visual Studio to build. "
#~ "After building the ``INSTALL`` project "
#~ "(under folder \"CMakePredefinedTargets\"). After "
#~ "build completes, find your LLVM "
#~ "binaries/headers in `build/include`."
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "import numpy as np\n"
#~ "\n"
#~ "ti.init()\n"
#~ "\n"
#~ "n = 4\n"
#~ "m = 7\n"
#~ "\n"
#~ "# Taichi tensors\n"
#~ "val = ti.var(ti.i32, shape=(n, m))\n"
#~ "vec = ti.Vector(3, dt=ti.i32, shape=(n, m))\n"
#~ "mat = ti.Matrix(3, 4, dt=ti.i32, shape=(n, m))\n"
#~ "\n"
#~ "# Scalar\n"
#~ "arr = np.ones(shape=(n, m), dtype=np.int32)\n"
#~ "\n"
#~ "val.from_numpy(arr)\n"
#~ "\n"
#~ "arr = val.to_numpy()\n"
#~ "\n"
#~ "# Vector\n"
#~ "arr = np.ones(shape=(n, m, 3), dtype=np.int32)\n"
#~ "\n"
#~ "vec.from_numpy(arr)\n"
#~ "\n"
#~ "arr = np.ones(shape=(n, m, 3, 1), dtype=np.int32)\n"
#~ "vec.from_numpy(arr)\n"
#~ "\n"
#~ "arr = vec.to_numpy()\n"
#~ "assert arr.shape == (n, m, 3, 1)\n"
#~ "\n"
#~ "arr = vec.to_numpy(as_vector=True)\n"
#~ "assert arr.shape == (n, m, 3)\n"
#~ "\n"
#~ "# Matrix\n"
#~ "arr = np.ones(shape=(n, m, 3, 4), dtype=np.int32)\n"
#~ "\n"
#~ "mat.from_numpy(arr)\n"
#~ "\n"
#~ "arr = mat.to_numpy()\n"
#~ "assert arr.shape == (n, m, 3, 4)"
#~ msgstr ""

#~ msgid ""
#~ "Restart the Taichi runtime system (clear"
#~ " memory, destroy all variables and "
#~ "kernels): ``ti.reset()``"
#~ msgstr ""

#~ msgid "Eliminate verbose outputs: ``ti.get_runtime().set_verbose(False)``"
#~ msgstr ""

#~ msgid "To not trigger GDB when crashes: ``export TI_GDB_TRIGGER=0``"
#~ msgstr ""

#~ msgid "To not use unified memory for CUDA: ``export TI_USE_UNIFIED_MEMORY=0``"
#~ msgstr ""

#~ msgid ""
#~ "To specify pre-allocated memory size "
#~ "for CUDA: ``export TI_DEVICE_MEMORY_GB=0.5``"
#~ msgstr ""

#~ msgid "Show more detailed log (TI_TRACE): ``export TI_LOG_LEVEL=trace``"
#~ msgstr ""

#~ msgid ""
#~ "To specify which GPU to use for"
#~ " CUDA: ``export CUDA_VISIBLE_DEVICES=[gpuid]``"
#~ msgstr ""

#~ msgid "To specify which Arch to use: ``export TI_ARCH=cuda``"
#~ msgstr ""

#~ msgid "To print intermediate IR generated: ``export TI_PRINT_IR=1``"
#~ msgstr ""

#~ msgid "To print verbose details: ``export TI_VERBOSE=1``"
#~ msgstr ""

#~ msgid ""
#~ "When using ``float32`` or ``float64`` as"
#~ " the data type, ``img`` entries will"
#~ " be clipped into range ``[0, 1]``."
#~ msgstr ""

#~ msgid ""
#~ "ti.GUI.ESCAPE\n"
#~ "ti.GUI.SHIFT\n"
#~ "ti.GUI.LEFT\n"
#~ "'a'\n"
#~ "'b'\n"
#~ "...\n"
#~ "ti.GUI.LMB\n"
#~ "ti.GUI.RMB"
#~ msgstr ""

#~ msgid ""
#~ "while gui.get_event():\n"
#~ "    print('Event key', gui.event.key)"
#~ msgstr ""

#~ msgid ""
#~ "img = ti.imread('hello.png')\n"
#~ "ti.imshow(img, 'Window Title')\n"
#~ "ti.imwrite(img, 'hello2.png')"
#~ msgstr ""

#~ msgid "TODO: complete here"
#~ msgstr ""

#~ msgid ""
#~ "Running the Taichi code below (``python3"
#~ " fractal.py``) will give you an "
#~ "animation of `Julia set "
#~ "<https://en.wikipedia.org/wiki/Julia_set>`_:"
#~ msgstr ""

#~ msgid "Currently, Taichi only supports Python 3.6/3.7/3.8."
#~ msgstr ""

#~ msgid ""
#~ "If Taichi crashes and reports "
#~ "``libtinfo.so.5 not found``: Please install"
#~ " ``libtinfo5`` on Ubuntu or ``ncurses5"
#~ "-compat-libs`` (AUR) on Arch Linux."
#~ msgstr ""

#~ msgid "``ti.transposed(A)`` or simply ``A.T()``"
#~ msgstr ""

#~ msgid "``ti.inverse(A)``"
#~ msgstr ""

#~ msgid "``ti.Matrix.abs(A)``"
#~ msgstr ""

#~ msgid "``ti.tr(A)``"
#~ msgstr ""

#~ msgid "``ti.determinant(A, type)``"
#~ msgstr ""

#~ msgid ""
#~ "``ti.cross(a, b)``, where ``a`` and "
#~ "``b`` are 3D vectors (i.e. ``3x1`` "
#~ "matrices)"
#~ msgstr ""

#~ msgid "``A.cast(type)``"
#~ msgstr ""

#~ msgid "(scalar or tuple) shape the tensor of vectors, see :ref:`tensor`"
#~ msgstr ""

#~ msgid ""
#~ "For example, this creates a 2x2 "
#~ "matrix with components (2, 3) in "
#~ "the first row and (4, 5) in "
#~ "the second row: ::"
#~ msgstr ""

#~ msgid ""
#~ "# Taichi-scope\n"
#~ "a = ti.Matrix([[2, 3], [4, 5])"
#~ msgstr ""

#~ msgid ""
#~ "# Taichi-scope\n"
#~ "v0 = ti.Vector([1.0, 2.0, 3.0])\n"
#~ "v1 = ti.Vector([4.0, 5.0, 6.0])\n"
#~ "v2 = ti.Vector([7.0, 8.0, 9.0])\n"
#~ "\n"
#~ "# to specify data in rows\n"
#~ "a = ti.Matrix(rows=[v0, v1, v2])\n"
#~ "\n"
#~ "# to specify data in columns instead\n"
#~ "a = ti.Matrix(cols=[v0, v1, v2])\n"
#~ "\n"
#~ "# lists can be used instead of vectors\n"
#~ "a = ti.Matrix(rows=[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])"
#~ msgstr ""

#~ msgid "a[2] = 2"
#~ msgstr ""

#~ msgid ""
#~ "(optional, scalar) the number of parent"
#~ " steps, i.e. ``n=1`` for parent, "
#~ "``n=2`` grandparent, etc..."
#~ msgstr ""

#~ msgid "::"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.i32) y = ti.var(ti.i32)"
#~ " blk1 = ti.root.dense(ti.ij, (6, 5)) "
#~ "blk2 = blk1.dense(ti.ij, (3, 2)) "
#~ "blk1.place(x) blk2.place(y)"
#~ msgstr ""

#~ msgid "x.parent()   # blk1 y.parent()   # blk2 y.parent(2)  # blk1"
#~ msgstr ""

#~ msgid ""
#~ "B = ti.Matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n"
#~ "\n"
#~ "A = ti.sin(B)\n"
#~ "# is equivalent to\n"
#~ "for i in ti.static(range(2)):\n"
#~ "    for j in ti.static(range(3)):\n"
#~ "        A[i, j] = ti.sin(B[i, j])"
#~ msgstr ""

#~ msgid ""
#~ "Debug your program with ``print(x)``. "
#~ "For example, if ``x`` is ``23``, "
#~ "then it prints"
#~ msgstr ""

#~ msgid "[debug] x = 23"
#~ msgstr ""

#~ msgid "in the console."
#~ msgstr ""

#~ msgid ""
#~ "This is not the same as the "
#~ "``print`` in Python-scope. For now "
#~ "``print`` in Taichi only takes **scalar"
#~ " numbers** as input. Strings, vectors "
#~ "and matrices are not supported. Please"
#~ " use ``print(v[0]); print(v[1])`` if you"
#~ " want to print a vector."
#~ msgstr ""

#~ msgid "See :ref:`tensor` for more details."
#~ msgstr ""

#~ msgid "(Vector, 3 component)"
#~ msgstr ""

#~ msgid "(Vector, 3D) the cross product of ``a`` and ``b``"
#~ msgstr ""

#~ msgid ""
#~ "a = ti.Vector([1, 2, 3])\n"
#~ "b = ti.Vector([4, 5, 6])\n"
#~ "c = ti.cross(a, b) # [2*6 - 5*3, 4*3 - 1*6, 1*5 - 4*2]"
#~ msgstr ""

#~ msgid ""
#~ "This is not the same as "
#~ "``ti.cross``. ``a`` and ``b`` do not "
#~ "have to be 3-component vectors."
#~ msgstr ""

#~ msgid "The life of a Taichi kernel"
#~ msgstr ""

#~ msgid "Life cycle of a Taichi kernel looks like this:"
#~ msgstr ""

#~ msgid "Taichi IR compilation, optimization, and binary generation"
#~ msgstr ""

#~ msgid "We also allocate two 1D tensors to simplify discussion:"
#~ msgstr ""

#~ msgid ""
#~ "When you have a second call with"
#~ " the same template signature (explained "
#~ "later), e.g.,"
#~ msgstr ""

#~ msgid ""
#~ "**Template signatures** are what distinguish"
#~ " different instantiations of a kernel "
#~ "template. The signature of ``add(x, "
#~ "42)`` is ``(x, ti.i32)``, which is "
#~ "the same as that of ``add(x, 1)``."
#~ " Therefore, the latter can reuse the"
#~ " previously compiled binary. The signature"
#~ " of ``add(y, 42)`` is ``(y, "
#~ "ti.i32)``, a different value from the"
#~ " previous signature, therefore a new "
#~ "instantiation and compilation will happen."
#~ msgstr ""

#~ msgid ""
#~ "Many basic operations in the Taichi "
#~ "standard library is implemented using "
#~ "Taichi kernels for performance, with "
#~ "more or less metaprogramming tricks. "
#~ "Invoking them will incur **implicit "
#~ "kernel instantiations**"
#~ msgstr ""

#~ msgid ""
#~ "When a new instantiation happens, the"
#~ " Taichi frontend compiler will transform"
#~ " the kernel body AST into a "
#~ "Python script, which, when executed, "
#~ "emits a Taichi frontend AST. Basically,"
#~ " some patches are applied to the "
#~ "Python AST so that the Taichi "
#~ "frontend can recognize it."
#~ msgstr ""

#~ msgid ""
#~ "Finally, the optimized SSA IR is "
#~ "fed into the LLVM IR codegen, and"
#~ " LLVM JIT generates high-performance "
#~ "executable CPU/GPU programs."
#~ msgstr ""

#~ msgid ""
#~ "Taichi kernels will be ultimately "
#~ "launched as multi-threaded CPU tasks "
#~ "or CUDA kernels."
#~ msgstr ""

#~ msgid "``[Metal], [OpenGL], [CPU], [CUDA], [LLVM]``: backends;"
#~ msgstr ""

#~ msgid "Tests should be added to ``taichi/tests``."
#~ msgstr ""

#~ msgid ""
#~ "Use ``ti test <filename(s)>`` to run "
#~ "specific tests. e.g. ``ti test "
#~ "numpy_io`` and ``ti test test_numpy_io.py``"
#~ " are equivalent."
#~ msgstr ""

#~ msgid ""
#~ "Use ``ti test -a <arch(s)>`` for "
#~ "test against specified architectures. e.g. "
#~ "``ti test -a opengl`` or ``ti test"
#~ " numpy_io -a cuda,metal``."
#~ msgstr ""

#~ msgid ""
#~ "Use ``ti test -na <arch(s)>`` for "
#~ "test all architectures exclude some of"
#~ " them. e.g. ``ti test -na "
#~ "opengl,cuda``."
#~ msgstr ""

#~ msgid ""
#~ "Use ``ti test -c`` to run only "
#~ "the C++ tests. e.g. ``ti test -c"
#~ " alg_simp``"
#~ msgstr ""

#~ msgid "Open the documentation at ``taichi/doc/build/index.html``."
#~ msgstr ""

#~ msgid "``gui``:  GUI"
#~ msgstr ""

#~ msgid "``inc``:  Small definition files to be included repeatedly"
#~ msgstr ""

#~ msgid "``jit``: JIT-in-time compilation base classes"
#~ msgstr ""

#~ msgid "``llvm``: LLVM utils"
#~ msgstr ""

#~ msgid "``math``: Math utils"
#~ msgstr ""

#~ msgid "``runtime``: Runtime environments"
#~ msgstr ""

#~ msgid "``python``: Python frontend implementation"
#~ msgstr ""

#~ msgid "``tests``: C++ and Python tests"
#~ msgstr ""

#~ msgid ""
#~ "To generate the slimmed version of "
#~ "libdevice based on a full "
#~ "``libdevice.X.bc`` file from a CUDA "
#~ "installation, use ``ti run make_slim_libdevice"
#~ " [libdevice.X.bc file]``"
#~ msgstr ""

#~ msgid ""
#~ "python3 -m pip install --user setuptools"
#~ " astpretty astor pybind11 Pillow\n"
#~ "python3 -m pip install --user pytest "
#~ "pytest-rerunfailures pytest-xdist yapf\n"
#~ "python3 -m pip install --user numpy "
#~ "GitPython coverage colorama autograd"
#~ msgstr ""

#~ msgid "Make sure you have ``clang`` with version >= 7"
#~ msgstr ""

#~ msgid ""
#~ "On Windows: Download ``clang-8`` via "
#~ "`this link "
#~ "<https://releases.llvm.org/8.0.0/LLVM-8.0.0-win64.exe>`_. Make"
#~ " sure you add the ``bin`` folder "
#~ "containing ``clang.exe`` to the ``PATH`` "
#~ "environment variable."
#~ msgstr ""

#~ msgid "On other Linux distributions, please build clang 8.0.1 from source:"
#~ msgstr ""

#~ msgid ""
#~ "wget https://github.com/llvm/llvm-"
#~ "project/releases/download/llvmorg-8.0.1/cfe-8.0.1.src.tar.xz\n"
#~ "tar xvJf cfe-8.0.1.src.tar.xz\n"
#~ "cd cfe-8.0.1.src\n"
#~ "mkdir build\n"
#~ "cd build\n"
#~ "cmake ..\n"
#~ "make -j 8\n"
#~ "sudo make install"
#~ msgstr ""

#~ msgid ""
#~ "Make sure you have LLVM 8.0.1/10.0.0."
#~ " Note that Taichi uses a customized"
#~ " LLVM so the pre-built binaries "
#~ "from the LLVM official website or "
#~ "other sources probably doesn't work. "
#~ "Here we provide LLVM 8.0.1 binaries "
#~ "customized for Taichi, which may or "
#~ "may not work depending on your "
#~ "system environment: `Linux <https://github.com"
#~ "/yuanming-hu/taichi_assets/releases/download/llvm8/taichi-"
#~ "llvm-8.0.1-linux-x64.zip>`_, `OS X "
#~ "<https://github.com/yuanming-"
#~ "hu/taichi_assets/releases/download/llvm8/taichi-"
#~ "llvm-8.0.1.zip>`_, `Windows <https://github.com"
#~ "/yuanming-hu/taichi_assets/releases/download/llvm8/taichi-"
#~ "llvm-8.0.1-msvc2017.zip>`_."
#~ msgstr ""

#~ msgid ""
#~ "wget https://github.com/llvm/llvm-"
#~ "project/releases/download/llvmorg-8.0.1/llvm-8.0.1.src.tar.xz\n"
#~ "tar xvJf llvm-8.0.1.src.tar.xz\n"
#~ "cd llvm-8.0.1.src\n"
#~ "# For LLVM 10.0.0:\n"
#~ "#     wget https://github.com/llvm/llvm-"
#~ "project/releases/download/llvmorg-10.0.0/llvm-10.0.0.src.tar.xz\n"
#~ ""
#~ "#     tar xvJf llvm-10.0.0.src.tar.xz\n"
#~ "#     cd llvm-10.0.0.src\n"
#~ "mkdir build\n"
#~ "cd build\n"
#~ "cmake .. -DLLVM_ENABLE_RTTI:BOOL=ON "
#~ "-DBUILD_SHARED_LIBS:BOOL=OFF -DCMAKE_BUILD_TYPE=Release "
#~ "-DLLVM_TARGETS_TO_BUILD=\"X86;NVPTX\" "
#~ "-DLLVM_ENABLE_ASSERTIONS=ON\n"
#~ "# If you are building on NVIDIA"
#~ " Jetson TX2, use "
#~ "-DLLVM_TARGETS_TO_BUILD=\"ARM;NVPTX\"\n"
#~ "\n"
#~ "make -j 8\n"
#~ "sudo make install\n"
#~ "\n"
#~ "# Check your LLVM installation\n"
#~ "llvm-config --version # You should get 8.0.1 or 10.0.0"
#~ msgstr ""

#~ msgid ""
#~ "# LLVM 8.0.1 + MSVC 2017\n"
#~ "cmake .. -G\"Visual Studio 15 2017 "
#~ "Win64\"  -DLLVM_ENABLE_RTTI:BOOL=ON "
#~ "-DBUILD_SHARED_LIBS:BOOL=OFF -DCMAKE_BUILD_TYPE=Release "
#~ "-DLLVM_TARGETS_TO_BUILD=\"X86;NVPTX\" "
#~ "-DLLVM_ENABLE_ASSERTIONS=ON -Thost=x64 "
#~ "-DLLVM_BUILD_TESTS:BOOL=OFF -DCMAKE_INSTALL_PREFIX=installed"
#~ "\n"
#~ "\n"
#~ "# LLVM 10.0.0 + MSVC 2019\n"
#~ "cmake .. -G\"Visual Studio 16 2019\" "
#~ "-A x64  -DLLVM_ENABLE_RTTI:BOOL=ON "
#~ "-DBUILD_SHARED_LIBS:BOOL=OFF -DCMAKE_BUILD_TYPE=Release "
#~ "-DLLVM_TARGETS_TO_BUILD=\"X86;NVPTX\" "
#~ "-DLLVM_ENABLE_ASSERTIONS=ON -Thost=x64 "
#~ "-DLLVM_BUILD_TESTS:BOOL=OFF -DCMAKE_INSTALL_PREFIX=installed"
#~ msgstr ""

#~ msgid ""
#~ "git clone https://github.com/taichi-dev/taichi "
#~ "--depth=1 --branch=master\n"
#~ "cd taichi\n"
#~ "git submodule update --init --recursive --depth=1\n"
#~ "mkdir build\n"
#~ "cd build\n"
#~ "cmake ..\n"
#~ "# if you do not set clang as the default compiler\n"
#~ "# use the line below:\n"
#~ "#   cmake .. -DCMAKE_CXX_COMPILER=clang-8\n"
#~ "#\n"
#~ "# Alternatively, if you would like "
#~ "to set clang as the default "
#~ "compiler\n"
#~ "# On Unix CMake honors environment "
#~ "variables $CC and $CXX upon deciding "
#~ "which C and C++ compilers to use"
#~ "\n"
#~ "#\n"
#~ "# if you are building with CUDA 10.0, use the line below:\n"
#~ "#   cmake .. -DCUDA_VERSION=10.0 -DTI_WITH_CUDA:BOOL=True\n"
#~ "make -j 8"
#~ msgstr ""

#~ msgid "Add the following script to your ``~/.bashrc``:"
#~ msgstr ""

#~ msgid ""
#~ "export TAICHI_REPO_DIR=/home/XXX/taichi  # Path "
#~ "to your taichi repository\n"
#~ "export PYTHONPATH=$TAICHI_REPO_DIR/python/:$PYTHONPATH\n"
#~ "export PATH=$TAICHI_REPO_DIR/bin/:$PATH\n"
#~ "# export PATH=/opt/llvm/bin:$PATH # Uncomment"
#~ " if your llvm-8 or clang-8 is "
#~ "in /opt"
#~ msgstr ""

#~ msgid "Execute ``source ~/.bashrc`` to reload shell config."
#~ msgstr ""

#~ msgid ""
#~ "Check out ``examples`` for runnable "
#~ "examples. Run them with ``python3``."
#~ msgstr ""

#~ msgid "Run with debug mode to see if there's any illegal memory access"
#~ msgstr ""

#~ msgid ""
#~ "Disable compiler optimizations to quickly "
#~ "confirm that the issue is not "
#~ "cause by optimization"
#~ msgstr ""

#~ msgid ""
#~ "``ti.VideoManger`` can help you export "
#~ "results in ``mp4`` or ``gif`` format."
#~ " For example,"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "\n"
#~ "ti.init()\n"
#~ "\n"
#~ "pixels = ti.var(ti.u8, shape=(512, 512, 3))\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def paint():\n"
#~ "    for i, j, k in pixels:\n"
#~ "        pixels[i, j, k] = ti.random() * 255\n"
#~ "\n"
#~ "result_dir = \"./results\"\n"
#~ "video_manger = ti.VideoManager(output_dir=result_dir, "
#~ "framerate=24, automatic_build=False)\n"
#~ "\n"
#~ "for i in range(50):\n"
#~ "    paint()\n"
#~ "\n"
#~ "    pixels_img = pixels.to_numpy()\n"
#~ "    video_manger.write_frame(pixels_img)\n"
#~ "    print(f'\\rFrame {i+1}/50 is recorded', end='')\n"
#~ "\n"
#~ "print()\n"
#~ "print('Exporting .mp4 and .gif videos...')\n"
#~ "video_manger.make_video(gif=True, mp4=True)\n"
#~ "print(f'MP4 video is saved to "
#~ "{video_manger.get_output_filename(\".mp4\")}')\n"
#~ "print(f'GIF video is saved to "
#~ "{video_manger.get_output_filename(\".gif\")}')"
#~ msgstr ""

#~ msgid ""
#~ "**A:** These structures have to be "
#~ "represented using 1D arrays in Taichi."
#~ " You can still iterate over them "
#~ "using ``for i in x`` or ``for "
#~ "i in range(n)``. However, at compile "
#~ "time, there's little the Taichi compiler"
#~ " can do for you to optimize it."
#~ " You can still tweak the data "
#~ "layout to get different runtime cache"
#~ " behaviors and performance numbers."
#~ msgstr ""

#~ msgid ""
#~ "To specify which Arch to use: "
#~ "``export TI_ARCH=cuda`` or "
#~ "``ti.init(arch=ti.cuda)``."
#~ msgstr ""

#~ msgid ""
#~ "To specify pre-allocated memory size "
#~ "for CUDA: ``export TI_DEVICE_MEMORY_GB=0.5`` "
#~ "or ``ti.init(device_memory_GB=0.5)``."
#~ msgstr ""

#~ msgid ""
#~ "To disable unified memory usage on "
#~ "CUDA: ``export TI_USE_UNIFIED_MEMORY=0``."
#~ msgstr ""

#~ msgid ""
#~ "Disable advanced optimization to save "
#~ "compile time & possible erros: "
#~ "``ti.core.toggle_advanced_optimization(False)`` or "
#~ "``export TI_ADVANCED_OPTIMIZATION=0``."
#~ msgstr ""

#~ msgid ""
#~ "To print intermediate IR generated: "
#~ "``export TI_PRINT_IR=1`` or "
#~ "``ti.init(print_ir=True)``."
#~ msgstr ""

#~ msgid ""
#~ "To print preprocessed Python code: "
#~ "``export TI_PRINT_PREPROCESSED=1`` or "
#~ "``ti.init(print_preprocessed=True)``.."
#~ msgstr ""

#~ msgid ""
#~ "To start program in debug mode: "
#~ "``export TI_DEBUG=1`` or ``ti.init(debug=True)``."
#~ msgstr ""

#~ msgid ""
#~ "Show more detailed log to level "
#~ "TRACE: ``export TI_LOG_LEVEL=trace`` or "
#~ "``ti.set_logging_level(ti.TRACE)``."
#~ msgstr ""

#~ msgid ""
#~ "Eliminate verbose outputs: "
#~ "``ti.get_runtime().set_verbose(False)`` or "
#~ "``TI_VERBOSE=0``."
#~ msgstr ""

#~ msgid "To trigger GDB when Taichi crashes: ``export TI_GDB_TRIGGER=1``."
#~ msgstr ""

#~ msgid ""
#~ "Every event have a key and type."
#~ " *Event key* is the key that "
#~ "you pressed on keyboard or mouse, "
#~ "can be one of:"
#~ msgstr ""

#~ msgid ""
#~ "ti.GUI.ESCAPE  # Esc\n"
#~ "ti.GUI.SHIFT   # Shift\n"
#~ "ti.GUI.LEFT    # Left Arrow\n"
#~ "'a'            # we use lowercase for alphabet\n"
#~ "'b'\n"
#~ "...\n"
#~ "ti.GUI.LMB     # Left Mouse Button\n"
#~ "ti.GUI.RMB     # Right Mouse Button"
#~ msgstr ""

#~ msgid ""
#~ "ti.GUI.RELEASE  # key up\n"
#~ "ti.GUI.PRESS    # key down\n"
#~ "ti.GUI.MOTION   # mouse moved"
#~ msgstr ""

#~ msgid ""
#~ "for e in gui.get_events():\n"
#~ "    if e.key == ti.GUI.ESCAPE:\n"
#~ "        exit()\n"
#~ "    elif e.type == ti.GUI.SPACE:\n"
#~ "        do_something()\n"
#~ "    elif e.type in ['a', ti.GUI.LEFT]:\n"
#~ "        ..."
#~ msgstr ""

#~ msgid "Interacting with Python"
#~ msgstr ""

#~ msgid ""
#~ "Everything outside Taichi-scopes (``ti.func``"
#~ " and ``ti.kernel``) is simply Python "
#~ "code. In Python-scopes, you can "
#~ "access Taichi tensor elements using "
#~ "plain indexing syntax. For example, to"
#~ " access a single pixel of the "
#~ "rendered image in Python, simply use"
#~ msgstr ""

#~ msgid ""
#~ "pixels[42, 11] = 0.7\n"
#~ "print(pixels[42, 11]) # prints 0.7"
#~ msgstr ""

#~ msgid ""
#~ "You can also use your favorite "
#~ "Python packages (e.g. ``numpy``, ``pytorch``,"
#~ " ``matplotlib``) together with Taichi. "
#~ "Taichi provides helper functions such as"
#~ " ``from_numpy`` and ``to_torch`` for tensor"
#~ " format conversion:"
#~ msgstr ""

#~ msgid ""
#~ "import numpy as np\n"
#~ "pixels.from_numpy(np.random.rand(n * 2, n))\n"
#~ "\n"
#~ "import matplotlib.pyplot as plt\n"
#~ "plt.imshow(pixels.to_numpy())\n"
#~ "plt.show()"
#~ msgstr ""

#~ msgid ""
#~ "If Taichi crashes and reports "
#~ "``libtinfo.so.5 not found``: Please install"
#~ " ``libtinfo5`` for Ubuntu or ``ncurses5"
#~ "-compat-libs`` (AUR) for Arch Linux."
#~ msgstr ""

#~ msgid "``A.inverse()``"
#~ msgstr ""

#~ msgid "``A.trace()``"
#~ msgstr ""

#~ msgid "``A.determinant()``"
#~ msgstr ""

#~ msgid "``A.cast(type)`` or simply ``int(A)`` and ``float(A)``"
#~ msgstr ""

#~ msgid "``any(A)``"
#~ msgstr ""

#~ msgid "``all(A)``"
#~ msgstr ""

#~ msgid ""
#~ "Currently, only ``+, -, @`` Matrix "
#~ "operations have experimental support in "
#~ "Python-scope. An exception will be "
#~ "raised if you try to apply other"
#~ " operations in Python-scope, use them"
#~ " in Taichi-scope (`@ti.kernel`) instead."
#~ msgstr ""

#~ msgid ""
#~ "# Python-scope\n"
#~ "a = ti.Matrix(3, 3, dt=ti.f32, shape=(5, 4))"
#~ msgstr ""

#~ msgid "For example, this creates a 3x1 matrix with components (2, 3, 4): ::"
#~ msgstr ""

#~ msgid ""
#~ "# Taichi-scope\n"
#~ "a = ti.Matrix([2, 3, 4])"
#~ msgstr ""

#~ msgid "this is equivalent to ti.Vector([x, y, ...])"
#~ msgstr ""

#~ msgid "TODO: WIP"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def copy(x: ti.template(), y: ti.template()):\n"
#~ "    for i in x:\n"
#~ "        y[i] = x[i]"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def copy(x: ti.template(), y: ti.template()):\n"
#~ "    for I in ti.grouped(y):\n"
#~ "        x[I] = y[I]\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def array_op(x: ti.template(), y: ti.template()):\n"
#~ "    # If tensor x is 2D\n"
#~ "    for I in ti.grouped(x): # I"
#~ " is a vector of size x.dim() "
#~ "and data type i32\n"
#~ "        y[I + ti.Vector([0, 1])] = I[0] + I[1]\n"
#~ "    # is equivalent to\n"
#~ "    for i, j in x:\n"
#~ "        y[i, j + 1] = i + j"
#~ msgstr ""

#~ msgid "Tensor size reflection"
#~ msgstr ""

#~ msgid ""
#~ "Sometimes it will be useful to get"
#~ " the dimensionality (``tensor.dim()``) and "
#~ "shape (``tensor.shape()``) of tensors. These"
#~ " functions can be used in both "
#~ "Taichi kernels and python scripts."
#~ msgstr ""

#~ msgid ""
#~ "@ti.func\n"
#~ "def print_tensor_size(x: ti.template()):\n"
#~ "  print(x.dim())\n"
#~ "  for i in ti.static(range(x.dim())):\n"
#~ "    print(x.shape()[i])"
#~ msgstr ""

#~ msgid ""
#~ "Use ``ti.static`` for compile-time "
#~ "branching (for those who come from "
#~ "C++17, this is `if constexpr "
#~ "<https://en.cppreference.com/w/cpp/language/if>`_.)"
#~ msgstr ""

#~ msgid "Use ``ti.static`` for forced loop unrolling"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def g2p(f: ti.i32):\n"
#~ "for p in range(0, n_particles):\n"
#~ " base = ti.cast(x[f, p] * inv_dx - 0.5, ti.i32)\n"
#~ " fx = x[f, p] * inv_dx - ti.cast(base, real)\n"
#~ " w = [0.5 * ti.sqr(1.5 - fx), 0.75 - ti.sqr(fx - 1.0),\n"
#~ "      0.5 * ti.sqr(fx - 0.5)]\n"
#~ " new_v = ti.Vector([0.0, 0.0])\n"
#~ " new_C = ti.Matrix([[0.0, 0.0], [0.0, 0.0]])\n"
#~ "\n"
#~ " # Unrolled 9 iterations for higher performance\n"
#~ " for i in ti.static(range(3)):\n"
#~ "   for j in ti.static(range(3)):\n"
#~ "     dpos = ti.cast(ti.Vector([i, j]), real) - fx\n"
#~ "     g_v = grid_v_out[base(0) + i, base(1) + j]\n"
#~ "     weight = w[i](0) * w[j](1)\n"
#~ "     new_v += weight * g_v\n"
#~ "     new_C += 4 * weight * ti.outer_product(g_v, dpos) * inv_dx\n"
#~ "\n"
#~ " v[f + 1, p] = new_v\n"
#~ " x[f + 1, p] = x[f, p] + dt * v[f + 1, p]\n"
#~ " C[f + 1, p] = new_C"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def reset():\n"
#~ "  for i in x:\n"
#~ "    for j in ti.static(range(3)):\n"
#~ "      # The inner loop must be "
#~ "unrolled since j is a vector index"
#~ " instead\n"
#~ "      # of a global tensor index.\n"
#~ "      x[i][j] = 0"
#~ msgstr ""

#~ msgid ""
#~ "The dimensionality of tensor shapes "
#~ "should **be consistent** with that of"
#~ " the offset. Otherwise, a ``ValueError``"
#~ " will be raised."
#~ msgstr ""

#~ msgid "(scalar) the length of ``a``"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.i32, (6, 5))\n"
#~ "x.dim()  # 2\n"
#~ "\n"
#~ "y = ti.var(ti.i32, 6)\n"
#~ "y.dim()  # 1\n"
#~ "\n"
#~ "z = ti.var(ti.i32, ())\n"
#~ "z.dim()  # 0"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.i32, (6, 5))\n"
#~ "x.shape()  # (6, 5)\n"
#~ "\n"
#~ "y = ti.var(ti.i32, 6)\n"
#~ "y.shape()  # (6,)\n"
#~ "\n"
#~ "z = ti.var(ti.i32, ())\n"
#~ "z.shape()  # ()"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.i32, (2, 3))\n"
#~ "x.data_type()  # ti.i32"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(dt=ti.i32)\n"
#~ "y = ti.var(dt=ti.f32)\n"
#~ "ti.root.place(x, y)"
#~ msgstr ""

#~ msgid ""
#~ "ti.root.dense(ti.ijk, (3, 5, 4)).place(x)\n"
#~ "x.shape() # returns (3, 5, 4)"
#~ msgstr ""

#~ msgid "axis (0 for ``i`` and 1 for ``j``)"
#~ msgstr ""

#~ msgid "(scalar) the size of tensor along that axis"
#~ msgstr ""

#~ msgid "Equivalent to ``tensor.shape()[i]``."
#~ msgstr ""

#~ msgid ""
#~ "ti.root.dense(ti.ijk, (3, 5, 4)).place(x)\n"
#~ "x.snode().get_shape(0)  # 3\n"
#~ "x.snode().get_shape(1)  # 5\n"
#~ "x.snode().get_shape(2)  # 4"
#~ msgstr ""

#~ msgid "(scalar) the dimensionality of the tensor"
#~ msgstr ""

#~ msgid "Equivalent to ``len(tensor.shape())``."
#~ msgstr ""

#~ msgid ""
#~ "ti.root.dense(ti.ijk, (8, 9, 10)).place(x)\n"
#~ "x.dim()  # 3"
#~ msgstr ""

#~ msgid ""
#~ "blk1 = ti.root.dense(ti.i, 8)\n"
#~ "blk2 = blk1.dense(ti.j, 4)\n"
#~ "blk3 = blk2.bitmasked(ti.k, 6)\n"
#~ "blk1.parent()  # ti.root\n"
#~ "blk2.parent()  # blk1\n"
#~ "blk3.parent()  # blk2"
#~ msgstr ""

#~ msgid "(scalar) the current size of the dynamic node"
#~ msgstr ""

#~ msgid "(``int32``) the size of the dynamic node, before appending"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def inside_taichi_scope():\n"
#~ "    x = 233\n"
#~ "    print('hello', x)\n"
#~ "    #=> hello 233\n"
#~ "\n"
#~ "    m = ti.Matrix([[2, 3, 4], [5, 6, 7]])\n"
#~ "    print('m is', m)\n"
#~ "    #=> m is [[2, 3, 4], [5, 6, 7]]\n"
#~ "\n"
#~ "    v = ti.Vector([3, 4])\n"
#~ "    print('v is', v)\n"
#~ "    #=> v is [3, 4]"
#~ msgstr ""

#~ msgid "For now, print is only supported on CPU, CUDA and OpenGL backends."
#~ msgstr ""

#~ msgid ""
#~ "For the CUDA backend, the printed "
#~ "result won't shows up until "
#~ "``ti.sync()``:"
#~ msgstr ""

#~ msgid ""
#~ "before kernel\n"
#~ "after kernel\n"
#~ "inside kernel\n"
#~ "after"
#~ msgstr ""

#~ msgid ""
#~ "Also note that host access or "
#~ "program end will also implicitly invoke"
#~ " for ``ti.sync()``."
#~ msgstr ""

#~ msgid "Boolean types should be represented using ``ti.i32``."
#~ msgstr ""

#~ msgid ""
#~ "Binary operations on different types "
#~ "will give you a promoted type, "
#~ "following the C programming language, "
#~ "e.g."
#~ msgstr ""

#~ msgid "``i32 + f32 = f32``"
#~ msgstr ""

#~ msgid "``f32 + f64 = f64``"
#~ msgstr ""

#~ msgid "``i32 + i64 = i64``"
#~ msgstr ""

#~ msgid ""
#~ "By default, numerical literals have "
#~ "32-bit precisions. For example, ``42`` "
#~ "has type ``ti.i32`` and ``3.14`` has "
#~ "type ``ti.f32``. Default integer and "
#~ "float-point precisions (``default_ip`` and "
#~ "``default_fp``) can be specified when "
#~ "initializing Taichi:"
#~ msgstr ""

#~ msgid ""
#~ "ti.init(..., default_fp=ti.f32)\n"
#~ "ti.init(..., default_fp=ti.f64)\n"
#~ "\n"
#~ "ti.init(..., default_ip=ti.i32)\n"
#~ "ti.init(..., default_ip=ti.i64)"
#~ msgstr ""

#~ msgid "Use ``ti.cast`` to cast scalar values."
#~ msgstr ""

#~ msgid ""
#~ "a = 1.4\n"
#~ "b = ti.cast(a, ti.i32)\n"
#~ "c = ti.cast(b, ti.f32)\n"
#~ "\n"
#~ "# Equivalently, use ``int()`` and ``float()``\n"
#~ "# to convert values to default float-point/integer types\n"
#~ "b = int(a)\n"
#~ "c = float(b)\n"
#~ "\n"
#~ "# Element-wise casts in matrices\n"
#~ "mat = ti.Matrix([[3.0, 0.0], [0.3, 0.1]])\n"
#~ "mat_int = mat.cast(int)\n"
#~ "mat_int2 = mat.cast(ti.i32)"
#~ msgstr ""

#~ msgid ""
#~ "'''\n"
#~ "level can be {}\n"
#~ "    ti.TRACE\n"
#~ "    ti.DEBUG\n"
#~ "    ti.INFO\n"
#~ "    ti.WARN\n"
#~ "    ti.ERR\n"
#~ "    ti.CRITICAL\n"
#~ "'''\n"
#~ "ti.set_logging_level(level)"
#~ msgstr ""

#~ msgid ""
#~ "The default logging level is "
#~ "``ti.INFO``. You can also override "
#~ "default logging level by setting the "
#~ "environment variable like ``TI_LOG_LEVEL=warn``."
#~ msgstr ""

#~ msgid ""
#~ "Run ``ti regression`` to show the "
#~ "difference between previous result in "
#~ "``benchmarks/baseline``. And you can see "
#~ "if the performance is increasing or "
#~ "decreasing after your commits. This is"
#~ " really helpful when your work is "
#~ "related to IR optimizations."
#~ msgstr ""

#~ msgid ""
#~ "Run ``ti baseline`` to save the "
#~ "benchmark result to ``benchmarks/baseline`` "
#~ "for furture comparsion, this may be "
#~ "executed on performance related PRs, "
#~ "before they are merged into master."
#~ msgstr ""

#~ msgid ""
#~ "Currently ``ti benchmark`` only support "
#~ "benchmarking number-of-statements, no "
#~ "time benchmarking is included since it"
#~ " depends on hardware performance and "
#~ "therefore hard to compare if the "
#~ "baseline is from another machine. We "
#~ "are to purchase a fixed-performance "
#~ "machine as a time benchmark server "
#~ "at some point. Discussion at: "
#~ "https://github.com/taichi-dev/taichi/issue/948"
#~ msgstr ""

#~ msgid ""
#~ "The suggested workflow for the "
#~ "performance related PR author to run "
#~ "the regression tests is:"
#~ msgstr ""

#~ msgid ""
#~ "Run ``ti benchmark && ti baseline`` "
#~ "in ``master`` to save the current "
#~ "performance as baseline."
#~ msgstr ""

#~ msgid ""
#~ "(If result OK) Run ``ti baseline`` "
#~ "to save stage 1 performance as "
#~ "baseline."
#~ msgstr ""

#~ msgid ""
#~ "To ensure that our tests covered "
#~ "every situations, we need to have "
#~ "**coverage report**. That is, to detect"
#~ " how many percent of code lines "
#~ "in is executed in test."
#~ msgstr ""

#~ msgid ""
#~ "You can use ``TI_IO`` macros to "
#~ "explicit define fields necessary in "
#~ "Taichi."
#~ msgstr ""

#~ msgid ""
#~ "# Python-scope\n"
#~ "a = ti.Vector(3, dt=ti.f32, shape=(5, 4))"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def add(tensor: ti.template(), delta: ti.i32):\n"
#~ "  for i in tensor:\n"
#~ "    tensor[i] += delta"
#~ msgstr ""

#~ msgid "We allocate two 1D tensors to simplify discussion:"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(dt=ti.f32, shape=128)\n"
#~ "y = ti.var(dt=ti.f32, shape=16)"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "ti.init(arch=ti.cpu)\n"
#~ "a = ti.var(ti.f32, 4)\n"
#~ "\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def foo():\n"
#~ "    a[0] = 1.0\n"
#~ "    print('a[0] = ', a[0]) # right\n"
#~ "    print(f'a[0] = {a[0]}') # wrong, f-string is not supported\n"
#~ "    print(\"a[0] = %f\" % a[0]) #"
#~ " wrong, formatted string is not "
#~ "supported\n"
#~ "\n"
#~ "foo()"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.f32, (2, 3))\n"
#~ "y = 1\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def inside_taichi_scope():\n"
#~ "    ti.static_print(y)\n"
#~ "    # => 1\n"
#~ "    ti.static_print(x.shape)\n"
#~ "    # => (2, 3)\n"
#~ "    ti.static_print(x.dtype)\n"
#~ "    # => DataType.float32\n"
#~ "    for i in range(4):\n"
#~ "            ti.static_print(i.dtype)\n"
#~ "            # => DataType.int32\n"
#~ "            # will only print once"
#~ msgstr ""

#~ msgid ""
#~ "ti.init(arch=ti.cpu, debug=True)\n"
#~ "\n"
#~ "x = ti.var(ti.f32, 128)\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def do_sqrt_all():\n"
#~ "    for i in x:\n"
#~ "        assert x[i] >= 0\n"
#~ "        x[i] = ti.sqrt(x)"
#~ msgstr ""

#~ msgid ""
#~ "@ti.func\n"
#~ "def copy(dst: ti.template(), src: ti.template()):\n"
#~ "    ti.static_assert(dst.shape == src.shape, "
#~ "\"copy() needs src and dst tensors "
#~ "to be same shape\")\n"
#~ "    for I in ti.grouped(src):\n"
#~ "        dst[I] = src[I]\n"
#~ "    return x % 2 == 1"
#~ msgstr ""

#~ msgid ""
#~ "You may use ``ti.init(advance_optimization=False)``"
#~ " to turn off advanced optimization "
#~ "and see if the issue still exists:"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "\n"
#~ "ti.init(advance_optimization=False)\n"
#~ "\n"
#~ "..."
#~ msgstr ""

#~ msgid "Differentiable programming (WIP)"
#~ msgstr ""

#~ msgid ""
#~ "This page is work in progress. "
#~ "Please check out `the DiffTaichi paper"
#~ " <https://arxiv.org/pdf/1910.00935.pdf>`_ and `video"
#~ " <https://www.youtube.com/watch?v=Z1xvAZve9aE>`_ to "
#~ "learn more about Taichi differentiable "
#~ "programming."
#~ msgstr ""

#~ msgid ""
#~ "The `DiffTaichi repo <https://github.com"
#~ "/yuanming-hu/difftaichi>`_ contains 10 "
#~ "differentiable physical simulators built with"
#~ " Taichi differentiable programming."
#~ msgstr ""

#~ msgid ""
#~ "Unlike tools such as TensorFlow where"
#~ " **immutable** output buffers are "
#~ "generated, the **imperative** programming "
#~ "paradigm adopted in Taichi allows "
#~ "programmers to freely modify global "
#~ "tensors. To make automatic differentiation "
#~ "well-defined under this setting, we "
#~ "make the following assumption on Taichi"
#~ " programs for differentiable programming:"
#~ msgstr ""

#~ msgid ""
#~ "If a global tensor element is "
#~ "written more than once, then starting"
#~ " from the second write, the write "
#~ "**must** come in the form of an"
#~ " atomic add (“accumulation\", using "
#~ "``ti.atomic_add`` or simply ``+=``)."
#~ msgstr ""

#~ msgid ""
#~ "No read accesses happen to a "
#~ "global tensor element, until its "
#~ "accumulation is done."
#~ msgstr ""

#~ msgid ""
#~ "Taichi programs that violate this rule"
#~ " has an undefined gradient behavior."
#~ msgstr ""

#~ msgid ""
#~ "**static for-loops** (e.g. ``for i "
#~ "in ti.static(range(4))``) will get unrolled"
#~ " by the Python frontend preprocessor "
#~ "and does not count as a level "
#~ "of loop."
#~ msgstr ""

#~ msgid ""
#~ "A few examples with neural network "
#~ "controllers optimized using differentiable "
#~ "simulators and brute-force gradient "
#~ "descent:"
#~ msgstr ""

#~ msgid ""
#~ "Apart from differentiating the simulation "
#~ "time steps, you can also automatically"
#~ " differentiate (negative) potential energies "
#~ "to get forces. Here is an `example"
#~ " <https://github.com/taichi-"
#~ "dev/taichi/blob/master/examples/mpm_lagrangian_forces.py>`_."
#~ msgstr ""

#~ msgid "Documentation WIP."
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "import os\n"
#~ "\n"
#~ "ti.init()\n"
#~ "\n"
#~ "pixels = ti.var(ti.u8, shape=(512, 512, 3))\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def paint():\n"
#~ "    for i, j, k in pixels:\n"
#~ "        pixels[i, j, k] = ti.random() * 255\n"
#~ "\n"
#~ "iterations = 1000\n"
#~ "gui = ti.GUI(\"Random pixels\", res=512)\n"
#~ "\n"
#~ "# mainloop\n"
#~ "for i in range(iterations):\n"
#~ "    paint()\n"
#~ "    gui.set_image(pixels)\n"
#~ "\n"
#~ "    filename = f'frame_{i:05d}.png'   # "
#~ "create filename with suffix png\n"
#~ "    print(f'Frame {i} is recorded in {filename}')\n"
#~ "    gui.show(filename)  # export and show in GUI"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "\n"
#~ "ti.init()\n"
#~ "\n"
#~ "pixels = ti.var(ti.u8, shape=(512, 512, 3))\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def set_pixels():\n"
#~ "    for i, j, k in pixels:\n"
#~ "        pixels[i, j, k] = ti.random() * 255\n"
#~ "\n"
#~ "set_pixels()\n"
#~ "filename = f'imwrite_export.png'\n"
#~ "ti.imwrite(pixels.to_numpy(), filename)\n"
#~ "print(f'The image has been saved to {filename}')"
#~ msgstr ""

#~ msgid ""
#~ "``ti.imwrite`` can export Taichi tensors "
#~ "(``ti.Matrix``, ``ti.Vector``, ``ti.var``) and "
#~ "numpy tensors ``np.ndarray``."
#~ msgstr ""

#~ msgid ""
#~ "Meanwhile, the resulted image type "
#~ "(grayscale, RGB, or RGBA) is determined"
#~ " by **the number of channels in "
#~ "the input tensor**, i.e., the length "
#~ "of the third dimension (``tensor.shape[2]``)."
#~ msgstr ""

#~ msgid ""
#~ "In other words, a tensor that has"
#~ " shape ``(w, h)`` or ``(w, h, "
#~ "1)`` will be exported as a "
#~ "grayscale image."
#~ msgstr ""

#~ msgid ""
#~ "If you want to export ``RGB`` or"
#~ " ``RGBA`` images instead, the input "
#~ "tensor should have a shape ``(w, "
#~ "h, 3)`` or ``(w, h, 4)`` "
#~ "respectively."
#~ msgstr ""

#~ msgid ""
#~ "All Taichi tensors have their own "
#~ "data types, such as ``ti.u8`` and "
#~ "``ti.f32``. Different data types can "
#~ "lead to different behaviors of "
#~ "``ti.imwrite``. Please check out :ref:`gui`"
#~ " for more details."
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "\n"
#~ "ti.init()\n"
#~ "\n"
#~ "pixels = ti.var(ti.u8, shape=(512, 512, 3))\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def paint():\n"
#~ "    for i, j, k in pixels:\n"
#~ "        pixels[i, j, k] = ti.random() * 255\n"
#~ "\n"
#~ "result_dir = \"./results\"\n"
#~ "video_manager = ti.VideoManager(output_dir=result_dir, "
#~ "framerate=24, automatic_build=False)\n"
#~ "\n"
#~ "for i in range(50):\n"
#~ "    paint()\n"
#~ "\n"
#~ "    pixels_img = pixels.to_numpy()\n"
#~ "    video_manager.write_frame(pixels_img)\n"
#~ "    print(f'\\rFrame {i+1}/50 is recorded', end='')\n"
#~ "\n"
#~ "print()\n"
#~ "print('Exporting .mp4 and .gif videos...')\n"
#~ "video_manager.make_video(gif=True, mp4=True)\n"
#~ "print(f'MP4 video is saved to "
#~ "{video_manager.get_output_filename(\".mp4\")}')\n"
#~ "print(f'GIF video is saved to "
#~ "{video_manager.get_output_filename(\".gif\")}')"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "import numpy as np\n"
#~ "\n"
#~ "ti.init(arch=ti.cpu)\n"
#~ "\n"
#~ "num_vertices = 1000\n"
#~ "pos = ti.Vector(3, dt=ti.f32, shape=(10, 10, 10))\n"
#~ "rgba = ti.Vector(4, dt=ti.f32, shape=(10, 10, 10))\n"
#~ "\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def place_pos():\n"
#~ "    for i, j, k in pos:\n"
#~ "        pos[i, j, k] = 0.1 * ti.Vector([i, j, k])\n"
#~ "\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def move_particles():\n"
#~ "    for i, j, k in pos:\n"
#~ "        pos[i, j, k] += ti.Vector([0.1, 0.1, 0.1])\n"
#~ "\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def fill_rgba():\n"
#~ "    for i, j, k in rgba:\n"
#~ "        rgba[i, j, k] = ti.Vector(\n"
#~ "            [ti.random(), ti.random(), ti.random(), ti.random()])\n"
#~ "\n"
#~ "\n"
#~ "place_pos()\n"
#~ "series_prefix = \"example.ply\"\n"
#~ "for frame in range(10):\n"
#~ "    move_particles()\n"
#~ "    fill_rgba()\n"
#~ "    # now adding each channel only"
#~ " supports passing individual np.array\n"
#~ "    # so converting into np.ndarray, reshape\n"
#~ "    # remember to use a temp "
#~ "var to store so you dont have "
#~ "to convert back\n"
#~ "    np_pos = np.reshape(pos.to_numpy(), (num_vertices, 3))\n"
#~ "    np_rgba = np.reshape(rgba.to_numpy(), (num_vertices, 4))\n"
#~ "    # create a PLYWriter\n"
#~ "    writer = ti.PLYWriter(num_vertices=num_vertices)\n"
#~ "    writer.add_vertex_pos(np_pos[:, 0], np_pos[:, 1], np_pos[:, 2])\n"
#~ "    writer.add_vertex_rgba(\n"
#~ "        np_rgba[:, 0], np_rgba[:, 1], np_rgba[:, 2], np_rgba[:, 3])\n"
#~ "    writer.export_frame_ascii(frame, series_prefix)"
#~ msgstr ""

#~ msgid ""
#~ "Blender requires an add-on called "
#~ "`Stop-motion-OBJ <https://github.com/neverhood311"
#~ "/Stop-motion-OBJ>`_ to load the "
#~ "result sequences. A very detailed "
#~ "explanation `video "
#~ "<https://www.youtube.com/watch?v=Ja7F7WHD39Q>`_ is "
#~ "provided by the author on how to"
#~ " install, enable, and use the add-"
#~ "on. Just keep in mind that "
#~ "significant changes in the workflow were"
#~ " made in their most recent test "
#~ "releases. To follow their instruction "
#~ "readme and video, please use ``v2.0.2``."
#~ msgstr ""

#~ msgid "Conversion between Taichi tensors and external arrays"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "import numpy as np\n"
#~ "\n"
#~ "ti.init()\n"
#~ "\n"
#~ "n = 4\n"
#~ "m = 7\n"
#~ "\n"
#~ "# Taichi tensors\n"
#~ "val = ti.var(ti.i32, shape=(n, m))\n"
#~ "vec = ti.Vector(3, dt=ti.i32, shape=(n, m))\n"
#~ "mat = ti.Matrix(3, 4, dt=ti.i32, shape=(n, m))\n"
#~ "\n"
#~ "# Scalar\n"
#~ "arr = np.ones(shape=(n, m), dtype=np.int32)\n"
#~ "\n"
#~ "val.from_numpy(arr)\n"
#~ "\n"
#~ "arr = val.to_numpy()\n"
#~ "\n"
#~ "# Vector\n"
#~ "arr = np.ones(shape=(n, m, 3), dtype=np.int32)\n"
#~ "\n"
#~ "vec.from_numpy(arr)\n"
#~ "\n"
#~ "arr = np.ones(shape=(n, m, 3, 1), dtype=np.int32)\n"
#~ "vec.from_numpy(arr)\n"
#~ "\n"
#~ "arr = vec.to_numpy()\n"
#~ "assert arr.shape == (n, m, 3)\n"
#~ "\n"
#~ "arr = vec.to_numpy(keep_dims=True)\n"
#~ "assert arr.shape == (n, m, 3, 1)\n"
#~ "\n"
#~ "# Matrix\n"
#~ "arr = np.ones(shape=(n, m, 3, 4), dtype=np.int32)\n"
#~ "\n"
#~ "mat.from_numpy(arr)\n"
#~ "\n"
#~ "arr = mat.to_numpy()\n"
#~ "assert arr.shape == (n, m, 3, 4)"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "import numpy as np\n"
#~ "\n"
#~ "ti.init()\n"
#~ "\n"
#~ "n = 4\n"
#~ "m = 7\n"
#~ "\n"
#~ "val = ti.var(ti.i32, shape=(n, m))\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def test_numpy(arr: ti.ext_arr()):\n"
#~ "  for i in range(n):\n"
#~ "    for j in range(m):\n"
#~ "      arr[i, j] += i + j\n"
#~ "\n"
#~ "a = np.empty(shape=(n, m), dtype=np.int32)\n"
#~ "\n"
#~ "for i in range(n):\n"
#~ "  for j in range(m):\n"
#~ "    a[i, j] = i * j\n"
#~ "\n"
#~ "test_numpy(a)\n"
#~ "\n"
#~ "for i in range(n):\n"
#~ "  for j in range(m):\n"
#~ "    assert a[i, j] == i * j + i + j"
#~ msgstr ""

#~ msgid ""
#~ "**Q:** What's the most convinent way "
#~ "to load images / textures into "
#~ "Taichi tensors?"
#~ msgstr ""

#~ msgid "**A:** Simply use ``tensor.from_numpy(ti.imread('filename.png'))``."
#~ msgstr ""

#~ msgid ""
#~ "**A:** No, but we provide them in"
#~ " an extension library `Taichi GLSL "
#~ "<https://taichi-glsl.readthedocs.io>`, install it"
#~ " using:"
#~ msgstr ""

#~ msgid ""
#~ "Or make use the extension library "
#~ "`Taichi THREE <https://github.com/taichi-"
#~ "dev/taichi_glsl>` to render images and "
#~ "update to GUI in real-time."
#~ msgstr ""

#~ msgid "**Q:** How do I declare a tensor with **dynamic length**?"
#~ msgstr ""

#~ msgid ""
#~ "**A:** What you want may be the"
#~ " ``dynamic`` SNode, a kind of sparse"
#~ " tensor, see :ref:`dynamic`."
#~ msgstr ""

#~ msgid ""
#~ "Or simply allocate a dense tensor "
#~ "large enough, and another 0-D tensor "
#~ "``tensor_len[None]`` for length record. But"
#~ " in fact, the ``dynamic`` SNode could"
#~ " be slower than the latter solution,"
#~ " due to the cost of maintaining "
#~ "the sparsity information."
#~ msgstr ""

#~ msgid ""
#~ "Restart the entire Taichi system "
#~ "(destroy all tensors and kernels): "
#~ "``ti.reset()``."
#~ msgstr ""

#~ msgid ""
#~ "``ti.init(log_level=ti.TRACE)`` is equivalent to "
#~ "``export TI_ARCH=trace``."
#~ msgstr ""

#~ msgid "(string) the window title"
#~ msgstr ""

#~ msgid "(scalar or tuple) resolution / size of the window"
#~ msgstr ""

#~ msgid "(np.array or Tensor) tensor containing the image, see notes below"
#~ msgstr ""

#~ msgid "``ti.var(shape=(x, y))``, a grey-scale image"
#~ msgstr ""

#~ msgid "``ti.var(shape=(x, y, 3))``, where `3` is for ``(r, g, b)`` channels"
#~ msgstr ""

#~ msgid "``ti.Vector(3, shape=(x, y))`` (see :ref:`vector`)"
#~ msgstr ""

#~ msgid "a ``np.ndarray`` which is the current image shown on the GUI."
#~ msgstr ""

#~ msgid ""
#~ "Get the RGBA shown image from the"
#~ " current GUI system which has four"
#~ " channels."
#~ msgstr ""

#~ msgid "(Matrix or Expr) the image you want to export"
#~ msgstr ""

#~ msgid ""
#~ "Export a ``np.ndarray`` or Taichi tensor"
#~ " (``ti.Matrix``, ``ti.Vector``, or ``ti.var``)"
#~ " to a specified location ``filename``."
#~ msgstr ""

#~ msgid ""
#~ "Please make sure that the input "
#~ "image has **a valid shape**. If "
#~ "you want to export a grayscale "
#~ "image, the input shape of tensor "
#~ "should be ``(height, weight)`` or "
#~ "``(height, weight, 1)``. For example:"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "\n"
#~ "ti.init()\n"
#~ "\n"
#~ "shape = (512, 512)\n"
#~ "type = ti.u8\n"
#~ "pixels = ti.var(dt=type, shape=shape)\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def draw():\n"
#~ "    for i, j in pixels:\n"
#~ "        pixels[i, j] = ti.random() * "
#~ "255    # integars between [0, 255] "
#~ "for ti.u8\n"
#~ "\n"
#~ "draw()\n"
#~ "\n"
#~ "ti.imwrite(pixels, f\"export_u8.png\")"
#~ msgstr ""

#~ msgid ""
#~ "Besides, for RGB or RGBA images, "
#~ "``ti.imwrite`` needs to receive a tensor"
#~ " which has shape ``(height, width, "
#~ "3)`` and ``(height, width, 4)`` "
#~ "individually."
#~ msgstr ""

#~ msgid ""
#~ "Generally the value of the pixels "
#~ "on each channel of a ``png`` image"
#~ " is an integar in [0, 255]. For"
#~ " this reason, ``ti.imwrite`` will **cast"
#~ " tensors** which has different datatypes"
#~ " all **into integars between [0, "
#~ "255]**. As a result, ``ti.imwrite`` has"
#~ " the following requirements for different"
#~ " datatypes of input tensors:"
#~ msgstr ""

#~ msgid ""
#~ "For float-type (``ti.f16``, ``ti.f32``, "
#~ "etc) input tensors, **the value of "
#~ "each pixel should be float between "
#~ "[0.0, 1.0]**. Otherwise ``ti.imwrite`` will"
#~ " first clip them into [0.0, 1.0]. "
#~ "Then they are multiplied by 256 "
#~ "and casted to integaters ranging from"
#~ " [0, 255]."
#~ msgstr ""

#~ msgid ""
#~ "For int-type (``ti.u8``, ``ti.u16``, "
#~ "etc) input tensors, **the value of "
#~ "each pixel can be any valid "
#~ "integer in its own bounds**. These "
#~ "integers in this tensor will be "
#~ "scaled to [0, 255] by being "
#~ "divided over the upper bound of "
#~ "its basic type accordingly."
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "\n"
#~ "ti.init()\n"
#~ "\n"
#~ "shape = (512, 512)\n"
#~ "channels = 3\n"
#~ "type = ti.f32\n"
#~ "pixels = ti.Matrix(channels, dt=type, shape=shape)\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def draw():\n"
#~ "    for i, j in pixels:\n"
#~ "        for k in ti.static(range(channels)):\n"
#~ "            pixels[i, j][k] = ti.random()"
#~ "   # floats between [0, 1] for "
#~ "ti.f32\n"
#~ "\n"
#~ "draw()\n"
#~ "\n"
#~ "ti.imwrite(pixels, f\"export_f32.png\")"
#~ msgstr ""

#~ msgid "Each value in this returned tensor is an integer in [0, 255]."
#~ msgstr ""

#~ msgid "(Matrix or Expr) the image to show in the GUI"
#~ msgstr ""

#~ msgid ""
#~ "# fractal.py\n"
#~ "\n"
#~ "import taichi as ti\n"
#~ "\n"
#~ "ti.init(arch=ti.gpu)\n"
#~ "\n"
#~ "n = 320\n"
#~ "pixels = ti.var(dt=ti.f32, shape=(n * 2, n))\n"
#~ "\n"
#~ "\n"
#~ "@ti.func\n"
#~ "def complex_sqr(z):\n"
#~ "    return ti.Vector([z[0]**2 - z[1]**2, z[1] * z[0] * 2])\n"
#~ "\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def paint(t: ti.f32):\n"
#~ "    for i, j in pixels:  # Parallized over all pixels\n"
#~ "        c = ti.Vector([-0.8, ti.cos(t) * 0.2])\n"
#~ "        z = ti.Vector([i / n - 1, j / n - 0.5]) * 2\n"
#~ "        iterations = 0\n"
#~ "        while z.norm() < 20 and iterations < 50:\n"
#~ "            z = complex_sqr(z) + c\n"
#~ "            iterations += 1\n"
#~ "        pixels[i, j] = 1 - iterations * 0.02\n"
#~ "\n"
#~ "\n"
#~ "gui = ti.GUI(\"Julia Set\", res=(n * 2, n))\n"
#~ "\n"
#~ "for i in range(1000000):\n"
#~ "    paint(i * 0.03)\n"
#~ "    gui.set_image(pixels)\n"
#~ "    gui.show()"
#~ msgstr ""

#~ msgid ""
#~ "When used with the CUDA backend on"
#~ " Windows or ARM devices (e.g. NVIDIA"
#~ " Jetson), Taichi by default allocates "
#~ "1 GB GPU memory for tensor "
#~ "storage. You can override this behavior"
#~ " by initializing with ``ti.init(arch=ti.cuda, "
#~ "device_memory_GB=3.4)`` to allocate ``3.4`` GB"
#~ " GPU memory, or ``ti.init(arch=ti.cuda, "
#~ "device_memory_fraction=0.3)`` to allocate ``30%``"
#~ " of the total GPU memory."
#~ msgstr ""

#~ msgid "(Sparse) tensors"
#~ msgstr ""

#~ msgid ""
#~ "Taichi is a data-oriented programming"
#~ " language where dense or spatially-"
#~ "sparse tensors are the first-class "
#~ "citizens. See :ref:`sparse` for more "
#~ "details on sparse tensors."
#~ msgstr ""

#~ msgid ""
#~ "In the code above, ``pixels = "
#~ "ti.var(dt=ti.f32, shape=(n * 2, n))`` "
#~ "allocates a 2D dense tensor named "
#~ "``pixels`` of size ``(640, 320)`` and"
#~ " element data type ``ti.f32`` (i.e. "
#~ "``float`` in C)."
#~ msgstr ""

#~ msgid ""
#~ "Computation resides in Taichi **kernels**. "
#~ "Kernel arguments must be type-hinted."
#~ " The language used in Taichi kernels"
#~ " and functions looks exactly like "
#~ "Python, yet the Taichi frontend compiler"
#~ " converts it into a language that "
#~ "is **compiled, statically-typed, lexically-"
#~ "scoped, parallel and differentiable**."
#~ msgstr ""

#~ msgid ""
#~ "Taichi **functions**, which can be "
#~ "called by Taichi kernels and other "
#~ "Taichi functions, should be defined with"
#~ " the keyword ``ti.func``."
#~ msgstr ""

#~ msgid ""
#~ "**Taichi-scopes v.s. Python-scopes**: "
#~ "everything decorated with ``ti.kernel`` and"
#~ " ``ti.func`` is in Taichi-scope, "
#~ "which will be compiled by the "
#~ "Taichi compiler. Everything else is in"
#~ " Python-scopes. They are simply "
#~ "Python code."
#~ msgstr ""

#~ msgid ""
#~ "Taichi kernels must be called in "
#~ "the Python-scope. I.e., **nested kernels"
#~ " are not supported**. Nested functions "
#~ "are allowed. **Recursive functions are "
#~ "not supported for now**."
#~ msgstr ""

#~ msgid "Taichi functions can only be called in Taichi-scope."
#~ msgstr ""

#~ msgid ""
#~ "**Struct-for loops** are particularly "
#~ "useful when iterating over (sparse) "
#~ "tensor elements. In the code above, "
#~ "``for i, j in pixels`` loops over"
#~ " all the pixel coordinates, i.e. "
#~ "``(0, 0), (0, 1), (0, 2), ... "
#~ ", (0, 319), (1, 0), ..., (639, "
#~ "319)``."
#~ msgstr ""

#~ msgid ""
#~ "Struct-for is the key to "
#~ ":ref:`sparse` in Taichi, as it will "
#~ "only loop over active elements in "
#~ "a sparse tensor. In dense tensors, "
#~ "all elements are active."
#~ msgstr ""

#~ msgid ""
#~ "Everything outside Taichi-scopes (``ti.func``"
#~ " and ``ti.kernel``) is simply Python "
#~ "code. In Python-scopes, you can "
#~ "access Taichi tensor elements using "
#~ "plain indexing syntax. For example, to"
#~ " access a single pixel of the "
#~ "rendered image in Python-scope, simply"
#~ " use:"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "pixels = ti.var(ti.f32, (1024, 512))\n"
#~ "\n"
#~ "pixels[42, 11] = 0.7  # store data into pixels\n"
#~ "print(pixels[42, 11]) # prints 0.7"
#~ msgstr ""

#~ msgid ""
#~ "Taichi provides helper functions such as"
#~ " ``from_numpy`` and ``to_numpy`` for "
#~ "transfer data between Taichi tensors and"
#~ " NumPy arrays, So that you can "
#~ "also use your favorite Python packages"
#~ " (e.g. ``numpy``, ``pytorch``, ``matplotlib``)"
#~ " together with Taichi. e.g.:"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "pixels = ti.var(ti.f32, (1024, 512))\n"
#~ "\n"
#~ "import numpy as np\n"
#~ "arr = np.random.rand(1024, 512)\n"
#~ "pixels.from_numpy(arr)   # load numpy data into taichi tensors\n"
#~ "\n"
#~ "import matplotlib.pyplot as plt\n"
#~ "arr = pixels.to_numpy()  # store taichi data into numpy arrays\n"
#~ "plt.imshow(arr)\n"
#~ "plt.show()\n"
#~ "\n"
#~ "import matplotlib.cm as cm\n"
#~ "cmap = cm.get_cmap('magma')\n"
#~ "gui = ti.GUI('Color map')\n"
#~ "while gui.running:\n"
#~ "    render_pixels()\n"
#~ "    arr = pixels.to_numpy()\n"
#~ "    gui.set_image(cmap(arr))\n"
#~ "    gui.show()"
#~ msgstr ""

#~ msgid ""
#~ "# misc/listgen_demo.py\n"
#~ "\n"
#~ "import taichi as ti\n"
#~ "\n"
#~ "ti.init(print_ir=True)\n"
#~ "\n"
#~ "x = ti.var(ti.i32)\n"
#~ "ti.root.dense(ti.i, 4).bitmasked(ti.i, 4).place(x)\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def func():\n"
#~ "    for i in x:\n"
#~ "        print(i)\n"
#~ "\n"
#~ "func()"
#~ msgstr ""

#~ msgid ""
#~ "For example, indexing is always needed"
#~ " when accessing elements in Taichi "
#~ "tensors, even if the tensor is 0D."
#~ " Use ``x[None] = 123`` to set "
#~ "the value in ``x`` if ``x`` is "
#~ "0D. This is because ``x = 123``"
#~ " will set ``x`` itself (instead of"
#~ " its containing value) to be the "
#~ "constant ``123`` in python syntax, and,"
#~ " unfortunately, we cannot modify this "
#~ "behavior."
#~ msgstr ""

#~ msgid ""
#~ "Python has relatively low performance. "
#~ "This can cause a performance issue "
#~ "when initializing large Taichi tensors "
#~ "with pure python scripts. A Taichi "
#~ "kernel should be used to initialize "
#~ "a huge tensor."
#~ msgstr ""

#~ msgid ""
#~ "In Taichi, *virtual indices* are used"
#~ " to locate elements in tensors, and"
#~ " *physical indices* are used to "
#~ "specify data layouts in memory."
#~ msgstr ""

#~ msgid ""
#~ "``SNode`` s in handy dense tensors "
#~ "(i.e., ``a = ti.var(ti.i32, shape=(128, "
#~ "256, 512))``) have **trivial** virtual-"
#~ "to-physical mapping, e.g. "
#~ "``physical_index_position[i] = i``."
#~ msgstr ""

#~ msgid ""
#~ "However, more complex data layouts, such"
#~ " as column-major 2D tensors can "
#~ "lead to ``SNodes`` with "
#~ "``physical_index_position[0] = 1`` and "
#~ "``physical_index_position[1] = 0``."
#~ msgstr ""

#~ msgid ""
#~ "a = ti.var(ti.f32, shape=(128, 32, 8))\n"
#~ "\n"
#~ "b = ti.var(ti.f32)\n"
#~ "ti.root.dense(ti.j, 32).dense(ti.i, 16).place(b)\n"
#~ "\n"
#~ "ti.get_runtime().materialize()\n"
#~ "\n"
#~ "mapping_a = a.snode().physical_index_position()\n"
#~ "\n"
#~ "assert mapping_a == {0: 0, 1: 1, 2: 2}\n"
#~ "\n"
#~ "mapping_b = b.snode().physical_index_position()\n"
#~ "\n"
#~ "assert mapping_b == {0: 1, 1: 0}\n"
#~ "# Note that b is column-major:\n"
#~ "# the virtual first index exposed "
#~ "to the user comes second in memory"
#~ " layout."
#~ msgstr ""

#~ msgid ""
#~ "Tensors (:ref:`scalar_tensor`) can be *placed*"
#~ " in a specific shape and *layout*."
#~ " Defining a proper layout can be "
#~ "critical to performance, especially for "
#~ "memory-bound applications. A carefully "
#~ "designed data layout can significantly "
#~ "improve cache/TLB-hit rates and "
#~ "cacheline utilization. Although when "
#~ "performance is not the first priority,"
#~ " you probably don't have to worry "
#~ "about it."
#~ msgstr ""

#~ msgid ""
#~ "In Taichi, the layout is defined "
#~ "in a recursive manner. See :ref:`snode`"
#~ " for more details about how this "
#~ "works. We suggest starting with the "
#~ "default layout specification (simply by "
#~ "specifying ``shape`` when creating tensors "
#~ "using ``ti.var/Vector/Matrix``), and then "
#~ "migrate to more advanced layouts using"
#~ " the ``ti.root.X`` syntax if necessary."
#~ msgstr ""

#~ msgid "For example, this declares a 0-D tensor:"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.f32)\n"
#~ "ti.root.place(x)\n"
#~ "# is equivalent to:\n"
#~ "x = ti.var(ti.f32, shape=())"
#~ msgstr ""

#~ msgid "This declares a 1D tensor of size ``3``:"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.f32)\n"
#~ "ti.root.dense(ti.i, 3).place(x)\n"
#~ "# is equivalent to:\n"
#~ "x = ti.var(ti.f32, shape=3)"
#~ msgstr ""

#~ msgid "This declares a 2D tensor of shape ``(3, 4)``:"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.f32)\n"
#~ "ti.root.dense(ti.ij, (3, 4)).place(x)\n"
#~ "# is equivalent to:\n"
#~ "x = ti.var(ti.f32, shape=(3, 4))"
#~ msgstr ""

#~ msgid ""
#~ "You may wonder, why not simply "
#~ "specify the ``shape`` of the tensor? "
#~ "Why bother using the more complex "
#~ "version? Good question, let go forward"
#~ " and figure out why."
#~ msgstr ""

#~ msgid ""
#~ "Since address spaces are linear in "
#~ "modern computers, for 1D Taichi tensors,"
#~ " the address of the ``i``-th element"
#~ " is simply ``i``."
#~ msgstr ""

#~ msgid ""
#~ "To store a multi-dimensional tensor, "
#~ "however, it has to be flattened, "
#~ "in order to fit into the 1D "
#~ "address space. For example, to store "
#~ "a 2D tensor of size ``(3, 2)``,"
#~ " there are two ways to do this:"
#~ msgstr ""

#~ msgid "Tensors of same size can be placed together."
#~ msgstr ""

#~ msgid ""
#~ "For example, this places two 1D "
#~ "tensors of size ``3`` (array of "
#~ "structure, AoS):"
#~ msgstr ""

#~ msgid ""
#~ "In contrast, this places two tensor "
#~ "placed separately (structure of array, "
#~ "SoA):"
#~ msgstr ""

#~ msgid ""
#~ "Normally, you don't have to worry "
#~ "about the performance nuances between "
#~ "different layouts, and should just "
#~ "define the simplest layout as a "
#~ "start. However, locality sometimes have "
#~ "a significant impact on the performance,"
#~ " especially when the tensor is huge."
#~ msgstr ""

#~ msgid ""
#~ "N = 200000\n"
#~ "pos = ti.var(ti.f32)\n"
#~ "vel = ti.var(ti.f32)\n"
#~ "ti.root.dense(ti.i, N).place(pos)\n"
#~ "ti.root.dense(ti.i, N).place(vel)\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def step():\n"
#~ "    pos[i] += vel[i] * dt\n"
#~ "    vel[i] += -k * pos[i] * dt"
#~ msgstr ""

#~ msgid ""
#~ "By default, when allocating a "
#~ "``ti.var``, it follows the simplest data"
#~ " layout."
#~ msgstr ""

#~ msgid ""
#~ "val = ti.var(ti.f32, shape=(32, 64, 128))\n"
#~ "# C++ equivalent: float val[32][64][128]"
#~ msgstr ""

#~ msgid ""
#~ "val = ti.var(ti.f32)\n"
#~ "ti.root.dense(ti.ijk, (8, 16, 32)).dense(ti.ijk, (4, 4, 4)).place(val)"
#~ msgstr ""

#~ msgid ""
#~ "Struct-fors on nested dense data "
#~ "structures will automatically follow their "
#~ "data order in memory. For example, "
#~ "if 2D scalar tensor ``A`` is "
#~ "stored in row-major order,"
#~ msgstr ""

#~ msgid ""
#~ "Struct-for loops on sparse tensors "
#~ "follow the same philosophy, and will "
#~ "be discussed further in :ref:`sparse`."
#~ msgstr ""

#~ msgid ""
#~ "A = ti.var(ti.f32)\n"
#~ "ti.root.dense(ti.ij, (256, 256)).place(A)"
#~ msgstr ""

#~ msgid ""
#~ "A = ti.var(ti.f32)\n"
#~ "ti.root.dense(ti.ji, (256, 256)).place(A) # Note ti.ji instead of ti.ij"
#~ msgstr ""

#~ msgid ""
#~ "density = ti.var(ti.f32)\n"
#~ "ti.root.dense(ti.ij, (128, 128)).dense(ti.ij, (8, 8)).place(density)"
#~ msgstr ""

#~ msgid ""
#~ "pos = ti.Vector(3, dt=ti.f32)\n"
#~ "vel = ti.Vector(3, dt=ti.f32)\n"
#~ "ti.root.dense(ti.i, 1024).place(pos, vel)\n"
#~ "# equivalent to\n"
#~ "ti.root.dense(ti.i, 1024).place(pos(0), pos(1), "
#~ "pos(2), vel(0), vel(1), vel(2))"
#~ msgstr ""

#~ msgid ""
#~ "pos = ti.Vector(3, dt=ti.f32)\n"
#~ "vel = ti.Vector(3, dt=ti.f32)\n"
#~ "for i in range(3):\n"
#~ "  ti.root.dense(ti.i, 1024).place(pos(i))\n"
#~ "for i in range(3):\n"
#~ "  ti.root.dense(ti.i, 1024).place(vel(i))"
#~ msgstr ""

#~ msgid ""
#~ "``ti.Matrix`` is for small matrices "
#~ "(e.g. `3x3`) only. If you have "
#~ "`64x64` matrices, you should consider "
#~ "using a 2D tensor of scalars."
#~ msgstr ""

#~ msgid ""
#~ "``ti.Vector(n, dt=ti.f32)`` or ``ti.Matrix(n, "
#~ "m, dt=ti.f32)`` to create tensors of "
#~ "vectors/matrices."
#~ msgstr ""

#~ msgid ""
#~ "as a an element of a global "
#~ "tensor. In this case, the tensor "
#~ "is an N-dimensional array of ``n "
#~ "by m`` matrices."
#~ msgstr ""

#~ msgid "As global tensors of matrices"
#~ msgstr ""

#~ msgid ""
#~ "(optional, scalar or tuple) shape the"
#~ " tensor of vectors, see :ref:`tensor`"
#~ msgstr ""

#~ msgid "For example, this creates a 5x4 tensor of 3x3 matrices: ::"
#~ msgstr ""

#~ msgid ""
#~ "# Python-scope\n"
#~ "a = ti.Matrix.var(3, 3, dt=ti.f32, shape=(5, 4))"
#~ msgstr ""

#~ msgid ""
#~ "In Python-scope, ``ti.var`` declares "
#~ ":ref:`scalar_tensor`, while ``ti.Matrix`` declares"
#~ " tensors of matrices."
#~ msgstr ""

#~ msgid "As global tensors of vectors"
#~ msgstr ""

#~ msgid "(tensor of matrices) the tensor of matrices"
#~ msgstr ""

#~ msgid "(scalar) index of the first tensor dimension"
#~ msgstr ""

#~ msgid "(scalar) index of the second tensor dimension"
#~ msgstr ""

#~ msgid ""
#~ "**Always** use two pair of square "
#~ "brackets to access scalar elements from"
#~ " tensors of matrices."
#~ msgstr ""

#~ msgid ""
#~ "The indices in the first pair of"
#~ " brackets locate the matrix inside "
#~ "the tensor of matrices;"
#~ msgstr ""

#~ msgid ""
#~ "For 0-D tensors of matrices, indices "
#~ "in the first pair of brackets "
#~ "should be ``[None]``."
#~ msgstr ""

#~ msgid "(Matrix) the transposed matrix of ``a``."
#~ msgstr ""

#~ msgid "(Matrix) the inverse of matrix ``a``."
#~ msgstr ""

#~ msgid ""
#~ "You may use ``ti.template()`` as a "
#~ "type hint to pass a tensor as "
#~ "an argument. For example:"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def copy(x: ti.template(), y: ti.template()):\n"
#~ "    for i in x:\n"
#~ "        y[i] = x[i]\n"
#~ "\n"
#~ "a = ti.var(ti.f32, 4)\n"
#~ "b = ti.var(ti.f32, 4)\n"
#~ "c = ti.var(ti.f32, 12)\n"
#~ "d = ti.var(ti.f32, 12)\n"
#~ "copy(a, b)\n"
#~ "copy(c, d)"
#~ msgstr ""

#~ msgid ""
#~ "However, the ``copy`` template shown "
#~ "above is not perfect. For example, "
#~ "it can only be used to copy "
#~ "1D tensors. What if we want to "
#~ "copy 2D tensors? Do we have to "
#~ "write another kernel?"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def copy(x: ti.template(), y: ti.template()):\n"
#~ "    for I in ti.grouped(y):\n"
#~ "        # I is a vector with "
#~ "same dimensionality with x and data "
#~ "type i32\n"
#~ "        # If y is 0D, then I"
#~ " = ti.Vector([]), which is equivalent "
#~ "to `None` when used in x[I]\n"
#~ "        # If y is 1D, then I = ti.Vector([i])\n"
#~ "        # If y is 2D, then I = ti.Vector([i, j])\n"
#~ "        # If y is 3D, then I = ti.Vector([i, j, k])\n"
#~ "        # ...\n"
#~ "        x[I] = y[I]\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def array_op(x: ti.template(), y: ti.template()):\n"
#~ "    # if tensor x is 2D:\n"
#~ "    for I in ti.grouped(x): # I"
#~ " is simply a 2D vector with "
#~ "data type i32\n"
#~ "        y[I + ti.Vector([0, 1])] = I[0] + I[1]\n"
#~ "\n"
#~ "    # then it is equivalent to:\n"
#~ "    for i, j in x:\n"
#~ "        y[i, j + 1] = i + j"
#~ msgstr ""

#~ msgid "Tensor metadata"
#~ msgstr ""

#~ msgid ""
#~ "Sometimes it is useful to get the"
#~ " data type (``tensor.dtype``) and shape "
#~ "(``tensor.shape``) of tensors. These "
#~ "attributes can be accessed in both "
#~ "Taichi- and Python-scopes."
#~ msgstr ""

#~ msgid ""
#~ "@ti.func\n"
#~ "def print_tensor_info(x: ti.template()):\n"
#~ "  print('Tensor dimensionality is', len(x.shape))\n"
#~ "  for i in ti.static(range(len(x.shape))):\n"
#~ "    print('Size alone dimension', i, 'is', x.shape[i])\n"
#~ "  ti.static_print('Tensor data type is', x.dtype)"
#~ msgstr ""

#~ msgid "For sparse tensors, the full domain shape will be returned."
#~ msgstr ""

#~ msgid ""
#~ "Loop over vector/matrix elements. Indices "
#~ "into Taichi matrices must be a "
#~ "compile-time constant. Indexing into taichi"
#~ " tensors can be run-time variables."
#~ " For example, if ``x`` is a 1-D"
#~ " tensor of 3D vector, accessed as "
#~ "``x[tensor_index][matrix index]``. The first "
#~ "index can be variable, yet the "
#~ "second must be a constant."
#~ msgstr ""

#~ msgid "For example, code for resetting this tensor of vectors should be"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def reset():\n"
#~ "  for i in x:\n"
#~ "    for j in ti.static(range(x.n)):\n"
#~ "      # The inner loop must be "
#~ "unrolled since j is a vector index"
#~ " instead\n"
#~ "      # of a global tensor index.\n"
#~ "      x[i][j] = 0"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "\n"
#~ "ti.init()\n"
#~ "\n"
#~ "@ti.data_oriented\n"
#~ "class Array2D:\n"
#~ "  def __init__(self, n, m, increment):\n"
#~ "    self.n = n\n"
#~ "    self.m = m\n"
#~ "    self.val = ti.var(ti.f32)\n"
#~ "    self.total = ti.var(ti.f32)\n"
#~ "    self.increment = increment\n"
#~ "    ti.root.dense(ti.ij, (self.n, self.m)).place(self.val)\n"
#~ "    ti.root.place(self.total)\n"
#~ "\n"
#~ "  @staticmethod\n"
#~ "  @ti.func\n"
#~ "  def clamp(x):  # Clamp to [0, 1)\n"
#~ "      return max(0, min(1 - 1e-6, x))\n"
#~ "\n"
#~ "  @ti.kernel\n"
#~ "  def inc(self):\n"
#~ "    for i, j in self.val:\n"
#~ "      ti.atomic_add(self.val[i, j], self.increment)\n"
#~ "\n"
#~ "  @ti.kernel\n"
#~ "  def inc2(self, increment: ti.i32):\n"
#~ "    for i, j in self.val:\n"
#~ "      ti.atomic_add(self.val[i, j], increment)\n"
#~ "\n"
#~ "  @ti.kernel\n"
#~ "  def reduce(self):\n"
#~ "    for i, j in self.val:\n"
#~ "      ti.atomic_add(self.total, self.val[i, j] * 4)\n"
#~ "\n"
#~ "arr = Array2D(128, 128, 3)\n"
#~ "\n"
#~ "double_total = ti.var(ti.f32, shape=())\n"
#~ "\n"
#~ "ti.root.lazy_grad()\n"
#~ "\n"
#~ "arr.inc()\n"
#~ "arr.inc.grad()\n"
#~ "assert arr.val[3, 4] == 3\n"
#~ "arr.inc2(4)\n"
#~ "assert arr.val[3, 4] == 7\n"
#~ "\n"
#~ "with ti.Tape(loss=arr.total):\n"
#~ "  arr.reduce()\n"
#~ "\n"
#~ "for i in range(arr.n):\n"
#~ "  for j in range(arr.m):\n"
#~ "    assert arr.val.grad[i, j] == 4\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def double():\n"
#~ "  double_total[None] = 2 * arr.total\n"
#~ "\n"
#~ "with ti.Tape(loss=double_total):\n"
#~ "  arr.reduce()\n"
#~ "  double()\n"
#~ "\n"
#~ "for i in range(arr.n):\n"
#~ "  for j in range(arr.m):\n"
#~ "    assert arr.val.grad[i, j] == 8"
#~ msgstr ""

#~ msgid ""
#~ "A Taichi tensor can be defined "
#~ "with **coordinate offsets**. The offsets "
#~ "will move tensor bounds so that "
#~ "tensor origins are no longer zero "
#~ "vectors. A typical use case is to"
#~ " support voxels with negative coordinates"
#~ " in physical simulations."
#~ msgstr ""

#~ msgid "a = ti.Matrix(2, 2, dt=ti.f32, shape=(32, 64), offset=(-16, 8))"
#~ msgstr ""

#~ msgid ""
#~ "In this way, the tensor's indices "
#~ "are from ``(-16, 8)`` to ``(16, "
#~ "72)`` (exclusive)."
#~ msgstr ""

#~ msgid ""
#~ "The dimensionality of tensor shapes "
#~ "should **be consistent** with that of"
#~ " the offset. Otherwise, a "
#~ "``AssertionError`` will be raised."
#~ msgstr ""

#~ msgid ""
#~ "a = ti.Matrix(2, 3, dt=ti.f32, "
#~ "shape=(32,), offset=(-16, ))          # Works!"
#~ "\n"
#~ "b = ti.Vector(3, dt=ti.f32, shape=(16, "
#~ "32, 64), offset=(7, 3, -4))   # "
#~ "Works!\n"
#~ "c = ti.Matrix(2, 1, dt=ti.f32, "
#~ "shape=None, offset=(32,))             # "
#~ "AssertionError\n"
#~ "d = ti.Matrix(3, 2, dt=ti.f32, "
#~ "shape=(32, 32), offset=(-16, ))       # "
#~ "AssertionError\n"
#~ "e = ti.var(dt=ti.i32, shape=16, offset=-16)"
#~ "                          # Works!\n"
#~ "f = ti.var(dt=ti.i32, shape=None, offset=-16)"
#~ "                        # AssertionError\n"
#~ "g = ti.var(dt=ti.i32, shape=(16, 32), "
#~ "offset=-16)                    # AssertionError"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "\n"
#~ "ti.init(arch=ti.cpu)\n"
#~ "var = ti.var(ti.f32, shape=1)\n"
#~ "\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def compute():\n"
#~ "    var[0] = 1.0\n"
#~ "    print(\"Setting var[0] =\", var[0])\n"
#~ "\n"
#~ "\n"
#~ "compute()\n"
#~ "ti.print_profile_info()"
#~ msgstr ""

#~ msgid ""
#~ "import taichi as ti\n"
#~ "\n"
#~ "ti.init(ti.cpu, kernel_profiler=True)\n"
#~ "var = ti.var(ti.f32, shape=1)\n"
#~ "\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def compute():\n"
#~ "    var[0] = 1.0\n"
#~ "\n"
#~ "\n"
#~ "compute()\n"
#~ "ti.kernel_profiler_print()"
#~ msgstr ""

#~ msgid "Tensors of scalars"
#~ msgstr ""

#~ msgid "(DataType) type of the tensor element"
#~ msgstr ""

#~ msgid "(optional, scalar or tuple) the shape of tensor"
#~ msgstr ""

#~ msgid ""
#~ "For example, this creates a *dense* "
#~ "tensor with four ``int32`` as elements:"
#~ " ::"
#~ msgstr ""

#~ msgid "x = ti.var(ti.i32, shape=4)"
#~ msgstr ""

#~ msgid "This creates a 4x3 *dense* tensor with ``float32`` elements: ::"
#~ msgstr ""

#~ msgid "x = ti.var(ti.f32, shape=(4, 3))"
#~ msgstr ""

#~ msgid ""
#~ "If shape is ``()`` (empty tuple), "
#~ "then a 0-D tensor (scalar) is "
#~ "created: ::"
#~ msgstr ""

#~ msgid "x = ti.var(ti.f32, shape=())"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.f32)\n"
#~ "ti.root.dense(ti.ij, (4, 3)).place(x)\n"
#~ "# equivalent to: x = ti.var(ti.f32, shape=(4, 3))"
#~ msgstr ""

#~ msgid ""
#~ "Not providing ``shape`` allows you to"
#~ " *place* the tensor in a layout "
#~ "other than the default *dense*, see "
#~ ":ref:`layout` for more details."
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.f32)\n"
#~ "x[None] = 1 # ERROR: x not placed!"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.f32, shape=())\n"
#~ "@ti.kernel\n"
#~ "def func():\n"
#~ "    x[None] = 1\n"
#~ "\n"
#~ "func()\n"
#~ "y = ti.var(ti.f32, shape=())\n"
#~ "# ERROR: cannot create tensor after kernel invocation!"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.f32, shape=())\n"
#~ "x[None] = 1\n"
#~ "y = ti.var(ti.f32, shape=())\n"
#~ "# ERROR: cannot create tensor after "
#~ "any tensor accesses from the Python-"
#~ "scope!"
#~ msgstr ""

#~ msgid "You can access an element of the Taichi tensor by an index or indices."
#~ msgstr ""

#~ msgid "(Tensor) the tensor of scalars"
#~ msgstr ""

#~ msgid "This extracts the element value at index ``[3, 4]`` of tensor ``a``: ::"
#~ msgstr ""

#~ msgid ""
#~ "This sets the element value at "
#~ "index ``2`` of 1D tensor ``b`` to"
#~ " ``5``: ::"
#~ msgstr ""

#~ msgid ""
#~ "The returned value can also be "
#~ "``Vector`` / ``Matrix`` if ``a`` is "
#~ "a tensor of vector / matrix, see"
#~ " :ref:`vector` for more details."
#~ msgstr ""

#~ msgid "(Tensor) the tensor"
#~ msgstr ""

#~ msgid "(tuple) the shape of tensor ``a``"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.i32, (6, 5))\n"
#~ "x.shape  # (6, 5)\n"
#~ "\n"
#~ "y = ti.var(ti.i32, 6)\n"
#~ "y.shape  # (6,)\n"
#~ "\n"
#~ "z = ti.var(ti.i32, ())\n"
#~ "z.shape  # ()"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.i32, (2, 3))\n"
#~ "x.dtype  # ti.i32"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(ti.i32)\n"
#~ "y = ti.var(ti.i32)\n"
#~ "blk1 = ti.root.dense(ti.ij, (6, 5))\n"
#~ "blk2 = blk1.dense(ti.ij, (3, 2))\n"
#~ "blk1.place(x)\n"
#~ "blk2.place(y)\n"
#~ "\n"
#~ "x.parent()   # blk1\n"
#~ "y.parent()   # blk2\n"
#~ "y.parent(2)  # blk1"
#~ msgstr ""

#~ msgid "(tensor) tensor(s) to be placed"
#~ msgstr ""

#~ msgid "The following code places two 0-D tensors named ``x`` and ``y``:"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(dt=ti.i32)\n"
#~ "y = ti.var(dt=ti.f32)\n"
#~ "ti.root.place(x, y)\n"
#~ "assert x.snode() == y.snode()"
#~ msgstr ""

#~ msgid "(Tensor)"
#~ msgstr ""

#~ msgid "(tuple of integers) the shape of tensor"
#~ msgstr ""

#~ msgid "Equivalent to ``tensor.snode().shape``."
#~ msgstr ""

#~ msgid ""
#~ "ti.root.dense(ti.ijk, (3, 5, 4)).place(x)\n"
#~ "x.shape # returns (3, 5, 4)"
#~ msgstr ""

#~ msgid "(SNode) the structual node where ``tensor`` is placed"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(dt=ti.i32)\n"
#~ "y = ti.var(dt=ti.f32)\n"
#~ "ti.root.place(x, y)\n"
#~ "x.snode()"
#~ msgstr ""

#~ msgid "(scalar or tuple) shape the tensor of vectors"
#~ msgstr ""

#~ msgid "The following code places a 1-D tensor of size ``3``:"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(dt=ti.i32)\n"
#~ "ti.root.dense(ti.i, 3).place(x)"
#~ msgstr ""

#~ msgid "The following code places a 2-D tensor of shape ``(3, 4)``:"
#~ msgstr ""

#~ msgid ""
#~ "x = ti.var(dt=ti.i32)\n"
#~ "ti.root.dense(ti.ij, (3, 4)).place(x)"
#~ msgstr ""

#~ msgid "The following places a 1-D dynamic tensor of maximum size ``16``:"
#~ msgstr ""

#~ msgid "Taichi tensors like powers of two"
#~ msgstr ""

#~ msgid ""
#~ "Non-power-of-two tensor dimensions "
#~ "are promoted into powers of two "
#~ "and thus these tensors will occupy "
#~ "more virtual address space. For example,"
#~ " a (dense) tensor of size ``(18, "
#~ "65)`` will be materialized as ``(32, "
#~ "128)``."
#~ msgstr ""

#~ msgid ""
#~ "Kernel arguments must be type-hinted."
#~ " Kernels can have at most 8 "
#~ "parameters, e.g.,"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def print_xy(x: ti.i32, y: ti.f32):\n"
#~ "    print(x + y)"
#~ msgstr ""

#~ msgid ""
#~ "A kernel can have a **scalar** "
#~ "return value. If a kernel has a"
#~ " return value, it must be type-"
#~ "hinted. The return value will be "
#~ "automatically cast into the hinted type."
#~ " e.g.,"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def add_xy(x: ti.f32, y: ti.f32) -> ti.i32:\n"
#~ "    return x + y  # same as: ti.cast(x + y, ti.i32)\n"
#~ "\n"
#~ "res = add_xy(2.3, 1.1)\n"
#~ "print(res)  # 3, since return type is ti.i32"
#~ msgstr ""

#~ msgid ""
#~ "For now, we only support one "
#~ "scalar as return value. Returning "
#~ "``ti.Matrix`` or ``ti.Vector`` is not "
#~ "supported. Python-style tuple return is"
#~ " not supported either. For example:"
#~ msgstr ""

#~ msgid ""
#~ "We also support **template arguments** "
#~ "(see :ref:`template_metaprogramming`) and **external"
#~ " array arguments** (see :ref:`external`) in"
#~ " Taichi kernels."
#~ msgstr ""

#~ msgid ""
#~ "Use ``@ti.func`` to decorate your Taichi"
#~ " functions. These functions are callable"
#~ " only in `Taichi`-scope. Do not call"
#~ " them in `Python`-scopes."
#~ msgstr ""

#~ msgid ""
#~ "@ti.func\n"
#~ "def laplacian(t, i, j):\n"
#~ "    return inv_dx2 * (\n"
#~ "        -4 * p[t, i, j] + "
#~ "p[t, i, j - 1] + p[t, i, "
#~ "j + 1] + p[t, i + 1, "
#~ "j] +\n"
#~ "        p[t, i - 1, j])\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def fdtd(t: ti.i32):\n"
#~ "    for i in range(n_grid): # Parallelized\n"
#~ "        for j in range(n_grid): # "
#~ "Serial loops in each parallel threads"
#~ "\n"
#~ "            laplacian_p = laplacian(t - 2, i, j)\n"
#~ "            laplacian_q = laplacian(t - 1, i, j)\n"
#~ "            p[t, i, j] = 2 * p[t - 1, i, j] + (\n"
#~ "                c * c * dt * dt + c * alpha * dt) * laplacian_q - p[\n"
#~ "                           t - 2, i, j] - c * alpha * dt * laplacian_p"
#~ msgstr ""

#~ msgid ""
#~ "# Bad function - two return statements\n"
#~ "@ti.func\n"
#~ "def safe_sqrt(x):\n"
#~ "  if x >= 0:\n"
#~ "    return ti.sqrt(x)\n"
#~ "  else:\n"
#~ "    return 0.0\n"
#~ "\n"
#~ "# Good function - single return statement\n"
#~ "@ti.func\n"
#~ "def safe_sqrt(x):\n"
#~ "  rst = 0.0\n"
#~ "  if x >= 0:\n"
#~ "    rst = ti.sqrt(x)\n"
#~ "  else:\n"
#~ "    rst = 0.0\n"
#~ "  return rst"
#~ msgstr ""

#~ msgid "Function arguments are passed by value."
#~ msgstr ""

#~ msgid ""
#~ "Unlike functions, **kernels do not "
#~ "support vectors or matrices as "
#~ "arguments**:"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def my_kernel():\n"
#~ "  for i, j in tensor_a:\n"
#~ "    tensor_b[i, j] = some_function(tensor_a[i, j])"
#~ msgstr ""

#~ msgid "The tensors and function be aliased to new names with ``ti.static``:"
#~ msgstr ""

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def my_kernel():\n"
#~ "  a, b, fun = ti.static(tensor_a, tensor_b, some_function)\n"
#~ "  for i,j in a:\n"
#~ "    b[i,j] = fun(a[i,j])"
#~ msgstr ""

#~ msgid ""
#~ "For example, consider class kernel to"
#~ " compute the 2-D laplacian of some"
#~ " tensor:"
#~ msgstr ""

#~ msgid ""
#~ "Here, we are using it for "
#~ "*compile-time const values*, i.e. the "
#~ "**tensor/function handles** are constants at"
#~ " compile time."
#~ msgstr ""

#~ msgid "Tensors and matrices"
#~ msgstr ""

#~ msgid ""
#~ "Tensors are global variables provided by"
#~ " Taichi. Tensors can be either sparse"
#~ " or dense. An element of a "
#~ "tensor can be either a scalar or"
#~ " a vector/matrix."
#~ msgstr ""

#~ msgid ""
#~ "Although mathematically matrices are treated"
#~ " as 2D tensors, in Taichi, **tensor**"
#~ " and **matrix** are two completely "
#~ "different concepts. Matrices can be used"
#~ " as tensor elements, so you can "
#~ "have tensors with each element being "
#~ "a matrix."
#~ msgstr ""

#~ msgid "Every global variable is an N-dimensional tensor."
#~ msgstr ""

#~ msgid "Global ``scalars`` are treated as 0-D tensors of scalars."
#~ msgstr ""

#~ msgid "Tensors are always accessed using indices"
#~ msgstr ""

#~ msgid "E.g. ``x[i, j, k]`` if ``x`` is a scalar 3D tensor."
#~ msgstr ""

#~ msgid ""
#~ "Even when accessing 0-D tensor ``x``,"
#~ " use ``x[None] = 0`` instead of "
#~ "``x = 0``. Please **always** use "
#~ "indexing to access entries in tensors."
#~ msgstr ""

#~ msgid "Tensor values are initially zero."
#~ msgstr ""

#~ msgid "Sparse tensors are initially inactive."
#~ msgstr ""

#~ msgid "Tensors of matrices"
#~ msgstr ""

#~ msgid "Tensor elements can also be matrices."
#~ msgstr ""

#~ msgid ""
#~ "Suppose you have a ``128 x 64``"
#~ " tensor called ``A``, each element "
#~ "containing a ``3 x 2`` matrix. To"
#~ " allocate a ``128 x 64`` tensor "
#~ "of ``3 x 2`` matrix, use the "
#~ "statement ``A = ti.Matrix(3, 2, "
#~ "dt=ti.f32, shape=(128, 64))``."
#~ msgstr ""

#~ msgid ""
#~ "As you may have noticed, there are"
#~ " **two** indexing operators ``[]`` when "
#~ "you load an matrix element from a"
#~ " global tensor of matrices: the first"
#~ " is for tensor indexing, the second"
#~ " for matrix indexing."
#~ msgstr ""

#~ msgid ""
#~ "If you have a dimension that is"
#~ " too large (e.g. ``64``), it's better"
#~ " to declare a tensor of size "
#~ "``64``. E.g., instead of declaring "
#~ "``ti.Matrix(64, 32, dt=ti.f32, shape=(3, "
#~ "2))``, declare ``ti.Matrix(3, 2, dt=ti.f32,"
#~ " shape=(64, 32))``. Try to put large"
#~ " dimensions to tensors instead of "
#~ "matrices."
#~ msgstr ""

#~ msgid ""
#~ "as an element of a global tensor."
#~ " In this case, the tensor is an"
#~ " N-dimensional array of ``n`` component "
#~ "vectors."
#~ msgstr ""

#~ msgid "For example, this creates a 5x4 tensor of 3 component vectors: ::"
#~ msgstr ""

#~ msgid ""
#~ "# Python-scope\n"
#~ "a = ti.Vector.var(3, dt=ti.f32, shape=(5, 4))"
#~ msgstr ""

#~ msgid ""
#~ "In Python-scope, ``ti.var`` declares "
#~ ":ref:`scalar_tensor`, while ``ti.Vector`` declares"
#~ " tensors of vectors."
#~ msgstr ""

#~ msgid "(tensor of Vector) the vector"
#~ msgstr ""

#~ msgid ""
#~ "**Always** use two pairs of square "
#~ "brackets to access scalar elements from"
#~ " tensors of vectors."
#~ msgstr ""

#~ msgid ""
#~ "The indices in the first pair of"
#~ " brackets locate the vector inside "
#~ "the tensor of vectors;"
#~ msgstr ""

#~ msgid ""
#~ "For 0-D tensors of vectors, indices "
#~ "in the first pair of brackets "
#~ "should be ``[None]``."
#~ msgstr ""

#~ msgid "(Vector)"
#~ msgstr ""

#~ msgid "(Vector) the normalized / unit vector of ``a``"
#~ msgstr ""

#~ msgid "(Vector, 2 or 3 components)"
#~ msgstr ""

#~ msgid "(Vector of the same size as a)"
#~ msgstr ""

#~ msgid "(Matrix) the outer product of ``a`` and ``b``"
#~ msgstr ""

#~ msgid "(Vector) vector with all components of ``a`` casted into type ``dt``"
#~ msgstr ""

#~ msgid "(Vector or tensor of Vector)"
#~ msgstr ""

#~ msgid ""
#~ "(scalar) return the dimensionality of "
#~ "vector ``a``  E.g., ::      # Taichi-"
#~ "scope     a = ti.Vector([1, 2, 3])"
#~ "     a.n  # 3  ::     # Python-"
#~ "scope     a = ti.Vector.var(3, dt=ti.f32, "
#~ "shape=())     a.n  # 3"
#~ msgstr ""

#~ msgid "# Python-scope a = ti.Vector.var(3, dt=ti.f32, shape=()) a.n  # 3"
#~ msgstr ""

#~ msgid ""
#~ "Add some simple code make use of"
#~ " our ``ti.log10`` to make sure it "
#~ "works well. Hint: You may pass/return"
#~ " values to/from Taichi-scope using "
#~ "0-D tensors, i.e. ``r[None]``."
#~ msgstr ""

#~ msgid ""
#~ "# Run this test on all backends except for OpenGL\n"
#~ "@ti.test(excludes=[ti.opengl])\n"
#~ "def test_sparse_tensor():\n"
#~ "    # ... (some tests that "
#~ "requires sparse feature which is not "
#~ "supported by OpenGL)"
#~ msgstr ""

#~ msgid ""
#~ "# Run this test on all backends except for OpenGL\n"
#~ "@ti.test(extensions=[ti.extension.sparse])\n"
#~ "def test_sparse_tensor():\n"
#~ "    # ... (some tests that "
#~ "requires sparse feature which is not "
#~ "supported by OpenGL)"
#~ msgstr ""

